var OHLCV_INDICATORS;

/******/ (() => {
    // webpackBootstrap
    /******/ "use strict";
    /******/ // The require scope
    /******/    var t = {
        /******/ // define getter functions for harmony exports
        /******/ d: (r, e) => {
            /******/ for (var n in e) 
            /******/ t.o(e, n) && !t.o(r, n) && 
            /******/ Object.defineProperty(r, n, {
                enumerable: !0,
                get: e[n]
            })
            /******/;
            /******/        },
        /******/ o: (t, r) => Object.prototype.hasOwnProperty.call(t, r)
        /******/ ,
        /******/ // define __esModule on exports
        /******/ r: t => {
            /******/ "undefined" != typeof Symbol && Symbol.toStringTag && 
            /******/ Object.defineProperty(t, Symbol.toStringTag, {
                value: "Module"
            })
            /******/ , Object.defineProperty(t, "__esModule", {
                value: !0
            });
        }
        /******/    }, r = {};
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/define property getters */
    /******/    
    // This entry need to be wrapped in an IIFE because it declares 'OHLCV_INDICATORS' on top-level, which conflicts with the current library output.
    (() => {
        // ESM COMPAT FLAG
        t.r(r), 
        // EXPORTS
        t.d(r, {
            default: () => /* binding */ bo
        });
        // ./src/core-functions/pushToMain.js
        var e = function(t, r, e) {
            if (0 === e.length) return !1;
            for (var n = t.verticalOhlcv, o = !0, i = 0; i < e.length; i++) {
                var a = e[i];
                if (!n.hasOwnProperty(a)) {
                    o = !1;
                    break;
                }
                var u = n[a][r];
                if (null == u || Number.isNaN(u)) {
                    o = !1;
                    break;
                }
            }
            return o;
        };
        // ./src/utilities/validators.js
        function n(t, r) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, r) {
                var e = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != e) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (e = e.call(t)).next, 0 === r) {
                            if (Object(e) !== e) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(e)).done) && (u.push(n.value), u.length !== r); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != e.return && (a = e.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, r) || i(t, r) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function o(t, r) {
            var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!e) {
                if (Array.isArray(t) || (e = i(t)) || r && t && "number" == typeof t.length) {
                    e && (t = e);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var a, u = !0, l = !1;
            return {
                s: function() {
                    e = e.call(t);
                },
                n: function() {
                    var t = e.next();
                    return u = t.done, t;
                },
                e: function(t) {
                    l = !0, a = t;
                },
                f: function() {
                    try {
                        u || null == e.return || e.return();
                    } finally {
                        if (l) throw a;
                    }
                }
            };
        }
        function i(t, r) {
            if (t) {
                if ("string" == typeof t) return a(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? a(t, r) : void 0;
            }
        }
        function a(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var u = function(t, r) {
            if (!Array.isArray(t)) throw new Error('Property "inputParams" must be an "Array" or "Set".');
            var e, n = o(t);
            try {
                for (n.s(); !(e = n.n()).done; ) {
                    var i, a = o(e.value.params);
                    try {
                        for (a.s(); !(i = a.n()).done; ) {
                            var u = i.value;
                            if ("number" == typeof u && u > r) throw console.log(u, r), new Error("At least one of the params of the indicator is greater than the input OHLCV length. Make sure to have enough datapoints in the input OHLCV.");
                        }
                    } catch (t) {
                        a.e(t);
                    } finally {
                        a.f();
                    }
                }
            } catch (t) {
                n.e(t);
            } finally {
                n.f();
            }
        }, l = function(t) {
            if (!0 === t.isComputed) throw Error('ohlcv is already computed, you can not add new indicators after "compute", "getLastValues" , "getDataAsCols" or "getData" methods are called.');
        }, c = function(t, r, e) {
            if (!Array.isArray(t)) throw new Error('Param "'.concat(r, '" must be an array in "').concat(e, '".'));
            return !0;
        }, s = function(t, r, e) {
            if (t instanceof Object == !1) throw new Error('Param "'.concat(r, '" must be an object in "').concat(e, '".'));
            return !0;
        }, f = function(t, r, e, n) {
            if (c(t, "arrayOptions", "".concat(n, ".").concat(e, ".validateArrayOptions")), 
            !t.includes(r.toString())) throw new Error('Param "'.concat(e, '" must be any of the following values [').concat(t.join(", "), '] in "').concat(n, '".'));
            return !0;
        }, y = function(t, r, e) {
            if ("boolean" != typeof t) throw new Error('Param "'.concat(r, '" must be an boolean in "').concat(e, '".'));
            return !0;
        }, p = function(t, r, e, n) {
            s(r, "options", "".concat(n, ".").concat(e, ".validateNumber"));
            var o = r.allowDecimals, i = void 0 !== o && o, a = r.min, u = r.max, l = i ? "number" : "integer";
            // 1) check that value is a number (and integer if decimals not allowed)
            if ("number" != typeof t || !1 === i && !Number.isInteger(t)) throw new Error('Param "'.concat(e, '" must be an ').concat(l, ' in "').concat(n, '".'));
            // 2) validate types of min and max if they’re provided
                        if (void 0 !== a && "number" != typeof a) throw new Error('Param "min" must be a valid '.concat(l, ' (if provided) in "').concat(n, ".").concat(e, '.validateNumber".'));
            if (void 0 !== u && "number" != typeof u) throw new Error('Param "max" must be a valid '.concat(l, ' (if provided) in "').concat(n, ".").concat(e, '.validateNumber".'));
            // 3) if both were provided, ensure min < max
                        if (void 0 !== a && void 0 !== u && a >= u) throw new Error('Param "min" must be less than "max" in "'.concat(n, ".").concat(e, '.validateNumber".'));
            // 4) check value against min (if set)
                        if (void 0 !== a && t < a) throw new Error('Param "'.concat(e, '" must be an ').concat(l, " ≥ ").concat(a, ' in "').concat(n, '".'));
            // 5) check value against max (if set)
                        if (void 0 !== u && t > u) throw new Error('Param "'.concat(e, '" must be an ').concat(l, " ≤ ").concat(u, ' in "').concat(n, '".'));
            return !0;
        }, h = function(t, r, e) {
            if (c(t, r, e), 2 !== t.length) throw new Error('Invalid "'.concat(r, '" array length: expected 2 items, but got ').concat(t.length, ' in "').concat(e, ".").concat(r, '".'));
            var o = n(t, 2), i = o[0], a = o[1];
            if (p(i, {
                min: -100,
                max: a,
                allowDecimals: !1
            }, "min", e), p(a, {
                min: i,
                max: 100,
                allowDecimals: !1
            }, "max", e), i === a) throw new Error('Invalid "min" can not be equal to "max" property in "'.concat(e, ".").concat(r, '".'));
            return !0;
        }, v = function(t, r, e) {
            if ("string" != typeof t || !t.length) throw new Error('Invalid "'.concat(r, '" property in "').concat(e, '". Only strings are accepted.'));
            return !0;
        }, // 0, 1, 2 or 3
        // The maximum value of DP and Big.DP.
        d = 1e6, // 0 to 1000000
        // The maximum magnitude of the exponent argument to the pow method.
        m = 1e6, // true or false
        /**************************************************************************************************/
        // Error messages.
        b = "[big.js] ", g = b + "Invalid ", w = g + "decimal places", S = g + "rounding mode", O = b + "Division by zero", 
        // The shared prototype object.
        A = {}, j = void 0, N = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
        /*
 * Round Big x to a maximum of sd significant digits using rounding mode rm.
 *
 * x {Big} The Big to round.
 * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.
 * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 * [more] {boolean} Whether the result of division was truncated.
 */
        function P(t, r, e, n) {
            var o = t.c;
            if (e === j && (e = t.constructor.RM), 0 !== e && 1 !== e && 2 !== e && 3 !== e) throw Error(S);
            if (r < 1) n = 3 === e && (n || !!o[0]) || 0 === r && (1 === e && o[0] >= 5 || 2 === e && (o[0] > 5 || 5 === o[0] && (n || o[1] !== j))), 
            o.length = 1, n ? (
            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
            t.e = t.e - r + 1, o[0] = 1) : 
            // Zero.
            o[0] = t.e = 0; else if (r < o.length) {
                // Round up?
                if (
                // xc[sd] is the digit after the digit that may be rounded up.
                n = 1 === e && o[r] >= 5 || 2 === e && (o[r] > 5 || 5 === o[r] && (n || o[r + 1] !== j || 1 & o[r - 1])) || 3 === e && (n || !!o[0]), 
                // Remove any digits after the required precision.
                o.length = r, n) 
                // Rounding up may mean the previous digit has to be rounded up.
                for (;++o[--r] > 9; ) if (o[r] = 0, 0 === r) {
                    ++t.e, o.unshift(1);
                    break;
                }
                // Remove trailing zeros.
                                for (r = o.length; !o[--r]; ) o.pop();
            }
            return t;
        }
        /*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 */        function T(t, r, e) {
            var n = t.e, o = t.c.join(""), i = o.length;
            // Exponential notation?
                        if (r) o = o.charAt(0) + (i > 1 ? "." + o.slice(1) : "") + (n < 0 ? "e" : "e+") + n;
            // Normal notation.
             else if (n < 0) {
                for (;++n; ) o = "0" + o;
                o = "0." + o;
            } else if (n > 0) if (++n > i) for (n -= i; n--; ) o += "0"; else n < i && (o = o.slice(0, n) + "." + o.slice(n)); else i > 1 && (o = o.charAt(0) + "." + o.slice(1));
            return t.s < 0 && e ? "-" + o : o;
        }
        // Prototype/instance methods
        /*
 * Return a new Big whose value is the absolute value of this Big.
 */        A.abs = function() {
            var t = new this.constructor(this);
            return t.s = 1, t;
        }, 
        /*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
 */
        A.cmp = function(t) {
            var r, e = this, n = e.c, o = (t = new e.constructor(t)).c, i = e.s, a = t.s, u = e.e, l = t.e;
            // Either zero?
                        if (!n[0] || !o[0]) return n[0] ? i : o[0] ? -a : 0;
            // Signs differ?
                        if (i != a) return i;
            // Compare exponents.
            if (r = i < 0, u != l) return u > l ^ r ? 1 : -1;
            // Compare digit by digit.
            for (a = (u = n.length) < (l = o.length) ? u : l, i = -1; ++i < a; ) if (n[i] != o[i]) return n[i] > o[i] ^ r ? 1 : -1;
            // Compare lengths.
                        return u == l ? 0 : u > l ^ r ? 1 : -1;
        }, 
        /*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
        A.div = function(t) {
            var r = this, e = r.constructor, n = r.c, // dividend
            o = (t = new e(t)).c, // divisor
            i = r.s == t.s ? 1 : -1, a = e.DP;
            if (a !== ~~a || a < 0 || a > d) throw Error(w);
            // Divisor is zero?
                        if (!o[0]) throw Error(O);
            // Dividend is 0? Return +-0.
                        if (!n[0]) return t.s = i, t.c = [ t.e = 0 ], t;
            var u, l, c, s, f, y = o.slice(), p = u = o.length, h = n.length, v = n.slice(0, u), // remainder
            m = v.length, b = t, // quotient
            g = b.c = [], S = 0, A = a + (b.e = r.e - t.e) + 1;
 // precision of the result
                        // Add zeros to make remainder as long as divisor.
            for (b.s = i, i = A < 0 ? 0 : A, 
            // Create version of divisor with leading zero.
            y.unshift(0); m++ < u; ) v.push(0);
            do {
                // n is how many times the divisor goes into current remainder.
                for (c = 0; c < 10; c++) {
                    // Compare divisor and remainder.
                    if (u != (m = v.length)) s = u > m ? 1 : -1; else for (f = -1, s = 0; ++f < u; ) if (o[f] != v[f]) {
                        s = o[f] > v[f] ? 1 : -1;
                        break;
                    }
                    // If divisor < remainder, subtract divisor from remainder.
                                        if (!(s < 0)) break;
                    // Remainder can't be more than 1 digit longer than divisor.
                    // Equalise lengths using divisor with extra leading zero?
                    for (l = m == u ? o : y; m; ) {
                        if (v[--m] < l[m]) {
                            for (f = m; f && !v[--f]; ) v[f] = 9;
                            --v[f], v[m] += 10;
                        }
                        v[m] -= l[m];
                    }
                    for (;!v[0]; ) v.shift();
                }
                // Add the digit n to the result array.
                                g[S++] = s ? c : ++c, 
                // Update the remainder.
                v[0] && s ? v[m] = n[p] || 0 : v = [ n[p] ];
            } while ((p++ < h || v[0] !== j) && i--);
            // Leading zero? Do not remove if result is simply zero (qi == 1).
                        return g[0] || 1 == S || (
            // There can't be more than one zero.
            g.shift(), b.e--, A--), 
            // Round?
            S > A && P(b, A, e.RM, v[0] !== j), b;
        }, 
        /*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */
        A.eq = function(t) {
            return 0 === this.cmp(t);
        }, 
        /*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */
        A.gt = function(t) {
            return this.cmp(t) > 0;
        }, 
        /*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */
        A.gte = function(t) {
            return this.cmp(t) > -1;
        }, 
        /*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */
        A.lt = function(t) {
            return this.cmp(t) < 0;
        }, 
        /*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */
        A.lte = function(t) {
            return this.cmp(t) < 1;
        }, 
        /*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */
        A.minus = A.sub = function(t) {
            var r, e, n, o, i = this, a = i.constructor, u = i.s, l = (t = new a(t)).s;
            // Signs differ?
                        if (u != l) return t.s = -l, i.plus(t);
            var c = i.c.slice(), s = i.e, f = t.c, y = t.e;
            // Either zero?
                        if (!c[0] || !f[0]) return f[0] ? t.s = -l : c[0] ? t = new a(i) : t.s = 1, 
            t;
            // Determine which is the bigger number. Prepend zeros to equalise exponents.
                        if (u = s - y) {
                for ((o = u < 0) ? (u = -u, n = c) : (y = s, n = f), n.reverse(), l = u; l--; ) n.push(0);
                n.reverse();
            } else for (
            // Exponents equal. Check digit by digit.
            e = ((o = c.length < f.length) ? c : f).length, u = l = 0; l < e; l++) if (c[l] != f[l]) {
                o = c[l] < f[l];
                break;
            }
            // x < y? Point xc to the array of the bigger number.
                        /*
   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
   * needs to start at yc.length.
   */
            if (o && (n = c, c = f, f = n, t.s = -t.s), (l = (e = f.length) - (r = c.length)) > 0) for (;l--; ) c[r++] = 0;
            // Subtract yc from xc.
                        for (l = r; e > u; ) {
                if (c[--e] < f[e]) {
                    for (r = e; r && !c[--r]; ) c[r] = 9;
                    --c[r], c[e] += 10;
                }
                c[e] -= f[e];
            }
            // Remove trailing zeros.
                        for (;0 === c[--l]; ) c.pop();
            // Remove leading zeros and adjust exponent accordingly.
                        for (;0 === c[0]; ) c.shift(), --y;
            return c[0] || (
            // n - n = +0
            t.s = 1, 
            // Result must be zero.
            c = [ y = 0 ]), t.c = c, t.e = y, t;
        }, 
        /*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */
        A.mod = function(t) {
            var r, e = this, n = e.constructor, o = e.s, i = (t = new n(t)).s;
            if (!t.c[0]) throw Error(O);
            return e.s = t.s = 1, r = 1 == t.cmp(e), e.s = o, t.s = i, r ? new n(e) : (o = n.DP, 
            i = n.RM, n.DP = n.RM = 0, e = e.div(t), n.DP = o, n.RM = i, this.minus(e.times(t)));
        }, 
        /*
 * Return a new Big whose value is the value of this Big negated.
 */
        A.neg = function() {
            var t = new this.constructor(this);
            return t.s = -t.s, t;
        }, 
        /*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */
        A.plus = A.add = function(t) {
            var r, e, n, o = this, i = o.constructor;
            // Signs differ?
            if (t = new i(t), o.s != t.s) return t.s = -t.s, o.minus(t);
            var a = o.e, u = o.c, l = t.e, c = t.c;
            // Either zero?
                        if (!u[0] || !c[0]) return c[0] || (u[0] ? t = new i(o) : t.s = o.s), 
            t;
            // Prepend zeros to equalise exponents.
            // Note: reverse faster than unshifts.
            if (u = u.slice(), r = a - l) {
                for (r > 0 ? (l = a, n = c) : (r = -r, n = u), n.reverse(); r--; ) n.push(0);
                n.reverse();
            }
            // Point xc to the longer array.
                        // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
            for (u.length - c.length < 0 && (n = c, c = u, u = n), r = c.length, e = 0; r; u[r] %= 10) e = (u[--r] = u[r] + c[r] + e) / 10 | 0;
            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
                        // Remove trailing zeros.
            for (e && (u.unshift(e), ++l), r = u.length; 0 === u[--r]; ) u.pop();
            return t.c = u, t.e = l, t;
        }, 
        /*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */
        A.pow = function(t) {
            var r = this, e = new r.constructor("1"), n = e, o = t < 0;
            if (t !== ~~t || t < -1e6 || t > m) throw Error(g + "exponent");
            for (o && (t = -t); 1 & t && (n = n.times(r)), t >>= 1; ) r = r.times(r);
            return o ? e.div(n) : n;
        }, 
        /*
 * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
 * significant digits using rounding mode rm, or Big.RM if rm is not specified.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
        A.prec = function(t, r) {
            if (t !== ~~t || t < 1 || t > d) throw Error(g + "precision");
            return P(new this.constructor(this), t, r);
        }, 
        /*
 * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places
 * using rounding mode rm, or Big.RM if rm is not specified.
 * If dp is negative, round to an integer which is a multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
        A.round = function(t, r) {
            if (t === j) t = 0; else if (t !== ~~t || t < -d || t > d) throw Error(w);
            return P(new this.constructor(this), t + this.e + 1, r);
        }, 
        /*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
        A.sqrt = function() {
            var t, r, e, n = this, o = n.constructor, i = n.s, a = n.e, u = new o("0.5");
            // Zero?
                        if (!n.c[0]) return new o(n);
            // Negative?
                        if (i < 0) throw Error(b + "No square root");
            // Estimate.
                        // Math.sqrt underflow/overflow?
            // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
            0 === (i = Math.sqrt(n + "")) || i === 1 / 0 ? ((r = n.c.join("")).length + a & 1 || (r += "0"), 
            a = ((a + 1) / 2 | 0) - (a < 0 || 1 & a), t = new o(((i = Math.sqrt(r)) == 1 / 0 ? "5e" : (i = i.toExponential()).slice(0, i.indexOf("e") + 1)) + a)) : t = new o(i + ""), 
            a = t.e + (o.DP += 4);
            // Newton-Raphson iteration.
            do {
                e = t, t = u.times(e.plus(n.div(e)));
            } while (e.c.slice(0, a).join("") !== t.c.slice(0, a).join(""));
            return P(t, (o.DP -= 4) + t.e + 1, o.RM);
        }, 
        /*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */
        A.times = A.mul = function(t) {
            var r, e = this, n = e.constructor, o = e.c, i = (t = new n(t)).c, a = o.length, u = i.length, l = e.e, c = t.e;
            // Determine sign of result.
                        // Return signed 0 if either 0.
            if (t.s = e.s == t.s ? 1 : -1, !o[0] || !i[0]) return t.c = [ t.e = 0 ], t;
            // Initialise exponent of result as x.e + y.e.
                        // Initialise coefficient array of result with zeros.
            for (t.e = l + c, 
            // If array xc has fewer digits than yc, swap xc and yc, and lengths.
            a < u && (r = o, o = i, i = r, c = a, a = u, u = c), r = new Array(c = a + u); c--; ) r[c] = 0;
            // Multiply.
            // i is initially xc.length.
                        for (l = u; l--; ) {
                // a is yc.length.
                for (u = 0, c = a + l; c > l; ) 
                // Current sum of products at this digit position, plus carry.
                u = r[c] + i[l] * o[c - l - 1] + u, r[c--] = u % 10, 
                // carry
                u = u / 10 | 0;
                r[c] = u;
            }
            // Increment result exponent if there is a final carry, otherwise remove leading zero.
                        // Remove trailing zeros.
            for (u ? ++t.e : r.shift(), l = r.length; !r[--l]; ) r.pop();
            return t.c = r, t;
        }, 
        /*
 * Return a string representing the value of this Big in exponential notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
        A.toExponential = function(t, r) {
            var e = this, n = e.c[0];
            if (t !== j) {
                if (t !== ~~t || t < 0 || t > d) throw Error(w);
                for (e = P(new e.constructor(e), ++t, r); e.c.length < t; ) e.c.push(0);
            }
            return T(e, !0, !!n);
        }, 
        /*
 * Return a string representing the value of this Big in normal notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */
        A.toFixed = function(t, r) {
            var e = this, n = e.c[0];
            if (t !== j) {
                if (t !== ~~t || t < 0 || t > d) throw Error(w);
                // x.e may have changed if the value is rounded up.
                for (t = t + (e = P(new e.constructor(e), t + e.e + 1, r)).e + 1; e.c.length < t; ) e.c.push(0);
            }
            return T(e, !1, !!n);
        }, 
        /*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */
        A[Symbol.for("nodejs.util.inspect.custom")] = A.toJSON = A.toString = function() {
            var t = this, r = t.constructor;
            return T(t, t.e <= r.NE || t.e >= r.PE, !!t.c[0]);
        }, 
        /*
 * Return the value of this Big as a primitve number.
 */
        A.toNumber = function() {
            var t = Number(T(this, !0, !0));
            if (!0 === this.constructor.strict && !this.eq(t.toString())) throw Error(b + "Imprecise conversion");
            return t;
        }, 
        /*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * rounding mode rm, or Big.RM if rm is not specified.
 * Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
        A.toPrecision = function(t, r) {
            var e = this, n = e.constructor, o = e.c[0];
            if (t !== j) {
                if (t !== ~~t || t < 1 || t > d) throw Error(g + "precision");
                for (e = P(new n(e), t, r); e.c.length < t; ) e.c.push(0);
            }
            return T(e, t <= e.e || e.e <= n.NE || e.e >= n.PE, !!o);
        }, 
        /*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */
        A.valueOf = function() {
            var t = this, r = t.constructor;
            if (!0 === r.strict) throw Error(b + "valueOf disallowed");
            return T(t, t.e <= r.NE || t.e >= r.PE, !0);
        };
        // Export
        (
        /*
 * Create and return a Big constructor.
 */
        function t() {
            /*
   * The Big constructor and exported function.
   * Create and return a new instance of a Big number object.
   *
   * n {number|string|Big} A numeric value.
   */
            function r(e) {
                var n = this;
                // Enable constructor usage without new.
                                if (!(n instanceof r)) return e === j ? t() : new r(e);
                // Duplicate.
                                if (e instanceof r) n.s = e.s, n.e = e.e, n.c = e.c.slice(); else {
                    if ("string" != typeof e) {
                        if (!0 === r.strict && "bigint" != typeof e) throw TypeError(g + "value");
                        // Minus zero?
                                                e = 0 === e && 1 / e < 0 ? "-0" : String(e);
                    }
                    !
                    /*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */
                    function(t, r) {
                        var e, n, o;
                        if (!N.test(r)) throw Error(g + "number");
                        // Determine sign.
                                                // Decimal point?
                        t.s = "-" == r.charAt(0) ? (r = r.slice(1), -1) : 1, (e = r.indexOf(".")) > -1 && (r = r.replace(".", ""));
                        // Exponential form?
                                                (n = r.search(/e/i)) > 0 ? (
                        // Determine exponent.
                        e < 0 && (e = n), e += +r.slice(n + 1), r = r.substring(0, n)) : e < 0 && (
                        // Integer.
                        e = r.length);
                        // Determine leading zeros.
                        for (o = r.length, n = 0; n < o && "0" == r.charAt(n); ) ++n;
                        if (n == o) 
                        // Zero.
                        t.c = [ t.e = 0 ]; else {
                            // Determine trailing zeros.
                            for (;o > 0 && "0" == r.charAt(--o); ) ;
                            // Convert string to array of digits without leading/trailing zeros.
                            for (t.e = e - n - 1, t.c = [], e = 0; n <= o; ) t.c[e++] = +r.charAt(n++);
                        }
                    }(n, e);
                }
                // Retain a reference to this Big constructor.
                // Shadow Big.prototype.constructor which points to Object.
                                n.constructor = r;
            }
            return r.prototype = A, r.DP = 20, r.RM = 1, r.NE = -7, r.PE = 21, r.strict = false, 
            r.roundDown = 0, r.roundHalfUp = 1, r.roundHalfEven = 2, r.roundUp = 3, r;
        })();
        /// <reference types="https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts" />
        /* harmony default export */        // ./node_modules/trading-signals/dist/error/NotEnoughDataError.js
        function x(t) {
            return x = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, x(t);
        }
        function _(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, E(n.key), n);
            }
        }
        function E(t) {
            var r = function(t, r) {
                if ("object" != x(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != x(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }(t, "string");
            return "symbol" == x(r) ? r : r + "";
        }
        function k(t, r, e) {
            return r = D(r), function(t, r) {
                if (r && ("object" == x(r) || "function" == typeof r)) return r;
                if (void 0 !== r) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, M() ? Reflect.construct(r, e || [], D(t).constructor) : r.apply(t, e));
        }
        function C(t) {
            var r = "function" == typeof Map ? new Map : void 0;
            return C = function(t) {
                if (null === t || !function(t) {
                    try {
                        return -1 !== Function.toString.call(t).indexOf("[native code]");
                    } catch (r) {
                        return "function" == typeof t;
                    }
                }(t)) return t;
                if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== r) {
                    if (r.has(t)) return r.get(t);
                    r.set(t, e);
                }
                function e() {
                    return function(t, r, e) {
                        if (M()) return Reflect.construct.apply(null, arguments);
                        var n = [ null ];
                        n.push.apply(n, r);
                        var o = new (t.bind.apply(t, n));
                        return e && I(o, e.prototype), o;
                    }(t, arguments, D(this).constructor);
                }
                return e.prototype = Object.create(t.prototype, {
                    constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), I(e, t);
            }, C(t);
        }
        function M() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (M = function() {
                return !!t;
            })();
        }
        function I(t, r) {
            return I = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, r) {
                return t.__proto__ = r, t;
            }, I(t, r);
        }
        function D(t) {
            return D = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, D(t);
        }
        var R =  function(t) {
            function r() {
                var t, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Not enough data";
                return function(t, r) {
                    if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
                }(this, r), t = k(this, r, [ e ]), Object.setPrototypeOf(t, (this instanceof r ? this.constructor : void 0).prototype), 
                t.name = "NotEnoughDataError", t;
            }
            return function(t, r) {
                if ("function" != typeof r && null !== r) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(r && r.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), r && I(t, r);
            }(r, t), e = r, n && _(e.prototype, n), o && _(e, o), Object.defineProperty(e, "prototype", {
                writable: !1
            }), e;
            var e, n, o;
        }( C(Error));
        // ./node_modules/trading-signals/dist/Indicator.js
        function F(t) {
            return F = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, F(t);
        }
        function L(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
        }
        function z(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, G(n.key), n);
            }
        }
        function Y(t, r, e) {
            return r && z(t.prototype, r), e && z(t, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function U(t, r, e) {
            return (r = G(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function G(t) {
            var r = function(t, r) {
                if ("object" != F(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != F(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }(t, "string");
            return "symbol" == F(r) ? r : r + "";
        }
        var K =  function() {
            return Y((function t() {
                L(this, t), U(this, "previousHighest", void 0), U(this, "highest", void 0), U(this, "previousLowest", void 0), 
                U(this, "lowest", void 0), U(this, "previousResult", void 0), U(this, "result", void 0);
            }), [ {
                key: "isStable",
                get: function() {
                    return void 0 !== this.result;
                }
            }, {
                key: "getResult",
                value: function() {
                    if (void 0 === this.result) throw new R;
                    return this.result;
                }
            }, {
                key: "setResult",
                value: function(t, r) {
                    return r && (this.highest = this.previousHighest, this.lowest = this.previousLowest, 
                    this.result = this.previousResult), void 0 === this.highest ? this.highest = t : t > this.highest ? (this.previousHighest = this.highest, 
                    this.highest = t) : this.previousHighest = this.highest, void 0 === this.lowest ? this.lowest = t : t < this.lowest ? (this.previousLowest = this.lowest, 
                    this.lowest = t) : this.previousLowest = this.lowest, this.previousResult = this.result, 
                    this.result = t;
                }
            }, {
                key: "replace",
                value: function(t) {
                    return this.update(t, !0);
                }
            } ]);
        }();
        // ./node_modules/trading-signals/dist/MA/MovingAverage.js
        function V(t) {
            return V = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, V(t);
        }
        function $(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
        }
        function q(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, tt(n.key), n);
            }
        }
        function H(t, r, e) {
            return r && q(t.prototype, r), e && q(t, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function B(t, r, e) {
            return r = X(r), function(t, r) {
                if (r && ("object" == V(r) || "function" == typeof r)) return r;
                if (void 0 !== r) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, J() ? Reflect.construct(r, e || [], X(t).constructor) : r.apply(t, e));
        }
        function J() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (J = function() {
                return !!t;
            })();
        }
        function X(t) {
            return X = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, X(t);
        }
        function W(t, r) {
            if ("function" != typeof r && null !== r) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(r && r.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), r && Z(t, r);
        }
        function Z(t, r) {
            return Z = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, r) {
                return t.__proto__ = r, t;
            }, Z(t, r);
        }
        function Q(t, r, e) {
            return (r = tt(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function tt(t) {
            var r = function(t, r) {
                if ("object" != V(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != V(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }(t, "string");
            return "symbol" == V(r) ? r : r + "";
        }
        var rt =  function(t) {
            function r(t) {
                var e;
                return $(this, r), Q(e = B(this, r), "interval", void 0), e.interval = t, e;
            }
            return W(r, t), H(r, [ {
                key: "updates",
                value: function(t) {
                    var r = this;
                    return t.forEach((function(t) {
                        return r.update(t);
                    })), this.result;
                }
            }, {
                key: "replace",
                value: function(t) {
                    return this.update(t, !0);
                }
            } ]);
        }(K);
        // ./node_modules/trading-signals/dist/SMA/SMA.js
        function et(t) {
            return et = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, et(t);
        }
        function nt(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
        }
        function ot(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, yt(n.key), n);
            }
        }
        function it(t, r, e) {
            return r && ot(t.prototype, r), e && ot(t, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function at(t, r, e) {
            return r = lt(r), function(t, r) {
                if (r && ("object" == et(r) || "function" == typeof r)) return r;
                if (void 0 !== r) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, ut() ? Reflect.construct(r, e || [], lt(t).constructor) : r.apply(t, e));
        }
        function ut() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (ut = function() {
                return !!t;
            })();
        }
        function lt(t) {
            return lt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, lt(t);
        }
        function ct(t, r) {
            if ("function" != typeof r && null !== r) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(r && r.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), r && st(t, r);
        }
        function st(t, r) {
            return st = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, r) {
                return t.__proto__ = r, t;
            }, st(t, r);
        }
        function ft(t, r, e) {
            return (r = yt(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function yt(t) {
            var r = function(t, r) {
                if ("object" != et(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != et(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }(t, "string");
            return "symbol" == et(r) ? r : r + "";
        }
        var pt =  function(t) {
            function r() {
                var t;
                nt(this, r);
                for (var e = arguments.length, n = new Array(e), o = 0; o < e; o++) n[o] = arguments[o];
                return ft(t = at(this, r, [].concat(n)), "prices", []), t;
            }
            return ct(r, t), it(r, [ {
                key: "update",
                value: function(t) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if (this.prices.length && r ? this.prices[this.prices.length - 1] = t : this.prices.push(t), 
                    this.prices.length > this.interval && this.prices.shift(), this.prices.length === this.interval) {
                        var e = this.prices.reduce((function(t, r) {
                            return t + r;
                        }), 0);
                        return this.setResult(e / this.prices.length, r);
                    }
                }
            } ]);
        }(rt);
        // ./node_modules/trading-signals/dist/WSMA/WSMA.js
        function ht(t) {
            return ht = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, ht(t);
        }
        function vt(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
        }
        function dt(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, jt(n.key), n);
            }
        }
        function mt(t, r, e) {
            return r && dt(t.prototype, r), e && dt(t, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function bt(t, r, e) {
            return r = wt(r), function(t, r) {
                if (r && ("object" == ht(r) || "function" == typeof r)) return r;
                if (void 0 !== r) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, gt() ? Reflect.construct(r, e || [], wt(t).constructor) : r.apply(t, e));
        }
        function gt() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (gt = function() {
                return !!t;
            })();
        }
        function wt(t) {
            return wt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, wt(t);
        }
        function St(t, r) {
            if ("function" != typeof r && null !== r) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(r && r.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), r && Ot(t, r);
        }
        function Ot(t, r) {
            return Ot = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, r) {
                return t.__proto__ = r, t;
            }, Ot(t, r);
        }
        function At(t, r, e) {
            return (r = jt(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function jt(t) {
            var r = function(t, r) {
                if ("object" != ht(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != ht(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }(t, "string");
            return "symbol" == ht(r) ? r : r + "";
        }
        var Nt =  function(t) {
            function r(t) {
                var e;
                return vt(this, r), At(e = bt(this, r), "interval", void 0), At(e, "indicator", void 0), 
                At(e, "smoothingFactor", void 0), e.interval = t, e.indicator = new pt(t), e.smoothingFactor = 1 / e.interval, 
                e;
            }
            return St(r, t), mt(r, [ {
                key: "updates",
                value: function(t) {
                    var r = this;
                    return t.forEach((function(t) {
                        return r.update(t);
                    })), this.result;
                }
            }, {
                key: "update",
                value: function(t) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], e = this.indicator.update(t);
                    if (r && void 0 !== this.previousResult) {
                        var n = (t - this.previousResult) * this.smoothingFactor;
                        return this.setResult(n + this.previousResult, r);
                    }
                    if (!r && void 0 !== this.result) {
                        var o = (t - this.result) * this.smoothingFactor;
                        return this.setResult(o + this.result, r);
                    }
                    if (void 0 === this.result && void 0 !== e) return this.setResult(e, r);
                }
            } ]);
        }(K);
        function Pt(t) {
            return t.length ? t.reduce((function(t, r) {
                return t + r;
            }), 0) / t.length : 0;
        }
        // ./node_modules/trading-signals/dist/TR/TR.js
        function Tt(t) {
            return Tt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Tt(t);
        }
        function xt(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
        }
        function _t(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, Ft(n.key), n);
            }
        }
        function Et(t, r, e) {
            return r && _t(t.prototype, r), e && _t(t, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function kt(t, r, e) {
            return r = Mt(r), function(t, r) {
                if (r && ("object" == Tt(r) || "function" == typeof r)) return r;
                if (void 0 !== r) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, Ct() ? Reflect.construct(r, e || [], Mt(t).constructor) : r.apply(t, e));
        }
        function Ct() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (Ct = function() {
                return !!t;
            })();
        }
        function Mt(t) {
            return Mt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, Mt(t);
        }
        function It(t, r) {
            if ("function" != typeof r && null !== r) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(r && r.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), r && Dt(t, r);
        }
        function Dt(t, r) {
            return Dt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, r) {
                return t.__proto__ = r, t;
            }, Dt(t, r);
        }
        function Rt(t, r, e) {
            return (r = Ft(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function Ft(t) {
            var r = function(t, r) {
                if ("object" != Tt(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != Tt(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }(t, "string");
            return "symbol" == Tt(r) ? r : r + "";
        }
        var Lt =  function(t) {
            function r() {
                var t;
                xt(this, r);
                for (var e = arguments.length, n = new Array(e), o = 0; o < e; o++) n[o] = arguments[o];
                return Rt(t = kt(this, r, [].concat(n)), "previousCandle", void 0), Rt(t, "twoPreviousCandle", void 0), 
                t;
            }
            return It(r, t), Et(r, [ {
                key: "update",
                value: function(t) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], e = t.high, n = t.low, o = e - n;
                    if (this.previousCandle && r && (this.previousCandle = this.twoPreviousCandle), 
                    this.previousCandle) {
                        var i = Math.abs(e - this.previousCandle.close), a = Math.abs(n - this.previousCandle.close);
                        return this.twoPreviousCandle = this.previousCandle, this.previousCandle = t, this.setResult(Math.max(o, i, a), r);
                    }
                    return this.twoPreviousCandle = this.previousCandle, this.previousCandle = t, this.setResult(o, r);
                }
            } ]);
        }(K);
        // ./node_modules/trading-signals/dist/ATR/ATR.js
        function zt(t) {
            return zt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, zt(t);
        }
        function Yt(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
        }
        function Ut(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, Jt(n.key), n);
            }
        }
        function Gt(t, r, e) {
            return r && Ut(t.prototype, r), e && Ut(t, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function Kt(t, r, e) {
            return r = $t(r), function(t, r) {
                if (r && ("object" == zt(r) || "function" == typeof r)) return r;
                if (void 0 !== r) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, Vt() ? Reflect.construct(r, e || [], $t(t).constructor) : r.apply(t, e));
        }
        function Vt() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (Vt = function() {
                return !!t;
            })();
        }
        function $t(t) {
            return $t = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, $t(t);
        }
        function qt(t, r) {
            if ("function" != typeof r && null !== r) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(r && r.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), r && Ht(t, r);
        }
        function Ht(t, r) {
            return Ht = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, r) {
                return t.__proto__ = r, t;
            }, Ht(t, r);
        }
        function Bt(t, r, e) {
            return (r = Jt(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function Jt(t) {
            var r = function(t, r) {
                if ("object" != zt(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != zt(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }(t, "string");
            return "symbol" == zt(r) ? r : r + "";
        }
        var Xt =  function(t) {
            function r(t) {
                var e, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Nt;
                return Yt(this, r), Bt(e = Kt(this, r), "interval", void 0), Bt(e, "tr", void 0), 
                Bt(e, "smoothing", void 0), e.interval = t, e.tr = new Lt, e.smoothing = new n(t), 
                e;
            }
            return qt(r, t), Gt(r, [ {
                key: "update",
                value: function(t) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], e = this.tr.update(t, r);
                    if (this.smoothing.update(e, r), this.smoothing.isStable) return this.setResult(this.smoothing.getResult(), r);
                }
            } ]);
        }(K);
        // ./node_modules/trading-signals/dist/BBANDS/BollingerBands.js
        function Wt(t) {
            return Wt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Wt(t);
        }
        function Zt(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
        }
        function Qt(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, er(n.key), n);
            }
        }
        function tr(t, r, e) {
            return r && Qt(t.prototype, r), e && Qt(t, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function rr(t, r, e) {
            return (r = er(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function er(t) {
            var r = function(t, r) {
                if ("object" != Wt(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != Wt(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }(t, "string");
            return "symbol" == Wt(r) ? r : r + "";
        }
        var nr =  function() {
            return tr((function t(r) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
                Zt(this, t), rr(this, "interval", void 0), rr(this, "deviationMultiplier", void 0), 
                rr(this, "prices", []), rr(this, "result", void 0), this.interval = r, this.deviationMultiplier = e;
            }), [ {
                key: "update",
                value: function(t) {
                    if (this.prices.push(t), this.prices.length > this.interval) {
                        this.prices.shift();
                        var r = Pt(this.prices), e = function(t, r) {
                            var e = r || Pt(t), n = Pt(t.map((function(t) {
                                return t - e;
                            })).map((function(t) {
                                return t * t;
                            })));
                            return Math.sqrt(n);
                        }(this.prices, r);
                        return this.result = {
                            lower: r - e * this.deviationMultiplier,
                            middle: r,
                            upper: r + e * this.deviationMultiplier
                        };
                    }
                }
            }, {
                key: "getResult",
                value: function() {
                    if (void 0 === this.result) throw new R;
                    return this.result;
                }
            }, {
                key: "isStable",
                get: function() {
                    return void 0 !== this.result;
                }
            } ]);
        }();
        // ./node_modules/trading-signals/dist/EMA/EMA.js
        function or(t) {
            return or = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, or(t);
        }
        function ir(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
        }
        function ar(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, hr(n.key), n);
            }
        }
        function ur(t, r, e) {
            return r && ar(t.prototype, r), e && ar(t, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function lr(t, r, e) {
            return r = sr(r), function(t, r) {
                if (r && ("object" == or(r) || "function" == typeof r)) return r;
                if (void 0 !== r) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, cr() ? Reflect.construct(r, e || [], sr(t).constructor) : r.apply(t, e));
        }
        function cr() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (cr = function() {
                return !!t;
            })();
        }
        function sr(t) {
            return sr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, sr(t);
        }
        function fr(t, r) {
            if ("function" != typeof r && null !== r) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(r && r.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), r && yr(t, r);
        }
        function yr(t, r) {
            return yr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, r) {
                return t.__proto__ = r, t;
            }, yr(t, r);
        }
        function pr(t, r, e) {
            return (r = hr(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function hr(t) {
            var r = function(t, r) {
                if ("object" != or(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != or(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }(t, "string");
            return "symbol" == or(r) ? r : r + "";
        }
        var vr =  function(t) {
            function r(t) {
                var e;
                return ir(this, r), pr(e = lr(this, r, [ t ]), "interval", void 0), pr(e, "pricesCounter", 0), 
                pr(e, "weightFactor", void 0), e.interval = t, e.weightFactor = 2 / (e.interval + 1), 
                e;
            }
            return fr(r, t), ur(r, [ {
                key: "update",
                value: function(t) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    return r ? r && 0 === this.pricesCounter && this.pricesCounter++ : this.pricesCounter++, 
                    r && void 0 !== this.previousResult ? this.setResult(t * this.weightFactor + this.previousResult * (1 - this.weightFactor), r) : this.setResult(t * this.weightFactor + (void 0 !== this.result ? this.result : t) * (1 - this.weightFactor), r);
                }
            }, {
                key: "getResult",
                value: function() {
                    if (this.pricesCounter < this.interval) throw new R;
                    return this.result;
                }
            }, {
                key: "isStable",
                get: function() {
                    try {
                        return this.getResult(), !0;
                    } catch (t) {
                        return !1;
                    }
                }
            } ]);
        }(rt);
        // ./node_modules/trading-signals/dist/MACD/MACD.js
        function dr(t) {
            return dr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, dr(t);
        }
        function mr(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
        }
        function br(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, Sr(n.key), n);
            }
        }
        function gr(t, r, e) {
            return r && br(t.prototype, r), e && br(t, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function wr(t, r, e) {
            return (r = Sr(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function Sr(t) {
            var r = function(t, r) {
                if ("object" != dr(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != dr(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }(t, "string");
            return "symbol" == dr(r) ? r : r + "";
        }
        var Or =  function() {
            return gr((function t(r, e, n) {
                mr(this, t), wr(this, "short", void 0), wr(this, "long", void 0), wr(this, "signal", void 0), 
                wr(this, "prices", []), wr(this, "result", void 0), this.short = r, this.long = e, 
                this.signal = n;
            }), [ {
                key: "getResult",
                value: function() {
                    if (void 0 === this.result) throw new R;
                    return this.result;
                }
            }, {
                key: "isStable",
                get: function() {
                    return void 0 !== this.result;
                }
            }, {
                key: "update",
                value: function(t) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    this.prices.length && r ? this.prices[this.prices.length - 1] = t : this.prices.push(t);
                    var e = this.short.update(t, r), n = this.long.update(t, r);
                    if (this.prices.length > this.long.interval && this.prices.shift(), this.prices.length === this.long.interval) {
                        var o = e - n, i = this.signal.update(o, r);
                        return this.result = {
                            histogram: o - i,
                            macd: o,
                            signal: i
                        };
                    }
                }
            } ]);
        }();
        // ./node_modules/trading-signals/dist/RSI/RSI.js
        function Ar(t) {
            return Ar = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Ar(t);
        }
        function jr(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
        }
        function Nr(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, Mr(n.key), n);
            }
        }
        function Pr(t, r, e) {
            return r && Nr(t.prototype, r), e && Nr(t, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function Tr(t, r, e) {
            return r = _r(r), function(t, r) {
                if (r && ("object" == Ar(r) || "function" == typeof r)) return r;
                if (void 0 !== r) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, xr() ? Reflect.construct(r, e || [], _r(t).constructor) : r.apply(t, e));
        }
        function xr() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (xr = function() {
                return !!t;
            })();
        }
        function _r(t) {
            return _r = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, _r(t);
        }
        function Er(t, r) {
            if ("function" != typeof r && null !== r) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(r && r.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), r && kr(t, r);
        }
        function kr(t, r) {
            return kr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, r) {
                return t.__proto__ = r, t;
            }, kr(t, r);
        }
        function Cr(t, r, e) {
            return (r = Mr(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function Mr(t) {
            var r = function(t, r) {
                if ("object" != Ar(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != Ar(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }(t, "string");
            return "symbol" == Ar(r) ? r : r + "";
        }
        var Ir =  function(t) {
            function r(t) {
                var e, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Nt;
                return jr(this, r), Cr(e = Tr(this, r), "interval", void 0), Cr(e, "previousPrices", []), 
                Cr(e, "avgGain", void 0), Cr(e, "avgLoss", void 0), Cr(e, "maxValue", 100), e.interval = t, 
                e.avgGain = new n(e.interval), e.avgLoss = new n(e.interval), e;
            }
            return Er(r, t), Pr(r, [ {
                key: "update",
                value: function(t) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if (this.previousPrices.length && r ? this.previousPrices[this.previousPrices.length - 1] = t : this.previousPrices.push(t), 
                    !(this.previousPrices.length < 2)) {
                        var e = t, n = this.previousPrices[this.previousPrices.length - 2];
                        if (e > n ? (this.avgLoss.update(0, r), this.avgGain.update(t - n, r)) : (this.avgLoss.update(n - e, r), 
                        this.avgGain.update(0, r)), this.avgGain.isStable) {
                            var o = this.avgLoss.getResult();
                            if (0 === o) return this.setResult(100, r);
                            var i = this.avgGain.getResult() / o;
                            return this.setResult(this.maxValue - this.maxValue / (i + 1), r);
                        }
                    }
                }
            } ]);
        }(K);
        // ./node_modules/trading-signals/dist/STOCH/StochasticOscillator.js
        function Dr(t) {
            return Dr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Dr(t);
        }
        function Rr(t) {
            return function(t) {
                if (Array.isArray(t)) return Fr(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || function(t, r) {
                if (t) {
                    if ("string" == typeof t) return Fr(t, r);
                    var e = {}.toString.call(t).slice(8, -1);
                    return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? Fr(t, r) : void 0;
                }
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Fr(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        function Lr(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
        }
        function zr(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, Gr(n.key), n);
            }
        }
        function Yr(t, r, e) {
            return r && zr(t.prototype, r), e && zr(t, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function Ur(t, r, e) {
            return (r = Gr(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function Gr(t) {
            var r = function(t, r) {
                if ("object" != Dr(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != Dr(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }(t, "string");
            return "symbol" == Dr(r) ? r : r + "";
        }
        var Kr =  function() {
            return Yr((function t(r, e, n) {
                Lr(this, t), Ur(this, "n", void 0), Ur(this, "m", void 0), Ur(this, "p", void 0), 
                Ur(this, "candles", []), Ur(this, "result", void 0), Ur(this, "periodM", void 0), 
                Ur(this, "periodP", void 0), this.n = r, this.m = e, this.p = n, this.periodM = new pt(e), 
                this.periodP = new pt(n);
            }), [ {
                key: "getResult",
                value: function() {
                    if (void 0 === this.result) throw new R;
                    return this.result;
                }
            }, {
                key: "isStable",
                get: function() {
                    return void 0 !== this.result;
                }
            }, {
                key: "update",
                value: function(t) {
                    if (this.candles.push(t), this.candles.length > this.n && this.candles.shift(), 
                    this.candles.length === this.n) {
                        var r = Math.max.apply(Math, Rr(this.candles.map((function(t) {
                            return t.high;
                        })))), e = Math.min.apply(Math, Rr(this.candles.map((function(t) {
                            return t.low;
                        })))), n = r - e, o = 100 * (t.close - e);
                        o /= 0 === n ? 1 : n;
                        var i = this.periodM.update(o), a = i && this.periodP.update(i);
                        if (void 0 !== i && void 0 !== a) return this.result = {
                            stochD: a,
                            stochK: i
                        };
                    }
                }
            } ]);
        }();
        // ./src/oscillators/rsi.js
        function Vr(t) {
            return Vr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Vr(t);
        }
        function $r(t) {
            return function(t) {
                if (Array.isArray(t)) return Hr(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || qr(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function qr(t, r) {
            if (t) {
                if ("string" == typeof t) return Hr(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? Hr(t, r) : void 0;
            }
        }
        function Hr(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        function Br(t, r, e) {
            return (r = function(t) {
                var r = function(t, r) {
                    if ("object" != Vr(t) || !t) return t;
                    var e = t[Symbol.toPrimitive];
                    if (void 0 !== e) {
                        var n = e.call(t, r || "default");
                        if ("object" != Vr(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === r ? String : Number)(t);
                }(t, "string");
                return "symbol" == Vr(r) ? r : r + "";
            }(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        // ./src/oscillators/stochastic.js
        function Jr(t) {
            return Jr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Jr(t);
        }
        function Xr(t) {
            return function(t) {
                if (Array.isArray(t)) return Zr(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || Wr(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Wr(t, r) {
            if (t) {
                if ("string" == typeof t) return Zr(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? Zr(t, r) : void 0;
            }
        }
        function Zr(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        function Qr(t, r, e) {
            return (r = function(t) {
                var r = function(t, r) {
                    if ("object" != Jr(t) || !t) return t;
                    var e = t[Symbol.toPrimitive];
                    if (void 0 !== e) {
                        var n = e.call(t, r || "default");
                        if ("object" != Jr(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === r ? String : Number)(t);
                }(t, "string");
                return "symbol" == Jr(r) ? r : r + "";
            }(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        var te = {
            ema: vr,
            sma: pt
        }, re = function(t, r, e, n, o) {
            var i = o.target, a = o.lag, u = t.verticalOhlcv, l = t.instances, c = "close" !== i ? "_".concat(i) : "", s = "".concat(e, "_").concat(n).concat(c);
            if (0 === r) {
                var f = t.arrayTypes, y = t.len;
                if (!u.hasOwnProperty(i)) throw new Error("Target property ".concat(i, " not found in verticalOhlcv for ").concat(e, "."));
                // Create the main moving average instance.
                                l[s] = new te[e](n), u[s] = new Float64Array(y).fill(NaN), a > 0 && t.lag([ s ], a), 
                f[s] = "Float64Array";
            }
            // Retrieve the current price value
                        var p = u[i][r], h = l[s];
            // Update the moving average instance.
            h.update(p);
            var v = NaN;
            try {
                v = h.getResult();
            } catch (t) {}
            // Always push the MA value (even if NaN).
                        return t.pushToMain({
                index: r,
                key: s,
                value: v
            }), !0;
        };
        // ./src/moving-averages/macd.js
        function ee(t) {
            return ee = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, ee(t);
        }
        function ne(t, r, e) {
            return (r = function(t) {
                var r = function(t, r) {
                    if ("object" != ee(t) || !t) return t;
                    var e = t[Symbol.toPrimitive];
                    if (void 0 !== e) {
                        var n = e.call(t, r || "default");
                        if ("object" != ee(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === r ? String : Number)(t);
                }(t, "string");
                return "symbol" == ee(r) ? r : r + "";
            }(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function oe(t, r) {
            var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!e) {
                if (Array.isArray(t) || (e = function(t, r) {
                    if (t) {
                        if ("string" == typeof t) return ie(t, r);
                        var e = {}.toString.call(t).slice(8, -1);
                        return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? ie(t, r) : void 0;
                    }
                }(t)) || r && t && "number" == typeof t.length) {
                    e && (t = e);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    e = e.call(t);
                },
                n: function() {
                    var t = e.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == e.return || e.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function ie(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var ae = "close";
        // ./src/utilities/numberUtilities.js
        function ue(t) {
            return ue = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, ue(t);
        }
        // Helper to clean non-numeric characters (except "-" at the start and decimal point)
                var le = {
            number: function(t) {
                return t;
            },
            numberCleanString: function(t) {
                return Number(t);
            },
            numberDirtyString: function(t) {
                return Number(t.replace(/(?!^-)[^0-9.]/g, ""));
            }
        }, ce = function(t) {
            var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            // 1) true numbers
                        if ("number" == typeof t && !Number.isNaN(t)) return "number";
            // 2) strings
                        if ("string" == typeof t) {
                var e = t.trim(), n = /^-?\d+(\.\d+)?$/;
                // a) clean numeric string: only digits and an optional single period
                if (n.test(e)) return "numberCleanString";
                // b) dirty numeric string: contains non-digits (dollar, commas, letters, etc.)
                //    but once you strip those out, you're left with a valid number
                                var o = e.replace(/[^0-9.]/g, "");
                if (o && n.test(o)) return "numberDirtyString";
            }
            if (r) throw new TypeError("Invalid input: expected a number or numeric string");
            return ue(t);
        }, se = function(t, r) {
            var e = Math.pow(10, r);
            // add a tiny epsilon to mitigate floating-point quirks around .5
                        return Math.round((t + Number.EPSILON) * e) / e;
        };
        // ./src/moving-averages/donchianChannel.js
        function fe(t) {
            return function(t) {
                if (Array.isArray(t)) return pe(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || ye(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function ye(t, r) {
            if (t) {
                if ("string" == typeof t) return pe(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? pe(t, r) : void 0;
            }
        }
        function pe(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        // ./src/moving-averages/bollingerBands.js
        function he(t) {
            return he = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, he(t);
        }
        function ve(t, r) {
            var e = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                r && (n = n.filter((function(r) {
                    return Object.getOwnPropertyDescriptor(t, r).enumerable;
                }))), e.push.apply(e, n);
            }
            return e;
        }
        function de(t, r, e) {
            return (r = function(t) {
                var r = function(t, r) {
                    if ("object" != he(t) || !t) return t;
                    var e = t[Symbol.toPrimitive];
                    if (void 0 !== e) {
                        var n = e.call(t, r || "default");
                        if ("object" != he(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === r ? String : Number)(t);
                }(t, "string");
                return "symbol" == he(r) ? r : r + "";
            }(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function me(t, r) {
            var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!e) {
                if (Array.isArray(t) || (e = function(t, r) {
                    if (t) {
                        if ("string" == typeof t) return be(t, r);
                        var e = {}.toString.call(t).slice(8, -1);
                        return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? be(t, r) : void 0;
                    }
                }(t)) || r && t && "number" == typeof t.length) {
                    e && (t = e);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    e = e.call(t);
                },
                n: function() {
                    var t = e.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == e.return || e.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function be(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var ge = "close";
        // ./src/oscillators/volumeOscillator.js
        function we(t) {
            return we = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, we(t);
        }
        function Se(t, r, e) {
            return (r = function(t) {
                var r = function(t, r) {
                    if ("object" != we(t) || !t) return t;
                    var e = t[Symbol.toPrimitive];
                    if (void 0 !== e) {
                        var n = e.call(t, r || "default");
                        if ("object" != we(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === r ? String : Number)(t);
                }(t, "string");
                return "symbol" == we(r) ? r : r + "";
            }(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        // ./src/utilities/dateUtilities.js
        function Oe(t) {
            return Oe = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Oe(t);
        }
        var Ae = {
            string: function(t) {
                return t.toISOString();
            },
            milliseconds: function(t) {
                return t.getTime();
            },
            seconds: function(t) {
                return t.getTime() / 1e3;
            },
            object: function(t) {
                return t;
            }
        }, je = {
            dateObject: function(t) {
                return t;
            },
            dateMilliseconds: function(t) {
                return new Date(t);
            },
            dateSeconds: function(t) {
                return new Date(1e3 * t);
            },
            dateIncompleteDayString: function(t) {
                return new Date("".concat(t, "  00:00:00"));
            },
            dateCompleteDateString: function(t) {
                return new Date(t);
            }
        }, Ne = function(t) {
            // Regex for a UTC Time Format where the string ends with "Z".
            var r = [ "Date -> object", "Milliseconds Timestamp -> integer", "Seconds Timestamp -> integer", "UTC Time Format (ISO 8601) -> string", "Including a Timezone Offset (ISO 8601) -> string", "Local Time Format (ISO 8601) -> string", "YYYY/MM/DD or YYYY-MM-DD -> string" ], e = function() {
                throw new Error('Invalid "'.concat(Oe(t), '" date value passed in selectDateFormatter. Supported formats: \n-').concat(r.join("\n- ")));
            };
            // Regex for a Timezone Offset Format,
            // which includes a plus or minus sign followed by HH:MM at the end.
                        if ("object" === Oe(t)) {
                if (t instanceof Date && !isNaN(t.valueOf())) return "dateObject";
                e();
            } else {
                if ("number" == typeof t) 
                // Use a numeric threshold based on the absolute value: typically,
                // if the absolute value is below 1e11, then it's a seconds timestamp.
                // Otherwise, it's a milliseconds timestamp.
                return Math.abs(t) < 1e11 ? "dateSeconds" : "dateMillseconds";
                if ("string" == typeof t) {
                    if (/^\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(?:\.\d+)?Z$/i.test(t) || /^\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(?:\.\d+)?([+-]\d{2}:\d{2})$/.test(t) || /^\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(?:\.\d+)?$/.test(t) && t.length > 10 || /^\d{4}\/\d{2}\/\d{2}$/.test(t)) return "dateCompleteDateString";
                    if (/^\d{4}-\d{2}-\d{2}$/.test(t)) return "dateIncompleteDayString";
                    e();
                } else e();
            }
        };
        // ./src/utilities/assignTypes.js
        function Pe(t, r) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, r) {
                var e = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != e) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (e = e.call(t)).next, 0 === r) {
                            if (Object(e) !== e) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(e)).done) && (u.push(n.value), u.length !== r); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != e.return && (a = e.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, r) || function(t, r) {
                if (t) {
                    if ("string" == typeof t) return Te(t, r);
                    var e = {}.toString.call(t).slice(8, -1);
                    return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? Te(t, r) : void 0;
                }
            }(t, r) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Te(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var xe = new Set([ "open", "high", "low", "close" ]), _e = function(t, r) {
            var e = {
                Array,
                Float64Array,
                Int32Array,
                Uint8Array,
                Int16Array
            }[t];
            if (!e || "function" != typeof e.from) throw new Error("Unsupported array type: ".concat(t));
            // Arrays get nulls, typed-arrays get NaNs
                        var n = "Array" === t ? null : NaN;
            // Ctor.from({ length }, mapFn) works for Array *and* all TypedArrays
                        return e.from({
                length: r
            }, (function() {
                return n;
            }));
        };
        // ./src/studies/lag.js
        function Ee(t, r) {
            var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!e) {
                if (Array.isArray(t) || (e = function(t, r) {
                    if (t) {
                        if ("string" == typeof t) return ke(t, r);
                        var e = {}.toString.call(t).slice(8, -1);
                        return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? ke(t, r) : void 0;
                    }
                }(t)) || r && t && "number" == typeof t.length) {
                    e && (t = e);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    e = e.call(t);
                },
                n: function() {
                    var t = e.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == e.return || e.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function ke(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        // ./src/studies/findCrosses.js
        function Ce(t, r) {
            var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!e) {
                if (Array.isArray(t) || (e = function(t, r) {
                    if (t) {
                        if ("string" == typeof t) return Me(t, r);
                        var e = {}.toString.call(t).slice(8, -1);
                        return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? Me(t, r) : void 0;
                    }
                }(t)) || r && t && "number" == typeof t.length) {
                    e && (t = e);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    e = e.call(t);
                },
                n: function() {
                    var t = e.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == e.return || e.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function Me(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        function Ie(t) {
            return Ie = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Ie(t);
        }
        function De(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, Re(n.key), n);
            }
        }
        function Re(t) {
            var r = function(t, r) {
                if ("object" != Ie(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != Ie(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }(t, "string");
            return "symbol" == Ie(r) ? r : r + "";
        }
        var Fe = function(t, r) {
            return t > r;
        }, Le = function(t, r) {
            return t < r;
        }, ze =  function() {
            return t = function t() {
                !function(t, r) {
                    if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
                }(this, t), Object.assign(this, {
                    interval: 0,
                    prevState: .5,
                    prevFast: NaN,
                    prevSlow: NaN,
                    prevHigh: NaN,
                    prevLow: NaN,
                    areHighAndLowUndefined: !1,
                    crossIndexes: {
                        up: [],
                        down: []
                    }
                });
            }, (r = [ {
                key: "update",
                value: function(t, r) {
                    var e = r.fast, n = r.high, o = r.slow, i = r.low, a = this.prevState;
                    this.areHighAndLowUndefined || void 0 !== n && void 0 !== i || (this.areHighAndLowUndefined = !0), 
                    Number.isNaN(e) || Number.isNaN(o) || function(t, r) {
                        return t === r;
                    }(e, o) ? a = .5 : Fe(e, o) ? a = this.areHighAndLowUndefined ? 1 : [ i, o, this.prevLow, this.prevSlow ].every((function(t) {
                        return !Number.isNaN(t);
                    })) && Le(i, o) && Fe(this.prevLow, this.prevSlow) ? 0 : 1 : Le(e, o) && (a = this.areHighAndLowUndefined ? 0 : [ n, o, this.prevHigh, this.prevSlow ].every((function(t) {
                        return !Number.isNaN(t);
                    })) && Fe(n, o) && Le(this.prevHigh, this.prevSlow) ? 1 : 0), .5 === a ? this.interval = 0 : 1 === a ? this.prevState <= .5 ? this.interval = 1 : this.interval++ : 0 === a && (this.prevState >= .5 ? this.interval = -1 : this.interval--), 
                    1 === this.interval && this.crossIndexes.up.push(t), -1 === this.interval && this.crossIndexes.down.push(t), 
                    //save prev state
                    Object.assign(this, {
                        prevState: a,
                        prevFast: e,
                        prevSlow: o,
                        prevHigh: n,
                        prevLow: i
                    });
                }
            }, {
                key: "getResult",
                value: function() {
                    return this.interval;
                }
            } ]) && De(t.prototype, r), e && De(t, e), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
            var t, r, e;
        }();
        function Ye(t) {
            return function(t) {
                if (Array.isArray(t)) return Ke(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || Ge(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Ue(t, r) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, r) {
                var e = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != e) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (e = e.call(t)).next, 0 === r) {
                            if (Object(e) !== e) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(e)).done) && (u.push(n.value), u.length !== r); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != e.return && (a = e.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, r) || Ge(t, r) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Ge(t, r) {
            if (t) {
                if ("string" == typeof t) return Ke(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? Ke(t, r) : void 0;
            }
        }
        function Ke(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var Ve = function(t) {
            var r = t.featureCols, e = t.flatFeaturesColLen, n = t.type, o = t.trainingSize, i = r.length !== e ? " (including flat one-hot encoded array values) " : "";
            console.log('---\nInitialized "'.concat(n, '" with ').concat(e, " features ").concat(i, " and ").concat(o, " rows: \n").concat(JSON.stringify(r), "\n\n"));
        }, $e = function(t, r, e, n) {
            var o = Ue(n, 2), i = o[0], a = o[1];
            return (Math.min(Math.max(t, r), e) - r) / (e - r) * (a - i) + i;
        }, qe = function(t, r) {
            var e = [];
            if (t.length > 0) for (var n = 0; n < t.length; n++) {
                var o = t[n], i = o.type, a = o.size, u = void 0 === a ? null : a, l = o.groupName, c = void 0 === l ? null : l, s = null !== u ? "".concat(i, "_").concat(u) : "".concat(i, "_").concat(c);
                if (!r.hasOwnProperty(s)) throw new Error("Scaled group (".concat(s, ") not found for regressor.options.findGroups[").concat(n, "]: ").concat(JSON.stringify(o)));
                e.push.apply(e, Ye(r[s]));
            }
            return e;
        }, He = function(t, r, e) {
            var n, o = 0, i = // ./src/machine-learning/ml-utilities.js
            function(t, r) {
                var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (!e) {
                    if (Array.isArray(t) || (e = Ge(t)) || r && t && "number" == typeof t.length) {
                        e && (t = e);
                        var n = 0, o = function() {};
                        return {
                            s: o,
                            n: function() {
                                return n >= t.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t[n++]
                                };
                            },
                            e: function(t) {
                                throw t;
                            },
                            f: o
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var i, a = !0, u = !1;
                return {
                    s: function() {
                        e = e.call(t);
                    },
                    n: function() {
                        var t = e.next();
                        return a = t.done, t;
                    },
                    e: function(t) {
                        u = !0, i = t;
                    },
                    f: function() {
                        try {
                            a || null == e.return || e.return();
                        } finally {
                            if (u) throw i;
                        }
                    }
                };
            }(t);
            try {
                for (i.s(); !(n = i.n()).done; ) {
                    var a = n.value;
                    if (!r.hasOwnProperty(a)) throw new Error('Property "'.concat(a, '" not found in "verticalOhlcv".'));
                    var u = r[a][e];
                    if (null == u || Number.isNaN(u)) throw new Error('Invalid value of property "'.concat(a, '".'));
                    if (a.startsWith("one_hot_") || a.startsWith("pca_")) o += r[a][e].length; else o += 1;
                }
            } catch (t) {
                i.e(t);
            } finally {
                i.f();
            }
            return o;
        }, Be = function(t) {
            // If Y[0] isn't an array, treat Y as a single-column 2D array
            var r = Array.isArray(t[0]) ? t : t.map((function(t) {
                return [ t ];
            })), e = r[0].length;
            // Number of columns in our (possibly wrapped) data
                        // Return count + 1 (same as before)
            return Array.from({
                length: e
            }).reduce((function(t, e, n) {
                return t + new Set(r.map((function(t) {
                    return t[n];
                }))).size;
            }), 0) + 1;
        }, Je = function(t) {
            var r = t.trainingCols, e = t.findGroups, n = t.verticalOhlcv, o = t.scaledGroups, i = [].concat(Ye(r), Ye(qe(e, o)));
            if (0 === i.length) return [];
            // sanity‐check that all features exist
            for (var a = !1, u = 0; u < i.length; u++) {
                var l = i[u];
                if (!n.hasOwnProperty(l)) {
                    a = !0;
                    break;
                }
            }
            return a ? [] : i;
        }, Xe = function(t) {
            var r = t.metrics, e = t.trueLabel, n = t.predictedLabel;
            // Increment overall counters
                        r.total = (r.total || 0) + 1, r.correct = r.correct || 0, 
            // Initialize per‐label stats container if needed
            r.labels = r.labels || {};
            var o = n.toString();
            // Ensure we have a slot for this label
                        // Recompute accuracy for each label
            for (var i in r.labels[o] || (r.labels[o] = {
                total: 0,
                correct: 0,
                accuracy: 0
            }), 
            // Update this label’s total predictions
            r.labels[o].total++, 
            // If correct, bump both overall and per-label correct counters
            n === e && (r.correct++, r.labels[o].correct++), 
            // Recompute overall accuracy
            r.accuracy = r.correct / r.total, r.labels) {
                var a = r.labels[i];
                a.accuracy = a.correct / a.total;
            }
        };
        // ./src/studies/dateTime.js
        function We(t) {
            return We = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, We(t);
        }
        function Ze(t, r) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, r) {
                var e = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != e) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (e = e.call(t)).next, 0 === r) {
                            if (Object(e) !== e) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(e)).done) && (u.push(n.value), u.length !== r); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != e.return && (a = e.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, r) || nn(t, r) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Qe(t, r) {
            var e = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                r && (n = n.filter((function(r) {
                    return Object.getOwnPropertyDescriptor(t, r).enumerable;
                }))), e.push.apply(e, n);
            }
            return e;
        }
        function tn(t) {
            for (var r = 1; r < arguments.length; r++) {
                var e = null != arguments[r] ? arguments[r] : {};
                r % 2 ? Qe(Object(e), !0).forEach((function(r) {
                    rn(t, r, e[r]);
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)) : Qe(Object(e)).forEach((function(r) {
                    Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
                }));
            }
            return t;
        }
        function rn(t, r, e) {
            return (r = function(t) {
                var r = function(t, r) {
                    if ("object" != We(t) || !t) return t;
                    var e = t[Symbol.toPrimitive];
                    if (void 0 !== e) {
                        var n = e.call(t, r || "default");
                        if ("object" != We(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === r ? String : Number)(t);
                }(t, "string");
                return "symbol" == We(r) ? r : r + "";
            }(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function en(t) {
            return function(t) {
                if (Array.isArray(t)) return on(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || nn(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function nn(t, r) {
            if (t) {
                if ("string" == typeof t) return on(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? on(t, r) : void 0;
            }
        }
        function on(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var an = function(t, r, e, n, o) {
            for (var i = function(t, e) {
                return r ? function(t, r) {
                    var e = new Uint8Array(r);
                    return e[t] = 1, e;
                }(t, e) : t;
            }, a = rn(rn(rn(rn(rn(rn({}, "".concat(n, "year"), t.getUTCFullYear()), "".concat(n, "month"), t.getUTCMonth()), "".concat(n, "hour"), t.getUTCHours()), "".concat(n, "minute"), t.getUTCMinutes()), "".concat(n, "day_of_the_week"), t.getUTCDay()), "".concat(n, "day_of_the_month"), t.getUTCDate() - 1), u = 0, l = Object.entries(e); u < l.length; u++) {
                var c = Ze(l[u], 2), s = c[0], f = c[1], y = s === "".concat(n, "year") ? a[s] - o : a[s];
                a[s] = i(y, f);
            }
            return a;
        };
        // ./src/machine-learning/scaler.js
        function un(t) {
            return function(t) {
                if (Array.isArray(t)) return cn(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || ln(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function ln(t, r) {
            if (t) {
                if ("string" == typeof t) return cn(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? cn(t, r) : void 0;
            }
        }
        function cn(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        // ./src/studies/mapCols.js
        function sn(t, r) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, r) {
                var e = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != e) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (e = e.call(t)).next, 0 === r) {
                            if (Object(e) !== e) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(e)).done) && (u.push(n.value), u.length !== r); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != e.return && (a = e.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, r) || fn(t, r) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function fn(t, r) {
            if (t) {
                if ("string" == typeof t) return yn(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? yn(t, r) : void 0;
            }
        }
        function yn(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var pn = function(t) {
            var r = t.main, e = t.index, n = r.verticalOhlcv, o = n.close[e], i = n.close[e - 1];
            return void 0 === i ? null : {
                change: (o - i) / i
            };
        };
        // ./src/machine-learning/trainX.js
        function hn(t, r) {
            var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!e) {
                if (Array.isArray(t) || (e = function(t, r) {
                    if (t) {
                        if ("string" == typeof t) return vn(t, r);
                        var e = {}.toString.call(t).slice(8, -1);
                        return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? vn(t, r) : void 0;
                    }
                }(t)) || r && t && "number" == typeof t.length) {
                    e && (t = e);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    e = e.call(t);
                },
                n: function() {
                    var t = e.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == e.return || e.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function vn(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        /**
 * Builds a flattened lookback feature vector or returns null if any value is non‐finite.
 *
 * @param {string[]} featureCols                – list of feature column keys
 * @param {Object}   instances                  – your instances object (with crossPairs)
 * @param {number}   flatFeaturesColLen         – total number of flattened feature slots
 * @param {string}   type                       – a string used only for error reporting
 * @param {number}   index                      – current time index
 * @param {number}   lookbackAbs                – number of lags to include
 * @param {Object}   verticalOhlcv              – an object mapping each key to its time series array
 * @returns {number[]\|null}                    – the feature vector or null if exiting early
 */        var dn = function(t) {
            var r, e = t.featureCols, n = t.flatFeaturesColLen, o = t.type, i = t.index, a = t.lookbackAbs, u = t.main.verticalOhlcv, l = !1, c = [], s = hn(e);
            try {
                for (s.s(); !(r = s.n()).done; ) {
                    var f = r.value;
                    if (f.startsWith("one_hot_") || f.startsWith("pca_")) for (var y = u[f][i].length, p = 0; p < y; p++) c.push({
                        key: f,
                        bit: p
                    }); else c.push({
                        key: f
                    });
                }
            } catch (t) {
                s.e(t);
            } finally {
                s.f();
            }
            if (c.length !== n) throw new Error("slots (".concat(c.length, ") ≠ flatFeaturesColLen (").concat(n, ") in ").concat(o, " index ").concat(i));
            // --- ALLOCATE AND FILL trainX ---
                        for (var h = new Array(n * a).fill(NaN), v = 0; v < a; v++) {
                for (var d = i - v, m = 0; m < c.length; m++) {
                    var b = c[m], g = b.key, w = b.bit, S = u[g][d], O = null != w ? S[w] : S;
                    if (!Number.isFinite(O)) {
                        l = !0;
                        break;
                    }
                    h[v * n + m] = O;
                }
                if (l) break;
            }
            return l ? null : h;
        };
        function mn(t) {
            return function(t) {
                if (Array.isArray(t)) return gn(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || bn(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function bn(t, r) {
            if (t) {
                if ("string" == typeof t) return gn(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? gn(t, r) : void 0;
            }
        }
        function gn(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var wn = "pca", Sn = function(t, r, n) {
            var o = n.prefix, i = n.trainingSize, a = n.findGroups, u = n.trainingCols, l = n.lookbackAbs, c = n.modelArgs, s = t.verticalOhlcv, f = t.scaledGroups, y = t.len, p = t.instances, h = t.ML, v = t.invalidValueIndex + 2, d = h.models;
            if (r === v) p.hasOwnProperty(wn) || (p[wn] = {}), p[wn][o] = {
                flatFeaturesColLen: 0,
                featureCols: [],
                X: []
            }, s[o] = new Array(y).fill(null), t.notNumberKeys.add(o); else {
                if (r < v || r < l) return;
                if (r + 1 === y) {
                    if (0 === p[wn][o].featureCols.length) {
                        var m = [].concat(mn(u), mn(qe(a, f)));
                        throw new Error("Some of the provided ".concat(o, ' features where not found in "verticalOhlcv": ').concat(JSON.stringify(m)));
                    }
                    //last execution
                                        var b, g = // ./src/machine-learning/pca.js
                    function(t, r) {
                        var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!e) {
                            if (Array.isArray(t) || (e = bn(t)) || r && t && "number" == typeof t.length) {
                                e && (t = e);
                                var n = 0, o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return n >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[n++]
                                        };
                                    },
                                    e: function(t) {
                                        throw t;
                                    },
                                    f: o
                                };
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }
                        var i, a = !0, u = !1;
                        return {
                            s: function() {
                                e = e.call(t);
                            },
                            n: function() {
                                var t = e.next();
                                return a = t.done, t;
                            },
                            e: function(t) {
                                u = !0, i = t;
                            },
                            f: function() {
                                try {
                                    a || null == e.return || e.return();
                                } finally {
                                    if (u) throw i;
                                }
                            }
                        };
                    }(p[wn][o].featureCols);
                    try {
                        for (g.s(); !(b = g.n()).done; ) {
                            var w = b.value;
                            if (!s.hasOwnProperty(w)) throw new Error('Feature "'.concat(w, '" not found in verticalOhlcv for pca.'));
                        }
                    } catch (t) {
                        g.e(t);
                    } finally {
                        g.f();
                    }
                    if (p[wn][o].X.length < i) {
                        var S = p[wn][o].X.length - i;
                        throw new Error('The current "trainingSize" at "'.concat(o, '" requires at least ').concat(S, ' more datapoints. Try adding more input ohlcv rows or reducing the "trainingSize" by ').concat(S, "."));
                    }
                }
            }
            var O = p[wn][o];
            if (0 === O.flatFeaturesColLen) {
                if (O.featureCols = Je({
                    trainingCols: u,
                    findGroups: a,
                    verticalOhlcv: s,
                    scaledGroups: f
                }), !e(t, r, O.featureCols)) return;
                O.flatFeaturesColLen = He(O.featureCols, s, r);
            }
            if (0 !== O.flatFeaturesColLen) {
                var A = O.X, j = O.featureCols, N = O.flatFeaturesColLen, P = dn({
                    featureCols: j,
                    flatFeaturesColLen: N,
                    type: wn,
                    index: r,
                    lookbackAbs: l,
                    main: t
                });
                if (null != P) {
                    if (d.hasOwnProperty(o)) {
                        var T = d[o].predict([ P ]).to2DArray();
                        s[o][r] = T[0];
                    }
                    A.push(P), A.length > i && A.shift(), A.length === i && (d[o] = new h.classes.PCA(A, c));
                }
            }
        };
        // ./src/machine-learning/train-utilities.js
        function On(t) {
            return On = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, On(t);
        }
        function An(t, r) {
            var e = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                r && (n = n.filter((function(r) {
                    return Object.getOwnPropertyDescriptor(t, r).enumerable;
                }))), e.push.apply(e, n);
            }
            return e;
        }
        function jn(t) {
            for (var r = 1; r < arguments.length; r++) {
                var e = null != arguments[r] ? arguments[r] : {};
                r % 2 ? An(Object(e), !0).forEach((function(r) {
                    Nn(t, r, e[r]);
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)) : An(Object(e)).forEach((function(r) {
                    Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
                }));
            }
            return t;
        }
        function Nn(t, r, e) {
            return (r = function(t) {
                var r = function(t, r) {
                    if ("object" != On(t) || !t) return t;
                    var e = t[Symbol.toPrimitive];
                    if (void 0 !== e) {
                        var n = e.call(t, r || "default");
                        if ("object" != On(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === r ? String : Number)(t);
                }(t, "string");
                return "symbol" == On(r) ? r : r + "";
            }(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        var Pn = function(t) {
            var r, e = t.main, n = t.type, o = t.xRows, i = t.yRows, a = t.useTrainMethod, u = t.modelArgs, l = t.algo, c = t.uniqueLabels, s = void 0 === c ? 0 : c, f = e.ML.classes[n];
            if (![ "classifier", "regressor" ].includes(l.toString())) throw new Error('Invalid "algo" para in "modelTrain" function.');
            return "FeedForwardNeuralNetworks" === n ? (u || (u = {}), u.hasOwnProperty("activation") || ("regressor" === l ? u = jn(jn({}, u), {}, {
                activation: "identity",
                hiddenLayers: [ 20 ]
            }) : "classifier" === l && (u = jn(jn({}, u), {}, {
                activation: 2 === s ? "logistic" : "identity",
                hiddenLayers: [ 20 ]
            })))) : "KNN" === n && (u || (u = {}), u.k = s), a ? (r = new f(u)).train(o, i) : r = new f(o, i, u), 
            r;
        };
        // ./src/machine-learning/regressor.js
        function Tn(t) {
            return Tn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Tn(t);
        }
        function xn(t) {
            return function(t) {
                if (Array.isArray(t)) return En(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || _n(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function _n(t, r) {
            if (t) {
                if ("string" == typeof t) return En(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? En(t, r) : void 0;
            }
        }
        function En(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var kn = "regressor", Cn = function(t, r, n, o) {
            var i = o.target, a = o.predictions, u = o.retrain, l = o.trainingCols, c = o.findGroups, s = o.type, f = o.modelArgs, y = o.precompute, p = y.lookbackAbs, h = y.prefix, v = y.flatX, d = y.flatY, m = y.useTrainMethod, b = t.verticalOhlcv, g = t.len, w = t.instances, S = t.scaledGroups, O = t.invalidValueIndex, A = t.ML.models, j = O + 1;
            if (r === j) {
                w.hasOwnProperty(kn) || (w.regressor = {}), w.regressor.hasOwnProperty(h) || (w.regressor[h] = {});
                var N = d ? a : 1;
 
                                w.regressor[h] = {
                    expectedLoops: N,
                    trainingSize: n,
                    isTrained: new Array(N).fill(!1),
                    shouldRetrain: u,
                    featureCols: [],
                    flatFeaturesColLen: 0,
                    X: [],
                    Y: Array.from({
                        length: N
                    }, (function() {
                        return [];
                    }))
                };
                for (var P = 0; P < a; P++) {
                    var T = "".concat(h, "_").concat(P + 1);
                    b[T] = new Float64Array(g).fill(NaN), A.hasOwnProperty(T) || (A[T] = []);
                }
            } else {
                if (r < j || r < p) return;
                if (r + 1 === g) {
                    if (0 === w.regressor[h].featureCols.length) {
                        var x = [].concat(xn(l), xn(qe(c, S)));
                        throw new Error("Some of the provided ".concat(h, ' features where not found in "verticalOhlcv": ').concat(JSON.stringify(x)));
                    }
                    //last execution
                                        var _, E = function(t, r) {
                        var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!e) {
                            if (Array.isArray(t) || (e = _n(t)) || r && t && "number" == typeof t.length) {
                                e && (t = e);
                                var n = 0, o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return n >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[n++]
                                        };
                                    },
                                    e: function(t) {
                                        throw t;
                                    },
                                    f: o
                                };
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }
                        var i, a = !0, u = !1;
                        return {
                            s: function() {
                                e = e.call(t);
                            },
                            n: function() {
                                var t = e.next();
                                return a = t.done, t;
                            },
                            e: function(t) {
                                u = !0, i = t;
                            },
                            f: function() {
                                try {
                                    a || null == e.return || e.return();
                                } finally {
                                    if (u) throw i;
                                }
                            }
                        };
                    }(w.regressor[h].featureCols);
                    try {
                        for (E.s(); !(_ = E.n()).done; ) {
                            var k = _.value;
                            if (!b.hasOwnProperty(k)) throw new Error('Feature "'.concat(k, '" not found in verticalOhlcv for ').concat(h, "."));
                        }
                    } catch (t) {
                        E.e(t);
                    } finally {
                        E.f();
                    }
                    if (w.regressor[h].X.length < n) {
                        var C = w.regressor[h].X.length - n;
                        throw new Error('The current "trainingSize" at "'.concat(h, '" requires at least ').concat(C, ' more datapoints. Try adding more input ohlcv rows or reducing the "trainingSize" by ').concat(C, "."));
                    }
                }
            }
            var M = w.regressor[h];
            if (0 === M.flatFeaturesColLen) {
                if (M.featureCols = Je({
                    trainingCols: l,
                    findGroups: c,
                    verticalOhlcv: b,
                    scaledGroups: S
                }), !e(t, r, M.featureCols)) return;
                M.flatFeaturesColLen = He(M.featureCols, b, r), Ve({
                    featureCols: M.featureCols,
                    flatFeaturesColLen: M.flatFeaturesColLen,
                    type: s,
                    trainingSize: n
                });
            }
            if (0 !== M.flatFeaturesColLen) {
                if (!b.hasOwnProperty(i)) throw new Error('Target property "'.concat(i, '" not found in verticalOhlcv for regressor.'));
                var I = M.expectedLoops, D = M.X, R = M.Y, F = M.flatFeaturesColLen, L = M.featureCols, z = M.shouldRetrain;
                if (!L.includes(i)) throw new Error('Target property "'.concat(i, '" not found in ').concat(s, " features: ").concat(JSON.stringify(L)));
                var Y = v ? b[i][r] : dn({
                    featureCols: L,
                    flatFeaturesColLen: F,
                    type: s,
                    index: r,
                    lookbackAbs: p,
                    main: t
                });
                if (v) {
                    if (!Number.isFinite(Y)) return;
 // or `trainX == null`
                                } else if (null == Y) return;
                for (var U = [], G = 0; G < a; G++) {
                    var K = b[i][r + G + 1];
                    if (!Number.isFinite(K)) break;
                    U.push(K);
                }
                //if univariable Y (flatY) a model is created for each prediction
                                for (var V = 0; V < I; V++) {
                    var $ = "".concat(h, "_").concat(V + 1), q = R[V], H = d ? void 0 === U[V] ? null : U[V] : U, B = M.isTrained[V];
                    //predicts using previously saved models even if current currTrainY is not available
                    if (A.hasOwnProperty($) && B && (!1 === z || A[$].length === a)) {
                        var J = A[$][0].predict([ Y ])[0];
                        if (d) {
                            if (Number.isNaN(J)) throw new Error("Prediction of ".concat(s, " at index ").concat(r, " was expecting a number."));
                            t.pushToMain({
                                index: r,
                                key: $,
                                value: J
                            });
                        } else {
                            if (!Array.isArray(J) || J.length !== a) throw new Error('Prediction output of "'.concat(s, '" at index ').concat(r, " was expecting an array of values."));
                            for (var X = 0; X < a; X++) t.pushToMain({
                                index: r,
                                key: "".concat(h, "_").concat(X + 1),
                                value: J[X]
                            });
                        }
                    }
                    if (!(r + a + 1 > g) && (!(U.length < a) && null !== H)) {
                        if (d) {
                            if ("number" != typeof H || Number.isNaN(H)) throw new Error("currTrainY must return number, got ".concat(Tn(H), " at index ").concat(r));
                        } else {
                            if (!Array.isArray(H)) throw new Error("currTrainY must return an array, got ".concat(Tn(H), " at index ").concat(r));
                            if (H.length !== a) throw new Error("currTrainY length (".concat(H.length, ') ≠ "options.predictions" (').concat(a, ') for regressor "').concat(s, '"'));
                        }
                        // enqueue
                                                q.push(H), q.length > n && q.shift(), 0 === V && (D.push(Y), 
                        D.length > n && D.shift()), (z || !B) && D.length === n && q.length === n && (A[$].push(Pn({
                            main: t,
                            type: s,
                            xRows: D,
                            yRows: q,
                            useTrainMethod: m,
                            modelArgs: f,
                            algo: kn,
                            uniqueLabels: 0
                        })), A[$].length > a && A[$].shift(), M.isTrained[V] = !0);
                    }
                }
            }
        };
        // ./src/machine-learning/classifier.js
        function Mn(t) {
            return Mn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Mn(t);
        }
        function In(t) {
            return function(t) {
                if (Array.isArray(t)) return Rn(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || Dn(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Dn(t, r) {
            if (t) {
                if ("string" == typeof t) return Rn(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? Rn(t, r) : void 0;
            }
        }
        function Rn(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var Fn = "classifier", Ln = function(t, r, n, o) {
            var i = o.yCallback, a = o.trainingCols, u = o.findGroups, l = void 0 === u ? [] : u, c = o.retrain, s = o.type, f = o.modelArgs, y = o.horizon, p = o.precompute, h = o.predictions, v = p.lookbackAbs, d = p.prefix, m = p.useTrainMethod, b = p.flatY, g = t.verticalOhlcv, w = t.len, S = t.instances, O = t.scaledGroups, A = t.invalidValueIndex, j = t.ML, N = j.models, P = A + 1;
            // ─── INITIALIZATION ───────────────────────────────────────────────
            if (r === P) {
                // prepare instance storage
                S.hasOwnProperty(Fn) || (S[Fn] = {}), S[Fn].hasOwnProperty(d) || (S[Fn][d] = {});
                var T = b ? h : 1;
 
                                S[Fn][d] = {
                    expectedLoops: T,
                    isTrained: new Array(T).fill(!1),
                    uniqueLabels: new Array(T).fill(0),
                    shouldRetrain: c,
                    featureCols: [],
                    flatFeaturesColLen: 0,
                    X: [],
                    Y: Array.from({
                        length: T
                    }, (function() {
                        return [];
                    }))
                };
                for (var x = 0; x < h; x++) {
                    var _ = "".concat(d, "_").concat(x + 1);
                    g[_] = "KNN" === s ? new Array(w).fill(null) : new Float32Array(w).fill(NaN), j.metrics[_] = {
                        accuracy: {},
                        total: 0,
                        correct: 0,
                        labels: {}
                    }, N.hasOwnProperty(_) || (N[_] = []);
                }
            } else {
                if (r < P || r < v) return;
                if (r + 1 === w) {
                    if (0 === S[Fn][d].featureCols.length) {
                        var E = [].concat(In(a), In(qe(l, O)));
                        throw new Error("Some of the provided ".concat(Fn, ' "').concat(d, '" features where not found in "verticalOhlcv": ').concat(JSON.stringify(E)));
                    }
                    //last execution
                                        var k, C = function(t, r) {
                        var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!e) {
                            if (Array.isArray(t) || (e = Dn(t)) || r && t && "number" == typeof t.length) {
                                e && (t = e);
                                var n = 0, o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return n >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[n++]
                                        };
                                    },
                                    e: function(t) {
                                        throw t;
                                    },
                                    f: o
                                };
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }
                        var i, a = !0, u = !1;
                        return {
                            s: function() {
                                e = e.call(t);
                            },
                            n: function() {
                                var t = e.next();
                                return a = t.done, t;
                            },
                            e: function(t) {
                                u = !0, i = t;
                            },
                            f: function() {
                                try {
                                    a || null == e.return || e.return();
                                } finally {
                                    if (u) throw i;
                                }
                            }
                        };
                    }(S[Fn][d].featureCols);
                    try {
                        for (C.s(); !(k = C.n()).done; ) {
                            var M = k.value;
                            if (!g.hasOwnProperty(M)) throw new Error('Feature "'.concat(M, '" not found in verticalOhlcv for ').concat(d, "."));
                        }
                    } catch (t) {
                        C.e(t);
                    } finally {
                        C.f();
                    }
                    if (S[Fn][d].X.length < n) {
                        var I = S[Fn][d].X.length - n;
                        throw new Error('The current "trainingSize" at '.concat(Fn, ' "').concat(d, '" requires at least ').concat(I, ' more datapoints. Try adding more input ohlcv rows or reducing the "trainingSize" by ').concat(I, "."));
                    }
                }
            }
            var D = S[Fn][d];
            if (0 === D.flatFeaturesColLen) {
                if (D.featureCols = Je({
                    trainingCols: a,
                    findGroups: l,
                    verticalOhlcv: g,
                    scaledGroups: O
                }), !e(t, r, D.featureCols)) return;
                D.flatFeaturesColLen = He(D.featureCols, g, r), Ve({
                    featureCols: D.featureCols,
                    flatFeaturesColLen: D.flatFeaturesColLen,
                    type: s,
                    trainingSize: n
                });
            }
            if (0 !== D.flatFeaturesColLen) {
                var R = D.uniqueLabels, F = D.expectedLoops, L = D.featureCols, z = D.flatFeaturesColLen, Y = D.shouldRetrain, U = D.X, G = dn({
                    featureCols: L,
                    flatFeaturesColLen: z,
                    type: s,
                    index: r,
                    lookbackAbs: v,
                    main: t
                });
                if (G) {
                    //if univariable Y (flatY) a model is created for each prediction
                    var K = i(r, g, y);
                    if (null !== K && (!Array.isArray(K) || K.length !== h)) throw new Error("trainY must be null or an array with ".concat(h, ' items, got "').concat(JSON.stringify(K), '" at index ').concat(r, " for ").concat(s));
                    for (var V = 0; V < F; V++) {
                        var $ = "".concat(d, "_").concat(V + 1), q = D.Y[V], H = b ? null === K ? null : K[V] : K, B = D.isTrained[V];
                        //predicts using previously saved models even if current currTrainY is not available
                        if (N.hasOwnProperty($) && B && (!1 === Y || N[$].length === y)) {
                            var J = N[$][0].predict([ G ])[0];
                            if (b) {
                                if (null == J) throw new Error("Prediction of ".concat(d, " at index ").concat(r, " was expecting a number."));
                                t.pushToMain({
                                    index: r,
                                    key: $,
                                    value: J
                                }), null != H && Xe({
                                    metrics: j.metrics[$],
                                    trueLabel: H,
                                    predictedLabel: J
                                });
                            } else {
                                if (!Array.isArray(J) || J.length !== h) throw new Error("Prediction output of ".concat(Fn, ' "').concat(d, '" at index ').concat(r, " was expecting an array of values."));
                                for (var X = 0; X < h; X++) t.pushToMain({
                                    index: r,
                                    key: "".concat(d, "_").concat(X + 1),
                                    value: J[X]
                                }), Array.isArray(H) && H.length === h && Xe({
                                    metrics: j.metrics["".concat(d, "_").concat(X + 1)],
                                    trueLabel: H[X],
                                    predictedLabel: J[X]
                                });
                            }
                        }
                        if (!(r + h + 1 > w) && null !== H) {
                            // future not defined
                            if (b) {
                                if (void 0 === H || null == H) throw new Error("currTrainY must return number, string or boolean got ".concat(Mn(H), " at index ").concat(r));
                            } else if (H.length !== h) throw new Error("The number of label columns returned (".concat(H.length, ") doesn’t match the options.predictions (").concat(h, ") setting for the ").concat(Fn, ' "').concat(d, '" classifier. ') + "Please update your yCallback function so its output array items align with options.predictions.");
                            // enqueue
                                                        if (q.push(H), q.length > n && q.shift(), 0 === V && (U.push(G), 
                            U.length > n && U.shift()), (Y || !B) && U.length === n && q.length === n) {
                                if (!1 === B && (R[V] = Be(q), R[V] < 2)) throw new Error("Invalid number or labels in ".concat(d, '. Check the logic of your "yCallback" function.'));
                                N[$].push(Pn({
                                    main: t,
                                    type: s,
                                    xRows: U,
                                    yRows: q,
                                    useTrainMethod: m,
                                    modelArgs: f,
                                    algo: Fn,
                                    uniqueLabels: R[V]
                                })), N[$].length > y && N[$].shift(), D.isTrained[V] = !0;
                            }
                        }
                    }
                }
            }
        };
        // ./src/core-functions/mainLoop.js
        function zn(t) {
            return function(t) {
                if (Array.isArray(t)) return Kn(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || Gn(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Yn(t, r) {
            var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!e) {
                if (Array.isArray(t) || (e = Gn(t)) || r && t && "number" == typeof t.length) {
                    e && (t = e);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    e = e.call(t);
                },
                n: function() {
                    var t = e.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == e.return || e.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function Un(t, r) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }
            // Map indicator keys to their respective functions
            (t) || function(t, r) {
                var e = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != e) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (e = e.call(t)).next, 0 === r) {
                            if (Object(e) !== e) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(e)).done) && (u.push(n.value), u.length !== r); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != e.return && (a = e.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, r) || Gn(t, r) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Gn(t, r) {
            if (t) {
                if ("string" == typeof t) return Kn(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? Kn(t, r) : void 0;
            }
        }
        function Kn(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var Vn = {
            dateTime: function(t, r, e) {
                var n = e.lag, o = e.oneHot, i = e.precompute, a = t.instances, u = t.verticalOhlcv, l = t.notNumberKeys, c = i.prefix;
                if (0 === r) {
                    var s = t.len, f = t.dateType, y = t.arrayTypes;
                    if (!f) throw Error('dateTime method found and invalid "date" in input ohlcv');
                    var p = u.date[0].getUTCFullYear(), h = (new Date).getUTCFullYear();
                    Object.assign(a, {
                        dateTime: {
                            colKeys: [].concat(en(i.colKeys), [ "".concat(c, "year") ]),
                            colKeySizes: tn(tn({}, i.colKeySizes), {}, rn({}, "".concat(c, "year"), h - p + 1)),
                            startYear: p
                        }
                    });
                    var v, d = a.dateTime.colKeys, m = o ? Array : Int16Array, b = o ? null : NaN, g = o ? "Array" : "Int16Array", w = function(t, r) {
                        var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!e) {
                            if (Array.isArray(t) || (e = nn(t)) || r && t && "number" == typeof t.length) {
                                e && (t = e);
                                var n = 0, o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return n >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[n++]
                                        };
                                    },
                                    e: function(t) {
                                        throw t;
                                    },
                                    f: o
                                };
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }
                        var i, a = !0, u = !1;
                        return {
                            s: function() {
                                e = e.call(t);
                            },
                            n: function() {
                                var t = e.next();
                                return a = t.done, t;
                            },
                            e: function(t) {
                                u = !0, i = t;
                            },
                            f: function() {
                                try {
                                    a || null == e.return || e.return();
                                } finally {
                                    if (u) throw i;
                                }
                            }
                        };
                    }(d);
                    // choose your ctor, fill-value and type-name once
                                        try {
                        for (w.s(); !(v = w.n()).done; ) {
                            var S = v.value;
                            // 1) set the arrayType
                                                        y[S] = g, 
                            // 2) allocate and fill the backing array
                            u[S] = new m(s).fill(b), 
                            // 3) mark as non-numeric
                            l.add(S);
                        }
                        // finally, apply lag once
                                        } catch (t) {
                        w.e(t);
                    } finally {
                        w.f();
                    }
                    n > 0 && t.lag(d, n);
                }
                for (var O = a.dateTime, A = O.colKeySizes, j = O.startYear, N = u.date[r], P = an(N, o, A, c, j), T = 0, x = Object.entries(P); T < x.length; T++) {
                    var _ = Ze(x[T], 2), E = _[0], k = _[1];
                    t.pushToMain({
                        index: r,
                        key: E,
                        value: k
                    });
                }
            },
            rsi: function(t, r, e, n) {
                var o = n.target, i = n.lag, a = n.parser, u = n.prefix, l = n.minmax, c = t.verticalOhlcv, s = t.instances, f = "close" === o ? "" : "_".concat(o), y = "".concat(u, "rsi_").concat(e).concat(f), p = "".concat(u, "rsi_sma_").concat(e).concat(f);
                // Initialization on the first index.
                if (0 === r) {
                    var h = t.len, v = t.arrayTypes;
                    if (!c.hasOwnProperty(o)) throw new Error("Target property ".concat(o, " not found in verticalOhlcv for rsi."));
                    Object.assign(s, Br(Br({}, y, new Ir(e)), p, new pt(e))), Object.assign(c, Br(Br({}, y, new Float64Array(h).fill(NaN)), p, new Float64Array(h).fill(NaN)));
                    var d = [ y, p ];
                    i > 0 && t.lag(d, i);
                    //[key, key_lag_1, …, key_lag_n] for each key
                                        var m = i > 0 ? d.flatMap((function(t) {
                        return [ t ].concat($r(Array.from({
                            length: i
                        }, (function(r, e) {
                            return "".concat(t, "_lag_").concat(e + 1);
                        }))));
                    })) : d;
                    if (Array.isArray(l)) {
                        var b, g, w = null !== (g = (b = t.scaledGroups).minmax_rsi) && void 0 !== g ? g : b.minmax_rsi = [];
                        w.push.apply(w, $r(m));
                    }
                    var S, O = function(t, r) {
                        var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!e) {
                            if (Array.isArray(t) || (e = qr(t)) || r && t && "number" == typeof t.length) {
                                e && (t = e);
                                var n = 0, o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return n >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[n++]
                                        };
                                    },
                                    e: function(t) {
                                        throw t;
                                    },
                                    f: o
                                };
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }
                        var i, a = !0, u = !1;
                        return {
                            s: function() {
                                e = e.call(t);
                            },
                            n: function() {
                                var t = e.next();
                                return a = t.done, t;
                            },
                            e: function(t) {
                                u = !0, i = t;
                            },
                            f: function() {
                                try {
                                    a || null == e.return || e.return();
                                } finally {
                                    if (u) throw i;
                                }
                            }
                        };
                    }(m);
                    try {
                        for (O.s(); !(S = O.n()).done; ) {
                            v[S.value] = "Float64Array";
                        }
                    } catch (t) {
                        O.e(t);
                    } finally {
                        O.f();
                    }
                }
                var A = c[o][r], j = NaN, N = NaN;
                // Update the RSI indicator.
                s[y].update(A);
                try {
                    j = s[y].getResult();
                } catch (t) {
                    j = NaN;
                }
                // Always push the RSI value, using NaN as a fallback.
                                t.pushToMain({
                    index: r,
                    key: y,
                    value: Number.isNaN(j) ? NaN : a(j)
                }), 
                // Update the SMA indicator only if a valid RSI value is available.
                Number.isNaN(j) || s[p].update(j);
                try {
                    N = s[p].getResult();
                } catch (t) {
                    N = NaN;
                }
                // Always push the smoothed RSI value.
                                t.pushToMain({
                    index: r,
                    key: p,
                    value: Number.isNaN(N) ? NaN : a(N)
                });
            },
            stochastic: function(t, r, e, n, o, i) {
                var a = i.minmax, u = i.prefix, l = i.lag, c = i.parser, s = t.verticalOhlcv, f = t.instances, y = (t.scaledGroups, 
                14 === e && 3 === n && 3 === o ? "" : "".concat(e, "_").concat(n, "_").concat(o)), p = "".concat(u, "stoch_d").concat(y), h = "".concat(u, "stoch_k").concat(y), v = "".concat(u).concat(y);
                // Initialization on the first index.
                if (0 === r) {
                    var d = t.len, m = t.arrayTypes;
                    Object.assign(f, Qr({}, v, new Kr(e, n, o))), Object.assign(s, Qr(Qr({}, p, new Float64Array(d).fill(NaN)), h, new Float64Array(d).fill(NaN)));
                    var b = [ p, h ];
                    l > 0 && t.lag(b, l);
                    //[key, key_lag_1, …, key_lag_n] for each key
                                        var g = l > 0 ? b.flatMap((function(t) {
                        return [ t ].concat(Xr(Array.from({
                            length: l
                        }, (function(r, e) {
                            return "".concat(t, "_lag_").concat(e + 1);
                        }))));
                    })) : b;
                    if (Array.isArray(a)) {
                        var w, S, O = null !== (S = (w = t.scaledGroups).minmax_rsi) && void 0 !== S ? S : w.minmax_rsi = [];
                        O.push.apply(O, Xr(g));
                    }
                    var A, j = function(t, r) {
                        var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!e) {
                            if (Array.isArray(t) || (e = Wr(t)) || r && t && "number" == typeof t.length) {
                                e && (t = e);
                                var n = 0, o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return n >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[n++]
                                        };
                                    },
                                    e: function(t) {
                                        throw t;
                                    },
                                    f: o
                                };
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }
                        var i, a = !0, u = !1;
                        return {
                            s: function() {
                                e = e.call(t);
                            },
                            n: function() {
                                var t = e.next();
                                return a = t.done, t;
                            },
                            e: function(t) {
                                u = !0, i = t;
                            },
                            f: function() {
                                try {
                                    a || null == e.return || e.return();
                                } finally {
                                    if (u) throw i;
                                }
                            }
                        };
                    }(g);
                    try {
                        for (j.s(); !(A = j.n()).done; ) {
                            m[A.value] = "Float64Array";
                        }
                    } catch (t) {
                        j.e(t);
                    } finally {
                        j.f();
                    }
                }
                var N = s.close[r], P = s.low[r], T = s.high[r], x = null;
                // Update the stochastic indicator.
                f[v].update({
                    close: N,
                    low: P,
                    high: T
                });
                try {
                    x = f[v].getResult();
                } catch (t) {
                    x = null;
                }
                var _ = x ? c(x.stochK) : NaN, E = x ? c(x.stochD) : NaN;
                t.pushToMain({
                    index: r,
                    key: h,
                    value: _
                }), t.pushToMain({
                    index: r,
                    key: p,
                    value: E
                });
            },
            atr: function(t, r, e, n) {
                var o = n.lag, i = n.percentage, a = n.upper, u = n.lower, l = t.verticalOhlcv, c = t.instances, s = "atr_".concat(e);
                if (0 === r) {
                    var f = t.instances, y = t.verticalOhlcv, p = t.arrayTypes, h = t.len;
                    f[s] = new Xt(e, Nt);
                    var v = [ s ];
                    i && v.push("".concat(s, "_percentage")), null !== a && v.push("".concat(s, "_upper")), 
                    null !== u && v.push("".concat(s, "_lower"));
                    for (var d = 0, m = v; d < m.length; d++) {
                        var b = m[d];
                        y[b] = new Float64Array(h).fill(NaN), p[b] = "Float64Array";
                    }
                    o > 0 && t.lag(v, o);
                }
                // Retrieve the current price value.
                                var g = {
                    high: l.high[r],
                    low: l.low[r],
                    close: l.close[r]
                }, w = c[s];
                // Update the moving average instance.
                w.update(g);
                var S = NaN;
                try {
                    S = w.getResult();
                } catch (t) {}
                if (i) {
                    var O = Number.isNaN(S) ? NaN : S / g.close;
                    t.pushToMain({
                        index: r,
                        key: "".concat(s, "_percentage"),
                        value: O
                    });
                }
                if (null !== a) {
                    var A = Number.isNaN(S) ? NaN : g.close + S * a;
                    t.pushToMain({
                        index: r,
                        key: "".concat(s, "_upper"),
                        value: A
                    });
                }
                if (null !== u) {
                    var j = Number.isNaN(S) ? NaN : g.close - S * u;
                    t.pushToMain({
                        index: r,
                        key: "".concat(s, "_lower"),
                        value: j
                    });
                }
                // Always push the MA value (even if NaN).
                                return t.pushToMain({
                    index: r,
                    key: s,
                    value: S
                }), !0;
            },
            ema: re,
            sma: re,
            macd: function(t, r, e, n, o, i) {
                var a = i.target, u = i.lag, l = i.precomputed, c = t.verticalOhlcv, s = t.instances, f = l.instanceKey;
                // Initialization on the first index.
                if (0 === r) {
                    var y = t.inputParams, p = t.len, h = t.arrayTypes;
                    if (!c.hasOwnProperty(a)) throw new Error("Target property ".concat(a, " not found in verticalOhlcv for macd."));
                    var v, d = 0, m = oe(y);
                    try {
                        for (m.s(); !(v = m.n()).done; ) {
                            "macd" === v.value.key && d++;
                        }
                        // Choose a display prefix based on the number of indicators.
                                        } catch (t) {
                        m.e(t);
                    } finally {
                        m.f();
                    }
                    var b = d > 1 ? "macd_".concat(e, "_").concat(n, "_").concat(o) : "macd", g = a === ae ? "".concat(b, "_diff") : "".concat(b, "_diff_").concat(a), w = a === ae ? "".concat(b, "_dea") : "".concat(b, "_dea_").concat(a), S = a === ae ? "".concat(b, "_histogram") : "".concat(b, "_histogram_").concat(a);
                    // Build the keys.
                                        s.hasOwnProperty("macd") || (s.macd = {
                        numberOfIndicators: d,
                        settings: {}
                    }), s.macd.settings[f] = new Or(new vr(e), new vr(n), new vr(o)), Object.assign(c, ne(ne(ne({}, g, new Float64Array(p).fill(NaN)), w, new Float64Array(p).fill(NaN)), S, new Float64Array(p).fill(NaN)));
                    var O = [ g, w, S ];
                    u > 0 && t.lag(O, u);
                    for (var A = 0, j = O; A < j.length; A++) {
                        h[j[A]] = "Float64Array";
                    }
                }
                var N = s.macd, P = N.numberOfIndicators, T = N.settings, x = P > 1 ? "macd_".concat(e, "_").concat(n, "_").concat(o) : "macd", _ = a === ae ? "".concat(x, "_diff") : "".concat(x, "_diff_").concat(a), E = a === ae ? "".concat(x, "_dea") : "".concat(x, "_dea_").concat(a), k = a === ae ? "".concat(x, "_histogram") : "".concat(x, "_histogram_").concat(a), C = T[f], M = c[a][r];
                C.update(M);
                var I = {};
                try {
                    I = C.getResult();
                } catch (t) {
                    // If the result is unavailable, macdResult remains NaN.
                }
                // Always push values; use NaN as fallback when macdResult is missing.
                                return t.pushToMain({
                    index: r,
                    key: _,
                    value: I ? I.macd : NaN
                }), t.pushToMain({
                    index: r,
                    key: E,
                    value: I ? I.signal : NaN
                }), t.pushToMain({
                    index: r,
                    key: k,
                    value: I ? I.histogram : NaN
                }), !0;
            },
            relativeVolume: function(t, r, e, n) {
                var o = n.lag, i = "relative_volume_".concat(e), a = t.instances, u = t.verticalOhlcv;
                if (0 === r) {
                    var l = t.len, c = t.arrayTypes;
                    a[i] = {
                        instance: new pt(e),
                        prevRelativeVolumeSma: NaN
                    }, u[i] = new Float64Array(l).fill(NaN), o > 0 && t.lag([ i ], o), c[i] = "Float64Array";
                }
                var s = u.volume[r], f = a[i].instance;
                f.update(s);
                var y = NaN;
                try {
                    y = f.getResult();
                } catch (t) {}
                var p = a[i].prevRelativeVolumeSma, h = NaN;
                // Only calculate relative volume if both current SMA and previous SMA are valid numbers and prevSma is not zero.
                return Number.isNaN(y) || Number.isNaN(p) || (h = s / p), t.pushToMain({
                    index: r,
                    key: i,
                    value: h
                }), a[i].prevRelativeVolumeSma = y, !0;
            },
            donchianChannels: function(t, r, e, n, o) {
                var i = t.verticalOhlcv, a = t.instances, u = t.len, l = t.inputParams, c = t.arrayTypes, s = t.lag, f = o.height, y = o.range, p = o.decimals, h = "".concat(e, "_").concat(n);
                // ---- INIT (only at first bar) ----
                if (0 === r) {
                    // how many donchianChannels calls in this session?
                    var v = l.filter((function(t) {
                        return "donchianChannels" === t.key;
                    })).length, d = "donchian_channel", m = v > 1 ? "".concat(d, "_").concat(h) : d, b = [ "upper", "basis", "lower" ].map((function(t) {
                        return "".concat(m, "_").concat(t);
                    }));
                    f && b.push("".concat(m, "_height"));
                    var g, w = function(t, r) {
                        var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!e) {
                            if (Array.isArray(t) || (e = ye(t)) || r && t && "number" == typeof t.length) {
                                e && (t = e);
                                var n = 0, o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return n >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[n++]
                                        };
                                    },
                                    e: function(t) {
                                        throw t;
                                    },
                                    f: o
                                };
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }
                        var i, a = !0, u = !1;
                        return {
                            s: function() {
                                e = e.call(t);
                            },
                            n: function() {
                                var t = e.next();
                                return a = t.done, t;
                            },
                            e: function(t) {
                                u = !0, i = t;
                            },
                            f: function() {
                                try {
                                    a || null == e.return || e.return();
                                } finally {
                                    if (u) throw i;
                                }
                            }
                        };
                    }(y);
                    try {
                        for (w.s(); !(g = w.n()).done; ) {
                            var S = g.value;
                            if (!(S in i)) throw new Error('Invalid range key "'.concat(S, '".'));
                            b.push("".concat(m, "_range_").concat(S));
                        }
                        // bootstrap instance
                                        } catch (t) {
                        w.e(t);
                    } finally {
                        w.f();
                    }
                    a.donchian_channel || (a.donchian_channel = {
                        numberOfIndicators: v,
                        settings: {}
                    }), a.donchian_channel.numberOfIndicators = v, a.donchian_channel.settings[h] = {
                        maxDeque: [],
                        minDeque: []
                    }, 
                    // allocate & fill NaNs
                    Object.assign(i, Object.fromEntries(b.map((function(t) {
                        return [ t, new Float64Array(u).fill(NaN) ];
                    })))), 
                    // apply lag if requested
                    s > 0 && t.lag(b, s), 
                    // mark price-based outputs
                    b.forEach((function(t) {
                        return c[t] = "Float64Array";
                    }));
                }
                // ---- PER-BAR COMPUTATION ----
                                var O = a.donchian_channel, A = O.numberOfIndicators, j = O.settings, N = A > 1 ? "donchian_channel_".concat(h) : "donchian_channel", P = j[h], T = P.maxDeque, x = P.minDeque, _ = r - n, E = _ - e + 1, k = [ "upper", "basis", "lower" ].map((function(t) {
                    return "".concat(N, "_").concat(t);
                }));
                f && k.push("".concat(N, "_height"));
                var C = y.map((function(t) {
                    return "".concat(N, "_range_").concat(t);
                }));
                // not enough data → push NaNs
                                if (E < 0 || _ + 1 > u) return [].concat(fe(k), fe(C)).forEach((function(e) {
                    return t.pushToMain({
                        index: r,
                        key: e,
                        value: NaN
                    });
                })), !0;
                var M = i.high, I = i.low, D = function(t, r, e) {
                    for (;t.length && t[0] < E; ) t.shift();
                    for (;t.length && e(r[t.at(-1)], r[_]); ) t.pop();
                    t.push(_);
                };
                // tiny helper to keep deques up-to-date
                                D(T, M, (function(t, r) {
                    return t <= r;
                })), D(x, I, (function(t, r) {
                    return t >= r;
                }));
                // single “bounds exist?” flag instead of repeated isNaN
                var R = T.length && x.length, F = R ? M[T[0]] : NaN, L = R ? I[x[0]] : NaN, z = R ? (F + L) / 2 : NaN;
                if (t.pushToMain({
                    index: r,
                    key: "".concat(N, "_upper"),
                    value: F
                }), t.pushToMain({
                    index: r,
                    key: "".concat(N, "_basis"),
                    value: z
                }), t.pushToMain({
                    index: r,
                    key: "".concat(N, "_lower"),
                    value: L
                }), f) {
                    // avoid divide-by-zero
                    var Y = R && L ? (F - L) / L : NaN;
                    t.pushToMain({
                        index: r,
                        key: "".concat(N, "_height"),
                        value: null === p ? Y : se(Y, p)
                    });
                }
                // precompute spread once
                                // for each extra range key, use price===price to skip NaNs
                for (var U = R ? F - L : NaN, G = 0; G < y.length; G++) {
                    var K = i[y[G]][r], V = R && K == K && U ? (K - L) / U : NaN;
                    t.pushToMain({
                        index: r,
                        key: C[G],
                        value: null === p ? V : se(V, p)
                    });
                }
                return !0;
            },
            bollingerBands: function(t, r, e, n, o) {
                var i, a, u, l, c, s, f = o.height, y = o.range, p = void 0 === y ? [] : y, h = o.target, v = o.lag, d = o.decimals, m = t.verticalOhlcv, b = t.instances, g = "".concat(e, "_").concat(n), w = "bollinger_bands";
                // Initialization on the first call.
                if (0 === r) {
                    var S = t.inputParams, O = t.verticalOhlcv, A = t.len, j = t.arrayTypes;
                    if (!(h in O)) throw new Error('bollingerBands could not find target "'.concat(h, '"'));
                    var N, P = 0, T = me(S);
                    try {
                        for (T.s(); !(N = T.n()).done; ) {
                            "bollingerBands" === N.value.key && P++;
                        }
                        // Only create the container if it doesn't already exist.
                                        } catch (t) {
                        T.e(t);
                    } finally {
                        T.f();
                    }
                    b.bollinger_bands || (b.bollinger_bands = {
                        numberOfIndicators: P,
                        settings: {}
                    }), 
                    // Add (or override) the indicator instance keyed by indicatorKey.
                    b.bollinger_bands.settings[g] = new nr(e, n);
                    var x = "";
                    P > 1 && (x += "_".concat(g)), h !== ge && (x += "_".concat(h));
                    var _ = [ "".concat(w, "_upper"), "".concat(w, "_middle"), "".concat(w, "_lower") ].map((function(t) {
                        return "".concat(t).concat(x);
                    }));
                    f && _.push("".concat(w, "_height").concat(x));
                    // Set up additional arrays for each range property.
                                        var E, k = me(p);
                    try {
                        for (k.s(); !(E = k.n()).done; ) {
                            var C = E.value;
                            if (!(C in O)) throw new Error('Invalid range item value "'.concat(C, '" property for bollingerBands.'));
                            _.push("".concat(w, "_range_").concat(C).concat(x));
                        }
                    } catch (t) {
                        k.e(t);
                    } finally {
                        k.f();
                    }
                    var M = Object.fromEntries(_.map((function(t) {
                        return [ t, new Float64Array(A).fill(NaN) ];
                    })));
                    Object.assign(O, function(t) {
                        for (var r = 1; r < arguments.length; r++) {
                            var e = null != arguments[r] ? arguments[r] : {};
                            r % 2 ? ve(Object(e), !0).forEach((function(r) {
                                de(t, r, e[r]);
                            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)) : ve(Object(e)).forEach((function(r) {
                                Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
                            }));
                        }
                        return t;
                    }({}, M)), v > 0 && t.lag(_, v);
                    var I, D = me(_);
                    try {
                        for (D.s(); !(I = D.n()).done; ) {
                            j[I.value] = "Float64Array";
                        }
                    } catch (t) {
                        D.e(t);
                    } finally {
                        D.f();
                    }
                }
                var R = "";
                b.bollinger_bands.numberOfIndicators > 1 && (R += "_".concat(g)), h !== ge && (R += "_".concat(h));
                // Update the indicator with the current value.
                var F = b.bollinger_bands.settings[g], L = m[h][r];
                F.update(L);
                // Attempt to retrieve the result.
                var z = {};
                try {
                    z = F.getResult();
                } catch (t) {
                    // If not available, result stays {}.
                }
                // Use NaN fallbacks for the primary values.
                                var Y = null !== (i = null === (a = z) || void 0 === a ? void 0 : a.upper) && void 0 !== i ? i : NaN, U = null !== (u = null === (l = z) || void 0 === l ? void 0 : l.middle) && void 0 !== u ? u : NaN, G = null !== (c = null === (s = z) || void 0 === s ? void 0 : s.lower) && void 0 !== c ? c : NaN;
                // Process height if requested.
                if (
                // Always push the indicator outputs.
                t.pushToMain({
                    index: r,
                    key: "".concat(w, "_upper").concat(R),
                    value: Y
                }), t.pushToMain({
                    index: r,
                    key: "".concat(w, "_middle").concat(R),
                    value: U
                }), t.pushToMain({
                    index: r,
                    key: "".concat(w, "_lower").concat(R),
                    value: G
                }), f) {
                    var K = NaN;
                    Number.isNaN(G) || Number.isNaN(Y) || (K = (Y - G) / G), t.pushToMain({
                        index: r,
                        key: "".concat(w, "_height").concat(R),
                        value: null === d ? K : se(K, d)
                    });
                }
                // Process each range property.
                                var V, $ = me(p);
                try {
                    for ($.s(); !(V = $.n()).done; ) {
                        var q = V.value, H = NaN, B = m[q][r];
                        Number.isNaN(B) || Number.isNaN(G) || Number.isNaN(Y) || (H = (B - G) / (Y - G)), 
                        t.pushToMain({
                            index: r,
                            key: "".concat(w, "_range_").concat(q).concat(R),
                            value: null === d ? H : se(H, d)
                        });
                    }
                } catch (t) {
                    $.e(t);
                } finally {
                    $.f();
                }
                return !0;
            },
            volumeOscillator: function(t, r, e, n, o) {
                var i = o.lag, a = t.verticalOhlcv, u = t.instances, l = a.volume[r], c = "volume_oscillator_".concat(e, "_").concat(n);
                if (0 === r) {
                    var s = t.len, f = t.arrayTypes;
                    Object.assign(u, Se({}, c, {
                        fastEMA: new vr(e),
                        slowEMA: new vr(n)
                    })), a[c] = new Float64Array(s).fill(NaN), i > 0 && t.lag([ c ], i), f[c] = "Float64Array";
                }
                var y = u[c], p = y.fastEMA, h = y.slowEMA;
                p.update(l), h.update(l);
                var v = NaN, d = NaN;
                try {
                    v = p.getResult();
                } catch (t) {}
                try {
                    d = h.getResult();
                } catch (t) {}
                var m = NaN;
                return Number.isNaN(v) || Number.isNaN(d) || (m = 100 * (v - d) / d), t.pushToMain({
                    index: r,
                    key: c,
                    value: m
                }), !0;
            },
            mapCols: function(t, r, e, n, o) {
                var i = o.lag, a = t.verticalOhlcv, u = t.len, l = t.arrayTypes;
                if (0 === r) {
                    var c, s = function(t, r) {
                        var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!e) {
                            if (Array.isArray(t) || (e = fn(t)) || r && t && "number" == typeof t.length) {
                                e && (t = e);
                                var n = 0, o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return n >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[n++]
                                        };
                                    },
                                    e: function(t) {
                                        throw t;
                                    },
                                    f: o
                                };
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }
                        var i, a = !0, u = !1;
                        return {
                            s: function() {
                                e = e.call(t);
                            },
                            n: function() {
                                var t = e.next();
                                return a = t.done, t;
                            },
                            e: function(t) {
                                u = !0, i = t;
                            },
                            f: function() {
                                try {
                                    a || null == e.return || e.return();
                                } finally {
                                    if (u) throw i;
                                }
                            }
                        };
                    }(e);
                    try {
                        for (s.s(); !(c = s.n()).done; ) {
                            var f = c.value;
                            if (a.hasOwnProperty(f)) throw new Error('New property "'.concat(f, '" already exist in "verticalOhlcv" and can not be modified using mapCols.'));
                            a[f] = new Array(u).fill(0), l[f] = "Array";
                        }
                    } catch (t) {
                        s.e(t);
                    } finally {
                        s.f();
                    }
                    i > 0 && t.lag(e, i);
                }
                var y = n({
                    index: r,
                    main: t
                });
                if (null == y) return !0;
                for (var p = 0, h = Object.entries(y); p < h.length; p++) {
                    var v = sn(h[p], 2), d = v[0], m = v[1];
                    t.pushToMain({
                        index: r,
                        key: d,
                        value: m
                    });
                }
            },
            scaler: function(t, r, e, n, o) {
                var i = o.type, a = o.group, u = o.range, l = o.lag, c = o.precomputed, s = (o.secondaryLoop, 
                c.groupKey), f = c.groupKeyLen, y = t.verticalOhlcv, p = t.instances, h = t.arrayTypes, v = (t.invalidValueIndex, 
                "".concat(i, "_").concat(e));
                if (0 === r) {
                    var d = t.len, m = t.isAlreadyComputed;
                    if (m.has(v)) throw new Error('In scaler method can not repeat params "size" and "options.type" together between indicators.');
                    m.add(v), p.hasOwnProperty("scaler") || (p.scaler = {}), p.scaler.hasOwnProperty(v) || (p.scaler[v] = {
                        windows: {}
                    });
                    var b, g = [], w = function(t, r) {
                        var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!e) {
                            if (Array.isArray(t) || (e = ln(t)) || r && t && "number" == typeof t.length) {
                                e && (t = e);
                                var n = 0, o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return n >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[n++]
                                        };
                                    },
                                    e: function(t) {
                                        throw t;
                                    },
                                    f: o
                                };
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }
                        var i, a = !0, u = !1;
                        return {
                            s: function() {
                                e = e.call(t);
                            },
                            n: function() {
                                var t = e.next();
                                return a = t.done, t;
                            },
                            e: function(t) {
                                u = !0, i = t;
                            },
                            f: function() {
                                try {
                                    a || null == e.return || e.return();
                                } finally {
                                    if (u) throw i;
                                }
                            }
                        };
                    }(n);
                    try {
                        var S = function() {
                            var r = b.value;
                            if (!y.hasOwnProperty(r)) throw new Error('Target property "'.concat(r, '" not found in verticalOhlcv'));
                            var e = "".concat(v, "_").concat(r);
                            y[e] = new Float64Array(d).fill(NaN), h[e] = "Float64Array";
                            var n = a ? s : r;
                            if (p.scaler[v].windows[n] = [], t.scaledGroups[s] || (t.scaledGroups[s] = []), 
                            t.scaledGroups[s].push(e), l > 0) {
                                var o, i = Array.from({
                                    length: l
                                }).map((function(t, r) {
                                    return "".concat(e, "_lag_").concat(r + 1);
                                }));
                                (o = t.scaledGroups[s]).push.apply(o, un(i)), g.push(e);
                            }
                        };
                        for (w.s(); !(b = w.n()).done; ) S();
                    } catch (t) {
                        w.e(t);
                    } finally {
                        w.f();
                    }
                    l > 0 && t.lag(g, l);
                }
                // update windows with current values
                for (var O = p.scaler[v].windows, A = !1, j = 0; j < n.length; j++) {
                    var N = n[j], P = y[N];
                    if (void 0 === P) {
                        A = !0;
                        break;
                    }
                    var T = P[r];
                    if (Number.isNaN(T) || null === T) {
                        A = !0;
                        break;
                    }
                    var x = O[a ? s : N];
                    x.push(T), x.length > (a ? e * f : e) && x.shift();
                }
                if (!A && r + 1 >= e) for (
                // scale values once enough data
                var _ = function() {
                    var e = n[E], o = y[e];
                    if (void 0 === o) return 0;
 // break
                                        var l = o[r];
                    if (Number.isNaN(l) || null === l) return 0;
 // break
                                        var c = "".concat(v, "_").concat(e), f = null, p = O[a ? s : e];
                    if ("minmax" === i) {
                        var h = Math.min.apply(Math, un(p)), d = Math.max.apply(Math, un(p));
                        f = $e(l, h, d, u);
                    } else {
                        if ("zscore" !== i) throw new Error('Unknown scaler type "'.concat(i, '"'));
                        var m = p.reduce((function(t, r) {
                            return t + r;
                        }), 0) / p.length, b = p.reduce((function(t, r) {
                            return t + Math.pow(r - m, 2);
                        }), 0) / p.length, g = Math.sqrt(b);
                        f = function(t, r, e) {
                            return 0 === e ? 0 : (t - r) / e;
                        }(l, m, g);
                    }
                    t.pushToMain({
                        index: r,
                        key: c,
                        value: f
                    });
                }, E = 0; E < n.length && 0 !== _(); E++) ;
            },
            crossPairs: function(t, r, e, n) {
                var o = n.limit, i = t.verticalOhlcv, a = t.verticalOhlcvTempCols, u = t.instances, l = t.len, c = t.arrayTypes, s = t.notNumberKeys;
                if (0 === r) {
                    var f, y = Ce(e);
                    try {
                        for (y.s(); !(f = y.n()).done; ) {
                            var p = f.value, h = p.fast, v = p.slow, d = "".concat(h, "_x_").concat(v);
                            // allow numeric 'slow' as a constant column
                            if ("number" == typeof v) {
                                var m = v.toString();
                                a.add(m), s.add(m), i[m] = new Int16Array(l).fill(v), c[m] = "Int16Array";
                            }
                            // sanity checks
                                                        if ("price" !== h && !i.hasOwnProperty(h)) throw new Error('crossPairs invalid param: fast "'.concat(h, '" not found in "verticalOhlcv": ').concat(JSON.stringify(Object.keys(i))));
                            if (!i.hasOwnProperty(v)) throw new Error('crossPairs invalid param: slow "'.concat(v, '" not found in "verticalOhlcv": ').concat(JSON.stringify(Object.keys(i))));
                            u.hasOwnProperty("crossPairs") || (u.crossPairs = {}), 
                            // create instance + output buffer
                            u.crossPairs[d] = {
                                run: new ze,
                                min: 1 / 0,
                                max: -1 / 0
                            }, i[d] = new Int32Array(l).fill(NaN), s.add(d), c[d] = "Int32Array";
                        }
                    } catch (t) {
                        y.e(t);
                    } finally {
                        y.f();
                    }
                }
                var b, g = Ce(e);
                try {
                    for (g.s(); !(b = g.n()).done; ) {
                        var w = b.value, S = w.fast, O = w.slow, A = "".concat(S, "_x_").concat(O), j = u.crossPairs[A].run;
                        // ——— Per-bar update ———
                        if ("price" === S) {
                            var N = i.close[r], P = i[O][r];
                            j.update(r, {
                                fast: N,
                                slow: P,
                                high: i.high[r],
                                low: i.low[r]
                            });
                        } else {
                            var T = i[S][r], x = i[O][r];
                            j.update(r, {
                                fast: T,
                                slow: x
                            });
                        }
                        var _ = j.getResult(), E = null === o ? _ : Math.max(-o, Math.min(o, _));
                        t.pushToMain({
                            index: r,
                            key: A,
                            value: E
                        });
                    }
                } catch (t) {
                    g.e(t);
                } finally {
                    g.f();
                }
                return !0;
            },
            lag: function(t, r, e, n) {
                var o = t.verticalOhlcv, i = t.len, a = t.arrayTypes;
                if (0 === r) {
                    var u, l = Ee(e);
                    try {
                        for (l.s(); !(u = l.n()).done; ) {
                            var c = u.value;
                            if (!a.hasOwnProperty(c)) throw new Error('Lag processing invoked by "'.concat(c, '" expected arrayTypes to have a "').concat(c, '" property, but it wasn’t found.'));
                            for (var s = 1; s <= n; s++) {
                                var f = "".concat(c, "_lag_").concat(s);
                                o[f] = _e(a[c], i), a[f] = a[c];
                            }
                        }
                    } catch (t) {
                        l.e(t);
                    } finally {
                        l.f();
                    }
                }
                var y, p = Ee(e);
                try {
                    for (p.s(); !(y = p.n()).done; ) 
                    // Populate the lagged values each tick:
                    for (var h = y.value, v = o[h], d = 1; d <= n; d++) {
                        var m = "".concat(h, "_lag_").concat(d), b = r - d, g = b < 0 || void 0 === v[b] ? null : v[b];
                        t.pushToMain({
                            index: r,
                            key: m,
                            value: g
                        });
                    }
                } catch (t) {
                    p.e(t);
                } finally {
                    p.f();
                }
                return !0;
            }
        }, $n = function(t) {
            for (var r = t.inputParams, e = t.len, n = t.invalidValueIndex + 1; n < e; n++) {
                var o, i = Yn(r);
                try {
                    for (i.s(); !(o = i.n()).done; ) for (var a = o.value, u = a.key, l = a.params, c = a.order, s = 10; s <= 20; s++) {
                        if ("number" != typeof c) throw new Error("order property of ".concat(u, " not found: ").concat(l));
                        s === c && ("pca" === u && Sn.apply(void 0, [ t, n ].concat(zn(l))), "classifier" === u && Ln.apply(void 0, [ t, n ].concat(zn(l))), 
                        "regressor" === u && Cn.apply(void 0, [ t, n ].concat(zn(l))));
                    }
                } catch (t) {
                    i.e(t);
                } finally {
                    i.f();
                }
            }
        }, qn = function(t, r) {
            for (var e = t.length, n = new pt(r), o = new Array(e), i = 0, a = 0, u = 0, l = 0; l < e; l++) if (n.update(t[l]), 
            n.isStable) {
                var c = n.getResult();
                o[l] = c, i += c, a += c * c, u++;
            } else o[l] = null;
            var s = i / u, f = a / u - s * s, y = Math.sqrt(f);
            return o.map((function(t) {
                return null !== t ? (t - s) / y : null;
            }));
        }, Hn = function(t, r) {
            var e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5;
            if (t.length !== r.length) throw new Error("Both arrays must have the same length");
            for (var n = qn(t, e), o = qn(r, e), i = t.length, a = [], u = 0, l = 0, c = 0, s = 0, f = 0, y = 0, p = -1, h = 0; h < i; h++) {
                if (null !== n[h] && null !== o[h]) {
                    p = h;
                    break;
                }
                a.push(0);
            }
            if (-1 === p) 
            // No valid data points
            return new Array(i).fill(0);
            for (var v = p; v < i; v++) {
                var d = n[v], m = o[v];
                if (null !== d && null !== m) if (u += d, l += m, c += d * m, s += d * d, f += m * m, 
                ++y < 2) a.push(0); else {
                    var b = y * c - u * l, g = Math.sqrt((y * s - u * u) * (y * f - l * l)), w = 0 === g ? 0 : b / g;
                    a.push(w);
                } else 
                // Reset sums and counts when encountering null values
                u = l = c = s = f = y = 0, a.push(0);
            }
            return a;
        };
        // ./src/utilities/verticalToHorizontal.js
        function Bn(t, r) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, r) {
                var e = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != e) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (e = e.call(t)).next, 0 === r) {
                            if (Object(e) !== e) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(e)).done) && (u.push(n.value), u.length !== r); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != e.return && (a = e.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, r) || function(t, r) {
                if (t) {
                    if ("string" == typeof t) return Jn(t, r);
                    var e = {}.toString.call(t).slice(8, -1);
                    return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? Jn(t, r) : void 0;
                }
            }(t, r) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Jn(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var Xn = function(t) {
            var r = t.main, e = t.skipNull, n = void 0 !== e && e, o = t.startIndex, i = void 0 === o ? 0 : o, a = t.dateFormat, u = r.precisionMultiplier, l = r.precision, c = r.verticalOhlcv, s = r.invalidValueIndex, f = r.len, y = r.verticalOhlcvKeyNames, p = r.verticalOhlcvTempCols, h = r.notNumberKeys;
            if (0 === y.length) return [];
            for (var v = n && s >= 0 ? s + 1 : 0, d = Math.max(v, i), m = f - d, b = Array.from({
                length: m
            }, (function() {
                return {};
            })), g = 0, w = Object.entries(c); g < w.length; g++) {
                var S = Bn(w[g], 2), O = S[0], A = S[1];
                if (!p.has(O)) for (var j = l && !h.has(O), N = d; N < f; N++) b[N - d][O] = j ? A[N] / u : "date" === O ? Ae[a](A[N]) : A[N];
            }
            return b;
        };
        // ./src/utilities/precisionMultiplier.js
        function Wn(t, r) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, r) {
                var e = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != e) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (e = e.call(t)).next, 0 === r) {
                            if (Object(e) !== e) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(e)).done) && (u.push(n.value), u.length !== r); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != e.return && (a = e.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, r) || function(t, r) {
                if (t) {
                    if ("string" == typeof t) return Zn(t, r);
                    var e = {}.toString.call(t).slice(8, -1);
                    return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? Zn(t, r) : void 0;
                }
            }(t, r) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Zn(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var Qn = function(t, r) {
            if (c(t, "arr", "getOrderFromArray"), v(r, "methodName", "getOrderFromArray"), t.every((function(t) {
                return [ "open", "high", "low", "close", "volume", "date" ].includes(t);
            }))) return 0;
            for (var e = 1, n = function() {
                var r = i[o];
                t.some((function(t) {
                    return t.includes(r);
                })) && e++;
            }, o = 0, i = [ "_x_", "zscore_", "minmax_", "lag_" ]; o < i.length; o++) n();
            if (![ "regressor", "classifier", "pca" ].includes(r)) return e;
            e = 10;
            for (var a = function() {
                var r = l[u];
                t.some((function(t) {
                    return t.includes(r);
                })) && e++;
            }, u = 0, l = [ "prediction_", "reg_", "cla_", "pca_" ]; u < l.length; u++) a();
            return e;
        };
        // ./src/machine-learning/ml-config.js
        function to(t, r) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, r) {
                var e = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != e) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (e = e.call(t)).next, 0 === r) {
                            if (Object(e) !== e) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(e)).done) && (u.push(n.value), u.length !== r); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != e.return && (a = e.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, r) || ro(t, r) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function ro(t, r) {
            if (t) {
                if ("string" == typeof t) return eo(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? eo(t, r) : void 0;
            }
        }
        function eo(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        var no = function(t, r, e) {
            //this function will be executed inside a secondary loop after most of the indicates are calculated
            //use the "verticalOhlcv" object to access desired indicators
            if (2 !== e) throw new Error('The default "yCallback" function in this classifier requires that "options.horizon" and "options.predictions" are set to "2".');
            var n = r.close[t], o = Array.from({
                length: e
            }, (function(e, n) {
                return r.close[n + 1 + t];
            }));
            if (o.some((function(t) {
                return void 0 === t;
            }))) return null;
            var i = o[0], a = o[1];
            //the total length of item is this output must be equal to "options.yColumns" property
                        return [ Number(i > n), Number(a > i) ];
        }, oo = function(t) {
            var r, e = t.ML, n = t.inputParams, o = e.models, i = {}, a = function(t, r) {
                var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (!e) {
                    if (Array.isArray(t) || (e = ro(t)) || r && t && "number" == typeof t.length) {
                        e && (t = e);
                        var n = 0, o = function() {};
                        return {
                            s: o,
                            n: function() {
                                return n >= t.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t[n++]
                                };
                            },
                            e: function(t) {
                                throw t;
                            },
                            f: o
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var i, a = !0, u = !1;
                return {
                    s: function() {
                        e = e.call(t);
                    },
                    n: function() {
                        var t = e.next();
                        return a = t.done, t;
                    },
                    e: function(t) {
                        u = !0, i = t;
                    },
                    f: function() {
                        try {
                            a || null == e.return || e.return();
                        } finally {
                            if (u) throw i;
                        }
                    }
                };
            }(n);
            try {
                for (a.s(); !(r = a.n()).done; ) {
                    var u = r.value, l = u.key, c = u.params;
                    if ("classifier" === l || "regressor" === l) {
                        var s = to(c, 2), f = (s[0], s[1]), y = f.type, p = f.predictions, h = f.precompute, v = h.flatY, d = h.prefix, m = v ? p : 1, b = void 0;
                        "regressor" === l ? b = ao[y].exportModel : "classifier" === l && (b = io[y].exportModel);
                        for (var g = 0; g < m; g++) {
                            var w = "".concat(d, "_").concat(g + 1);
                            i[w] = b(o[w]);
                        }
                    }
                }
            } catch (t) {
                a.e(t);
            } finally {
                a.f();
            }
            return i;
        }, io = {
            KNN: {
                shortName: "knn",
                flatY: !0,
                useTrainMethod: !1,
                exportModel: function(t) {
                    return t.toJSON();
                }
            },
            FeedForwardNeuralNetworks: {
                shortName: "feed_forward",
                flatY: !1,
                useTrainMethod: !0,
                exportModel: function(t) {
                    return t.toJSON();
                }
            },
            GaussianNB: {
                shortName: "naive_bayes",
                flatY: !0,
                useTrainMethod: !0,
                exportModel: function(t) {
                    return t.toJSON();
                }
            },
            MultinomialNB: {
                shortName: "naive_bayes",
                flatY: !0,
                useTrainMethod: !0,
                exportModel: function(t) {
                    return t.toJSON();
                }
            },
            DecisionTreeClassifier: {
                shortName: "decision_tree",
                flatY: !0,
                useTrainMethod: !0,
                exportModel: function(t) {
                    return t.toJSON();
                }
            },
            RandomForestClassifier: {
                shortName: "random_forest",
                flatY: !0,
                useTrainMethod: !0,
                exportModel: function(t) {
                    return t.toJSON();
                }
            },
            RandomForestClassifierWasm: {
                shortName: "random_forest",
                flatY: !0,
                useTrainMethod: !0,
                exportModel: function(t) {
                    return t.save();
                }
            }
        }, ao = {
            SimpleLinearRegression: {
                shortName: "linear",
                flatX: !0,
                flatY: !0,
                useTrainMethod: !1,
                exportModel: function(t) {
                    return t.toJSON();
                }
            },
            PolynomialRegression: {
                shortName: "polynomial",
                flatX: !0,
                flatY: !0,
                useTrainMethod: !1,
                exportModel: function(t) {
                    return t.toJSON();
                }
            },
            MultivariateLinearRegression: {
                shortName: "multivariable",
                flatX: !1,
                flatY: !1,
                useTrainMethod: !1,
                exportModel: function(t) {
                    return t.toJSON();
                }
            },
            DecisionTreeRegression: {
                shortName: "decision_tree",
                flatX: !1,
                flatY: !0,
                useTrainMethod: !0,
                exportModel: function(t) {
                    return t.toJSON();
                }
            },
            RandomForestRegression: {
                shortName: "random_forest",
                flatX: !1,
                flatY: !0,
                useTrainMethod: !0,
                exportModel: function(t) {
                    return t.toJSON();
                }
            },
            FeedForwardNeuralNetworks: {
                shortName: "feed_forward",
                flatX: !1,
                flatY: !1,
                useTrainMethod: !0,
                exportModel: function(t) {
                    return t.toJSON();
                }
            }
        };
        // ./index.js
        function uo(t, r) {
            var e = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                r && (n = n.filter((function(r) {
                    return Object.getOwnPropertyDescriptor(t, r).enumerable;
                }))), e.push.apply(e, n);
            }
            return e;
        }
        function lo(t) {
            return lo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, lo(t);
        }
        function co(t, r, e) {
            return (r = mo(r)) in t ? Object.defineProperty(t, r, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[r] = e, t;
        }
        function so(t, r) {
            var e = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!e) {
                if (Array.isArray(t) || (e = po(t)) || r && t && "number" == typeof t.length) {
                    e && (t = e);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    e = e.call(t);
                },
                n: function() {
                    var t = e.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == e.return || e.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function fo(t, r) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, r) {
                var e = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != e) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (e = e.call(t)).next, 0 === r) {
                            if (Object(e) !== e) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(e)).done) && (u.push(n.value), u.length !== r); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != e.return && (a = e.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, r) || po(t, r) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function yo(t) {
            return function(t) {
                if (Array.isArray(t)) return ho(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || po(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function po(t, r) {
            if (t) {
                if ("string" == typeof t) return ho(t, r);
                var e = {}.toString.call(t).slice(8, -1);
                return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? ho(t, r) : void 0;
            }
        }
        function ho(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var e = 0, n = Array(r); e < r; e++) n[e] = t[e];
            return n;
        }
        function vo(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, mo(n.key), n);
            }
        }
        function mo(t) {
            var r = function(t, r) {
                if ("object" != lo(t) || !t) return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var n = e.call(t, r || "default");
                    if ("object" != lo(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }
            /**
 * Class OHLCV_INDICATORS
 *
 * This class provides methods for calculating and managing technical indicators 
 * on financial OHLCV (Open, High, Low, Close, Volume) data. It enables users 
 * to parallel compute various technical indicators in 1 single loop for standard indicators and a second loop for ML regressors and classifier.
 * OHLCV datasets.
 */ (t, "string");
            return "symbol" == lo(r) ? r : r + "";
        }
        var bo =  function() {
            return t = function t(r) {
                var e = this, n = r.input, o = r.ticker, i = void 0 === o ? null : o, a = r.precision, l = void 0 === a || a, f = r.inputParams, h = void 0 === f ? null : f, v = r.chunkProcess, d = void 0 === v ? 2e3 : v, m = r.ML, b = void 0 === m ? {} : m;
                if (function(t, r) {
                    if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
                }(this, t), c(n, "input", null !== i ? "contructor ".concat(i) : "constuctor"), 
                0 === n.length) throw Error("input OHLCV must not be empty: " + i);
                y(l, "precision", "constructor"), p(d, {
                    min: 100,
                    max: 5e4,
                    allowDecimals: !1
                }, "chunkProcess", "constructor"), s(b, "ML", "constructor"), this.notNumberKeys = new Set, 
                this.chunkProcess = d, this.input = yo(n), this.len = this.input.length, this.firstRow = this.input[0];
                var g = function(t) {
                    for (var r = t.firstRow, e = t.notNumberKeys, n = {}, o = {}, i = 0, a = Object.entries(r); i < a.length; i++) {
                        var u = Pe(a[i], 2), l = u[0], c = u[1];
                        if ("date" === l) n[l] = Ne(c), o[l] = "Array", e.add(l); else if ("volume" === l) n[l] = ce(c, !0), 
                        o[l] = "Int32Array", e.add(l); else if (xe.has(l)) n[l] = ce(c, !0), o[l] = "Float64Array"; else {
                            var s = ce(c, !1);
                            n[l] = s, o[l] = "number" === s ? "Float64Array" : "Array", s.startsWith("number") || e.add(l);
                        }
                    }
                    return {
                        inputTypes: n,
                        arrayTypes: o
                    };
                }(this), w = g.inputTypes, S = g.arrayTypes;
                if (this.inputTypes = w, this.arrayTypes = S, !this.firstRow.hasOwnProperty("close")) throw Error('input OHLCV array objects require at least "close" property: '.concat(i));
                this.dateType = this.inputTypes.date ? this.inputTypes.date : null, this.isComputed = !1, 
                this.instances = {}, this.verticalOhlcv = {}, this.verticalOhlcvKeyNames = [], this.verticalOhlcvTempCols = new Set, 
                this.utilities = {
                    correlation: Hn
                }, this.invalidValueIndex = -1, this.precision = l, this.precisionMultiplier = function(t, r) {
                    if (!1 === t.precision) return 1;
                    for (var e = 1, n = 0, o = Object.entries(r); n < o.length; n++) {
                        var i = Wn(o[n], 2), a = i[0], u = i[1];
                        if (!1 !== new Set([ "open", "high", "low", "close" ]).has(a)) {
                            var l = Wn(String(u).split("."), 2)[1], c = void 0 === l ? "" : l, s = Math.max(4, c.length), f = s > 1 ? Math.pow(10, s - 1) : 1;
                            f > e && (e = f);
                        }
                    }
                    return e;
                }(this, this.firstRow), this.scaledGroups = {}, this.isAlreadyComputed = new Set;
                var O = b.classes;
                return void 0 !== O && s(O, "ML.classes", "constructor"), this.ML = {
                    models: {},
                    classes: O,
                    metrics: {},
                    featureCols: {}
                }, this.processSecondaryLoop = !1, this.pushToMain = function(t) {
                    var r = t.index, n = t.key, o = t.value;
                    return function(t) {
                        var r = t.main, e = t.index, n = t.key, o = t.value;
                        return r.verticalOhlcv[n][e] = o, !0;
                    }({
                        main: e,
                        index: r,
                        key: n,
                        value: o
                    });
                }, null !== h ? (u(h, this.len), this.inputParams = h, this.compute()) : this.inputParams = [], 
                this;
            }, r = [ {
                key: "getDataAsCols",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    this.compute();
                    var r = t.skipNull, e = void 0 === r || r, n = t.dateFormat, o = void 0 === n ? "string" : n;
                    f(Object.keys(Ae), o, "dateFormat", "getDataAsCols"), s(t, "options", "getDataAsCols");
                    for (var i = this.precisionMultiplier, a = this.precision, u = this.len, l = this.invalidValueIndex, c = this.verticalOhlcv, y = this.arrayTypes, p = this.verticalOhlcvTempCols, h = this.notNumberKeys, v = {}, d = e ? l + 1 : 0, m = u - d, b = 0, g = Object.entries(c); b < g.length; b++) {
                        var w = fo(g[b], 2), S = w[0], O = w[1];
                        if (!p.has(S)) {
                            var A = a && !h.has(S);
                            v[S] = _e(y[S], m);
                            for (var j = d; j < u; j++) v[S][j] = A ? O[j] / i : "date" === S ? Ae[o](O[j]) : O[j];
                        }
                    }
                    return v;
                }
            }, {
                key: "getData",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    //getData method returns the last object (row) of the new OHLCV with indicators: {open, high, low, close, rsi_14, bollinger_bands_upper}
                                        this.compute();
                    var r = t.skipNull, e = void 0 === r || r, n = t.dateFormat, o = void 0 === n ? "string" : n;
                    return f(Object.keys(Ae), o, "dateFormat", "getData"), s(t, "options", "getData"), 
                    Xn({
                        main: this,
                        skipNull: e,
                        startIndex: 0,
                        dateFormat: o
                    });
                }
            }, {
                key: "getLastValues",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    this.compute();
                    var r = t.dateFormat, e = void 0 === r ? "string" : r;
                    return f(Object.keys(Ae), e, "dateFormat", "getData"), Xn({
                        skipNull: !1,
                        main: this,
                        startIndex: this.len - 1,
                        dateFormat: e
                    })[0];
                }
            }, {
                key: "compute",
                value: function() {
                    // If we've already computed, bail out immediately
                    return this.isComputed || (
                    // Mark as “in progress”
                    this.isComputed = !1, 
                    // Figure out whether there’s a date field in the inputs
                    // Only run the full loop once (or when new data appears later,
                    // if you extend this to reset isComputed elsewhere)
                    this.len > 0 && (function(t, r) {
                        var n = r.len, o = r.inputParams, i = r.precisionMultiplier, a = r.arrayTypes, l = r.verticalOhlcv, c = r.verticalOhlcvKeyNames, s = r.inputTypes, f = r.chunkProcess, y = r.notNumberKeys, p = r.processSecondaryLoop;
                        u(o, n);
                        for (var h = 0, v = Object.keys(s); h < v.length; h++) {
                            var d = v[h];
                            l[d] = _e(a[d], n);
                        }
                        // Process each row in the input
                                                for (var m = 0; m < n; m += f) for (var b = Math.min(m + f, n), g = m; g < b; g++) {
                            for (var w = t[g], S = 0, O = Object.entries(s); S < O.length; S++) {
                                var A = Un(O[S], 2), j = A[0], N = A[1], P = w[j];
                                if (le.hasOwnProperty(N)) {
                                    var T = le[N](P);
                                    i > 1 && !y.has(j) && (T *= i), r.pushToMain({
                                        index: g,
                                        key: j,
                                        value: T
                                    });
                                } else je.hasOwnProperty(N) ? r.pushToMain({
                                    index: g,
                                    key: j,
                                    value: je[N](P)
                                }) : r.pushToMain({
                                    index: g,
                                    key: j,
                                    value: P
                                });
                            }
                            // Process these indicators separately (ensuring their execution order)
                                                        var x, _ = Yn(o);
                            try {
                                for (_.s(); !(x = _.n()).done; ) for (var E = x.value, k = E.key, C = E.params, M = E.order, I = 0; I <= 9; I++) {
                                    if ("number" != typeof M) throw new Error("order property of ".concat(k, " not found: ").concat(C));
                                    I === M && Vn[k].apply(Vn, [ r, g ].concat(zn(C)));
                                }
                            } catch (t) {
                                _.e(t);
                            } finally {
                                _.f();
                            }
                            t[g] = null;
                            //flusing data
                            var D = Object.keys(l);
                            // if any value at this index is missing/NaN/null, mark it invalid
                                                        e(r, g, D) || (r.invalidValueIndex = g);
                        }
                        (o.some((function(t) {
                            var r = t.key;
                            return "regressor" === r || "classifier" === r || "pca" === r;
                        })) || p) && $n(r), c.push.apply(c, zn(Object.keys(l)));
                    }(this.input, this), this.isComputed = !0, 
                    //flushing after mainLoop
                    this.input = [], this.instances = {}, this.firstRow = [])), this;
                }
            }, {
                key: "crossPairs",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, e = "crossPairs";
                    l(this), c(t, "arr", e), s(r, "options", e);
                    var n = r.limit, o = void 0 === n ? null : n;
                    null !== o && p(o, {}, "options.limit", e);
                    var i, a = [], u = so(t);
                    try {
                        for (u.s(); !(i = u.n()).done; ) {
                            var f = i.value, y = f.fast, h = void 0 === y ? "" : y, v = f.slow, d = void 0 === v ? "" : v;
                            if ("" === h || "" === d) throw new Error("Invalid crossPairs[".concat(h, "_").concat(d, "]: Object property “fast” must be a non-null column name and “slow” must be a non-null column name or integer."));
                            a.push(h.toString(), d.toString());
                        }
                    } catch (t) {
                        u.e(t);
                    } finally {
                        u.f();
                    }
                    if (this.isAlreadyComputed.has(e)) throw new Error('You can only call the "'.concat(e, '" method once.'));
                    this.isAlreadyComputed.add(e);
                    var m = Qn(a, e);
                    return this.inputParams.push({
                        key: e,
                        order: m,
                        params: [ t, {
                            limit: o
                        } ]
                    }), this;
                }
            }, {
                key: "lag",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [ "close" ], r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, e = "lag";
                    l(this), c(t, "colKeys", e), p(r, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "lookback", e);
                    var n = Qn(t, e);
                    return this.inputParams.push({
                        key: e,
                        order: n,
                        params: [ t, r ]
                    }), this;
                }
            }, {
                key: "relativeVolume",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, e = "relativeVolume";
                    if (!this.inputTypes.hasOwnProperty("volume")) throw new Error('If "relativeVolume" is called the input ohlcv must contain valid volume properties.');
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", e), s(r, "options", e);
                    var n = r.lag, o = void 0 === n ? 0 : n;
                    return p(o, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", e), this.inputParams.push({
                        key: e,
                        order: 0,
                        params: [ t, {
                            lag: o
                        } ]
                    }), this;
                }
            }, {
                key: "atr",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 14, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, e = "atr";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", e), s(r, "options", e);
                    var n = r.lag, o = void 0 === n ? 0 : n, i = r.percentage, a = void 0 !== i && i, u = r.upper, c = void 0 === u ? null : u, f = r.lower, h = void 0 === f ? null : f;
                    return p(o, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", e), y(a, "options.percentage", "atr"), null !== c && p(c, {
                        min: .001,
                        max: 100,
                        allowDecimals: !0
                    }, "options.upper", "atr"), null !== h && p(h, {
                        min: .001,
                        max: 100,
                        allowDecimals: !0
                    }, "options.lower", "atr"), this.inputParams.push({
                        key: e,
                        order: 0,
                        params: [ t, {
                            lag: o,
                            percentage: a,
                            upper: c,
                            lower: h
                        } ]
                    }), this;
                }
            }, {
                key: "ema",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, e = "ema";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", e), s(r, "options", e);
                    var n = r.target, o = void 0 === n ? "close" : n, i = r.lag, a = void 0 === i ? 0 : i;
                    v(o, "options.target", e), p(a, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", e);
                    var u = Qn([ o ], e);
                    return this.inputParams.push({
                        key: e,
                        order: u,
                        params: [ e, t, {
                            target: o,
                            lag: a
                        } ]
                    }), this;
                }
            }, {
                key: "sma",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, e = "sma";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", e), s(r, "options", e);
                    var n = r.target, o = void 0 === n ? "close" : n, i = r.lag, a = void 0 === i ? 0 : i;
                    v(o, "options.target", e), p(a, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", e);
                    var u = Qn([ o ], e);
                    return this.inputParams.push({
                        key: e,
                        order: u,
                        params: [ e, t, {
                            target: o,
                            lag: a
                        } ]
                    }), this;
                }
            }, {
                key: "stochastic",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 14, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3, e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3, n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, o = "stochastic", i = this.len;
                    p(t, {
                        min: 1,
                        max: i,
                        allowDecimals: !1
                    }, "kPeriod", o), p(r, {
                        min: 1,
                        max: i,
                        allowDecimals: !1
                    }, "kSlowingPeriod", o), p(e, {
                        min: 1,
                        max: i,
                        allowDecimals: !1
                    }, "dPeriod", o), s(n, "options", o);
                    var a = function(t) {
                        return t;
                    }, u = "", l = n.lag, c = void 0 === l ? 0 : l;
                    p(c, {
                        min: 0,
                        max: i,
                        allowDecimals: !1
                    }, "options.lag", o);
                    var f = n.minmax;
                    return (Array.isArray(f) || "boolean" == typeof f && !0 === f) && (Array.isArray(f) ? (h(f, "options.minmax", o), 
                    a = function(t) {
                        return null !== f ? $e(t, 0, 100, f) : t;
                    }) : (y(f, "options.minmax", o), f = [ 0, 1 ], a = function(t) {
                        return null !== f ? $e(t, 0, 100, f) : t;
                    }), u = "minmax_"), this.inputParams.push({
                        key: o,
                        order: 0,
                        params: [ t, r, e, {
                            minmax: f,
                            prefix: u,
                            parser: a,
                            lag: c
                        } ]
                    }), this;
                }
            }, {
                key: "macd",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 12, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 26, e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 9, n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, o = "macd";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "fast", o), p(r, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "slow", o), p(e, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "signal", o), s(n, "options", o);
                    var i = n.target, a = void 0 === i ? "close" : i, u = n.lag, c = void 0 === u ? 0 : u;
                    v(a, "options.target", o), p(c, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", o);
                    var f = {
                        instanceKey: "".concat(t, "_").concat(r, "_").concat(e).concat("close" === a ? "" : "_".concat(a))
                    }, y = Qn([ a ], o);
                    return this.inputParams.push({
                        key: o,
                        order: y,
                        params: [ t, r, e, {
                            target: a,
                            lag: c,
                            precomputed: f
                        } ]
                    }), this;
                }
            }, {
                key: "bollingerBands",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 20, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2, e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = "bollingerBands";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", n), p(r, {
                        min: .01,
                        max: 50,
                        allowDecimals: !0
                    }, "stdDev", n), s(e, "options", n);
                    var o = e.target, i = void 0 === o ? "close" : o, a = e.height, u = void 0 !== a && a, f = e.range, h = void 0 === f ? [] : f, d = e.lag, m = void 0 === d ? 0 : d, b = e.decimals, g = void 0 === b ? null : b;
                    v(i, "options.target", n), c(h, "options.range", n), p(m, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", n), y(u, "options.height", n), null !== g && p(g, {
                        min: 1,
                        max: 15,
                        allowDecimals: !1
                    }, "decimals", n);
                    var w = Qn([ i ], n);
                    return this.inputParams.push({
                        key: n,
                        order: w,
                        params: [ t, r, {
                            target: i,
                            height: u,
                            range: h,
                            lag: m,
                            decimals: g
                        } ]
                    }), this;
                }
            }, {
                key: "rsi",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 14, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, e = "rsi";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", e), s(r, "options", e);
                    var n = r.target, o = void 0 === n ? "close" : n, i = r.lag, a = void 0 === i ? 0 : i, u = r.minmax;
                    v(o, "options.target", e), p(a, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", e);
                    var c = function(t) {
                        return t;
                    }, f = "";
                    (Array.isArray(u) || "boolean" == typeof u && !0 === u) && (Array.isArray(u) ? (h(u, "options.minmax", e), 
                    c = function(t) {
                        return null !== u ? $e(t, 0, 100, u) : t;
                    }) : (y(u, "options.minmax", e), u = [ 0, 1 ], c = function(t) {
                        return null !== u ? $e(t, 0, 100, u) : t;
                    }), f = "minmax_");
                    var d = Qn([ o ], e);
                    return this.inputParams.push({
                        key: e,
                        order: d,
                        params: [ t, {
                            target: o,
                            lag: a,
                            parser: c,
                            prefix: f,
                            minmax: u
                        } ]
                    }), this;
                }
            }, {
                key: "donchianChannels",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 20, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = "donchianChannels";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", n), p(r, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "offset", n), s(e, "options", n);
                    var o = e.height, i = void 0 !== o && o, a = e.range, u = void 0 === a ? [] : a, f = e.lag, h = void 0 === f ? 0 : f, v = e.decimals, d = void 0 === v ? null : v;
                    return c(u, "options.range", n), p(h, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", n), y(i, "options.height", n), null !== d && p(d, {
                        min: 1,
                        max: 15,
                        allowDecimals: !1
                    }, "decimals", n), this.inputParams.push({
                        key: n,
                        order: 0,
                        params: [ t, r, {
                            height: i,
                            range: u,
                            lag: h,
                            decimals: d
                        } ]
                    }), this;
                }
            }, {
                key: "volumeOscillator",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10, e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = "volumeOscillator";
                    if (!this.inputTypes.hasOwnProperty("volume")) throw new Error('If "volumeOscillator" is called the input ohlcv must contain valid volume properties.');
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "fastsize", n), p(r, {
                        min: t,
                        max: this.len,
                        allowDecimals: !1
                    }, "slowsize", n), s(e, "options", n);
                    var o = e.lag, i = void 0 === o ? 0 : o;
                    return p(i, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", n), this.inputParams.push({
                        key: n,
                        order: 0,
                        params: [ t, r, {
                            lag: i
                        } ]
                    }), this;
                }
            }, {
                key: "dateTime",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r = "dateTime";
                    l(this), s(t, "options", r);
                    var e = t.lag, n = void 0 === e ? 0 : e, o = t.oneHot, i = void 0 !== o && o;
                    p(n, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", r), y(i, "options.oneHot", r);
                    var a = i ? "one_hot_" : "", u = co(co(co(co(co({}, "".concat(a, "month"), 12), "".concat(a, "day_of_the_month"), 31), "".concat(a, "day_of_the_week"), 7), "".concat(a, "hour"), 24), "".concat(a, "minute"), 60), c = {
                        prefix: a,
                        colKeySizes: u,
                        colKeys: Object.keys(u)
                    };
                    return this.inputParams.push({
                        key: r,
                        order: 0,
                        params: [ {
                            lag: n,
                            oneHot: i,
                            precompute: c
                        } ]
                    }), this;
                }
            }, {
                key: "scaler",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "zscore", r = arguments.length > 1 ? arguments[1] : void 0, e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = "scaler";
                    l(this), p(r, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", n), s(e, "options", n);
                    var o = e.group, i = void 0 !== o && o, a = e.range, u = void 0 === a ? [ 0, 1 ] : a, v = e.lag, d = void 0 === v ? 0 : v, m = e.colKeys, b = void 0 === m ? [] : m;
                    c(b, "options.colKeys", n), y(i, "options.group", n), h(u, "options.range", n), 
                    f([ "minmax", "zscore" ], t, "options.type", n);
                    var g = {
                        groupKey: "".concat(t, "_").concat(r),
                        groupKeyLen: b.length
                    }, w = !1, S = Qn(b, n);
                    return S >= 10 && (w = !0), this.inputParams.push({
                        key: n,
                        order: S,
                        params: [ r, b, {
                            type: t,
                            group: i,
                            range: u,
                            lag: d,
                            precomputed: g,
                            secondaryLoop: w
                        } ]
                    }), this;
                }
            }, {
                key: "classifier",
                value: function() {
                    var t, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 200, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    l(this);
                    var n = "classifier";
                    p(r, {
                        max: this.len,
                        allowDecimals: !1
                    }, "trainingSize", n), s(e, "options", n);
                    var o = e.retrain, i = void 0 !== o && o, a = e.trainingCols, u = void 0 === a ? [] : a, h = e.type, v = void 0 === h ? "KNN" : h, d = e.lookback, m = void 0 === d ? 0 : d, b = e.findGroups, g = void 0 === b ? [] : b, w = e.predictions, S = void 0 === w ? 2 : w, O = e.horizon, A = void 0 === O ? 2 : O, j = e.modelArgs, N = void 0 === j ? void 0 : j;
                    if (void 0 !== N && ("object" !== lo(N) || null === N || Array.isArray(N))) throw new TypeError('"modelArgs" must be either undefined or a plain object in '.concat(v));
                    var P = null !== (t = e.yCallback) && void 0 !== t ? t : no;
                    if ("function" != typeof P) throw new Error('"yCallback" must be a function in the following format:\n\n---\n\nconst yCallback = '.concat(no.toString(), "\n\n---\n\n"));
                    if (f(Object.keys(io), v, "options.type", n), !this.ML.classes.hasOwnProperty(v)) throw new Error('"'.concat(v, '" isn’t available because its library wasn’t imported into OHLCV_INDICATORS.ML.'));
                    y(i, "options.retrain", n), c(u, "options.trainingCols", n), p(A, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.horizon", n), p(m, {
                        max: 0,
                        allowDecimals: !1
                    }, "options.lookback", n), p(S, {
                        min: 1,
                        allowDecimals: !1
                    }, "options.predictions", n);
                    var T = yo(u);
                    if (c(g, "options.findGroups", "scaler") && g.length > 0) {
                        var x, _ = so(g);
                        try {
                            for (_.s(); !(x = _.n()).done; ) {
                                var E = x.value, k = E.type, C = void 0 === k ? "" : k, M = E.size, I = E.groupName, D = void 0 === I ? "" : I;
                                if (!C || !M && !D || M && D) throw new Error('If "options.findGroups" array is set, each item must be an object that includes the "type" (mandatory) and either "size" or "groupName" (choose 1) used to locate previously scaled (minmax or zscore) groups.');
                                T.push(C.toString(), D.toString());
                            }
                        } catch (t) {
                            _.e(t);
                        } finally {
                            _.f();
                        }
                    } else if (0 === u.length) throw new Error('"trainingCols" array is empty in '.concat(n));
                    var R = io[v], F = R.shortName, L = R.flatY, z = R.useTrainMethod, Y = "cla_".concat(F, "_").concat(r, "_prediction");
                    if (this.isAlreadyComputed.has(Y)) throw new Error("Each classifier must have a unique pair of “type” and trainingSize.\nThis rule ensures that your output columns are labeled unambiguously.\n" + 'You provided a duplicate: type="'.concat(v, '" with trainingSize=').concat(r, "."));
                    var U = {
                        lookbackAbs: Math.abs(m) + 1,
                        flatY: L,
                        prefix: Y,
                        useTrainMethod: z
                    };
                    this.isAlreadyComputed.add(Y);
                    var G = Qn(T, n);
                    return this.inputParams.push({
                        key: n,
                        order: G,
                        params: [ r, {
                            yCallback: P,
                            predictions: S,
                            lookback: m,
                            retrain: i,
                            trainingCols: u,
                            findGroups: g,
                            horizon: A,
                            type: v,
                            modelArgs: N,
                            precompute: U
                        } ]
                    }), this;
                }
            }, {
                key: "regressor",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 200, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    l(this);
                    var e = "regressor";
                    p(t, {
                        max: this.len,
                        allowDecimals: !1
                    }, "trainingSize", e), s(r, "options", e);
                    var n = r.retrain, o = void 0 !== n && n, i = r.target, a = void 0 === i ? "close" : i, u = r.predictions, h = void 0 === u ? 1 : u, d = r.trainingCols, m = void 0 === d ? [] : d, b = r.type, g = void 0 === b ? "SimpleLinearRegression" : b, w = r.lookback, S = void 0 === w ? 0 : w, O = r.findGroups, A = void 0 === O ? [] : O, j = r.modelArgs, N = void 0 === j ? void 0 : j;
                    if (f(Object.keys(ao), g, "type", e), !this.ML.classes.hasOwnProperty(g)) throw new Error('"'.concat(g, '" isn’t available because its library wasn’t imported into OHLCV_INDICATORS.ML.'));
                    //regressor
                                        y(o, "options.retrain", e), v(a, "options.target", e), p(h, {
                        min: 1,
                        allowDecimals: !1
                    }, "predictions", e), p(S, {
                        max: 0,
                        allowDecimals: !1
                    }, "lookback", e), c(m, "options.trainingCols", e);
                    var P = ao[g], T = P.shortName, x = P.flatX, _ = P.flatY, E = P.useTrainMethod, k = "reg_".concat(T, "_").concat(t, "_").concat(a, "_prediction"), C = yo(m);
                    if (c(A, "options.findGroups", "scaler") && A.length > 0) {
                        var M, I = so(A);
                        try {
                            for (I.s(); !(M = I.n()).done; ) {
                                var D = M.value, R = D.type, F = void 0 === R ? "" : R, L = D.size, z = D.groupName, Y = void 0 === z ? "" : z;
                                if (!F || !L && !Y || L && Y) throw new Error('If "options.findGroups" array is set, each item must be an object that includes the "type" (mandatory) and either "size" or "groupName" (choose 1) used to locate previously scaled (minmax or zscore) groups.');
                                C.push(F.toString(), Y.toString());
                            }
                        } catch (t) {
                            I.e(t);
                        } finally {
                            I.f();
                        }
                    } else if (0 === m.length && !1 === x) throw new Error('"trainingCols" array is empty in '.concat(e, " ").concat(g));
                    if (x) {
                        if (m.length > 0) throw new Error("If regressor type is ".concat(g, ' then leave "options.trainingCols" array empty.'));
                        if (S > 0) throw new Error("If regressor type is ".concat(g, ' then "options.lookback" must be 0.'));
                        if (A.length > 0) throw new Error("If regressor type is ".concat(g, ' then "options.findGroups" must be null.'));
                        m.push(a);
                    }
                    if (this.isAlreadyComputed.has(k)) throw new Error('Each regressor must have a unique "type", "trainingSize" and "target".\nThis rule ensures that your output columns are labeled unambiguously.\n' + 'You provided a duplicate: type="'.concat(g, '", trainingSize=').concat(t, " target=").concat(a, "."));
                    var U = {
                        lookbackAbs: Math.abs(S) + 1,
                        flatX: x,
                        flatY: _,
                        prefix: k,
                        useTrainMethod: E
                    };
                    this.isAlreadyComputed.add(k);
                    var G = Qn(C, e);
                    return this.inputParams.push({
                        key: e,
                        order: G,
                        params: [ t, {
                            target: a,
                            predictions: h,
                            retrain: o,
                            lookback: S,
                            trainingCols: m,
                            findGroups: A,
                            type: g,
                            modelArgs: N,
                            precompute: U
                        } ]
                    }), this;
                }
            }, {
                key: "pca",
                value: function(t, r) {
                    var e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = "pca";
                    p(r, {
                        min: 1,
                        max: this.len
                    }, "trainingSize", n), v(t, "suffix", n), s(e, "options", n);
                    var o = e.findGroups, i = void 0 === o ? [] : o, a = e.trainingCols, u = void 0 === a ? [] : a, l = e.lookback, h = void 0 === l ? 0 : l;
                    c(u, "options.trainigCols", n), p(h, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lookback", n), void 0 !== e.modelArgs ? s(e.modelArgs, "options.modelArgs", n) : e.modelArgs = {};
                    //modelArgs
                    var d = function(t) {
                        for (var r = 1; r < arguments.length; r++) {
                            var e = null != arguments[r] ? arguments[r] : {};
                            r % 2 ? uo(Object(e), !0).forEach((function(r) {
                                co(t, r, e[r]);
                            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)) : uo(Object(e)).forEach((function(r) {
                                Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
                            }));
                        }
                        return t;
                    }({
                        showSource: !1,
                        storeModel: !1,
                        isCovarianceMatrix: !1,
                        method: "NIPALS",
                        //SVD, covarianceMatrix or NIPALS
                        center: !0,
                        scale: !1,
                        nCompNIPALS: 5,
                        ignoreZeroVariance: !1
                    }, e.modelArgs);
                    y(d.showSource, "options.modelArgs.showSource", n), y(d.storeModel, "options.modelArgs.storeModel", n), 
                    y(d.isCovarianceMatrix, "options.modelArgs.isCovarianceMatrix", n), y(d.center, "options.modelArgs.center", n), 
                    y(d.scale, "options.modelArgs.scale", n), y(d.ignoreZeroVariance, "options.modelArgs.ignoreZeroVariance", n), 
                    f([ "SVD", "NIPALS", "covarianceMatrix" ], d.method, "options.modelArgs.method", n), 
                    p(d.nCompNIPALS, {
                        min: 1
                    }, "options.modelArgs.nCompNIPALS", n);
                    var m = [];
                    if (c(i, "options.findGroups", "pca") && i.length > 0) {
                        var b, g = so(i);
                        try {
                            for (g.s(); !(b = g.n()).done; ) {
                                var w = b.value, S = w.type, O = void 0 === S ? "" : S, A = w.size, j = w.groupName, N = void 0 === j ? "" : j;
                                if (!O || !A && !N || A && N) throw new Error('If "options.findGroups" array is set, each item must be an object that includes the "type" (mandatory) and either "size" or "groupName" (choose 1) used to locate previously scaled (minmax or zscore) groups.');
                                m.push(O.toString(), N.toString());
                            }
                        } catch (t) {
                            g.e(t);
                        } finally {
                            g.f();
                        }
                    }
                    var P = Qn(m, n), T = "pca_".concat(t, "_").concat(r);
                    if (this.isAlreadyComputed.has(T)) throw new Error('Each regressor must have a unique "suffix" param.\nThis rule ensures that your output columns are labeled unambiguously.\n' + 'You provided a duplicate: type="'.concat(t, '".'));
                    var x = Math.abs(h) + 1;
                    return this.isAlreadyComputed.add(T), this.inputParams.push({
                        key: n,
                        order: P,
                        params: [ {
                            prefix: T,
                            trainingSize: r,
                            findGroups: i,
                            trainingCols: u,
                            lookbackAbs: x,
                            modelArgs: d
                        } ]
                    }), this;
                }
            }, {
                key: "exportTrainedModels",
                value: function() {
                    return oo(this);
                }
            }, {
                key: "mapCols",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [ "change" ], r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    l(this);
                    var n = "mapCols";
                    null == r && (r = pn), s(e, "options", n);
                    var o = e.lag, i = void 0 === o ? 0 : o;
                    c(t, "newCols", n), p(i, {
                        min: 0,
                        allowDecimals: !1
                    }, "options.lag", n);
                    var a = Qn(t, n);
                    return this.inputParams.push({
                        key: n,
                        order: a,
                        params: [ t, r, {
                            lag: i
                        } ]
                    }), this;
                }
            } ], r && vo(t.prototype, r), n && vo(t, n), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
            var t, r, n;
        }();
    })(), OHLCV_INDICATORS = r;
})
/******/ ();