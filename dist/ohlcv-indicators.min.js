var OHLCV_INDICATORS;

/******/ (() => {
    // webpackBootstrap
    /******/ "use strict";
    /******/ // The require scope
    /******/    var t = {
        /******/ // define getter functions for harmony exports
        /******/ d: (e, r) => {
            /******/ for (var n in r) 
            /******/ t.o(r, n) && !t.o(e, n) && 
            /******/ Object.defineProperty(e, n, {
                enumerable: !0,
                get: r[n]
            })
            /******/;
            /******/        },
        /******/ o: (t, e) => Object.prototype.hasOwnProperty.call(t, e)
        /******/ ,
        /******/ // define __esModule on exports
        /******/ r: t => {
            /******/ "undefined" != typeof Symbol && Symbol.toStringTag && 
            /******/ Object.defineProperty(t, Symbol.toStringTag, {
                value: "Module"
            })
            /******/ , Object.defineProperty(t, "__esModule", {
                value: !0
            });
        }
        /******/    }, e = {};
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/define property getters */
    /******/    
    // This entry need to be wrapped in an IIFE because it declares 'OHLCV_INDICATORS' on top-level, which conflicts with the current library output.
    (() => {
        // ./src/utilities/validators.js
        function r(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = function(t, e) {
                    if (t) {
                        if ("string" == typeof t) return n(t, e);
                        var r = {}.toString.call(t).slice(8, -1);
                        return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? n(t, e) : void 0;
                    }
                }(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var o = 0, i = function() {};
                    return {
                        s: i,
                        n: function() {
                            return o >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[o++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: i
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var a, u = !0, l = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return u = t.done, t;
                },
                e: function(t) {
                    l = !0, a = t;
                },
                f: function() {
                    try {
                        u || null == r.return || r.return();
                    } finally {
                        if (l) throw a;
                    }
                }
            };
        }
        function n(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        // ESM COMPAT FLAG
        t.r(e), 
        // EXPORTS
        t.d(e, {
            default: () => /* binding */ Hr
        });
        var o = function(t) {
            return "string" == typeof t && /^\d{4}-\d{2}-\d{2}/.test(t);
        }, i = function(t) {
            if (0 !== t.lastComputedIndex) throw Error('ohlcv is already computed, you can not add new indicators after "compute", "getLastValues" , "getDataAsCols" or "getData" methods are called.');
        }, // 0, 1, 2 or 3
        // The maximum value of DP and Big.DP.
        a = 1e6, // 0 to 1000000
        // The maximum magnitude of the exponent argument to the pow method.
        u = 1e6, // true or false
        /**************************************************************************************************/
        // Error messages.
        l = "[big.js] ", c = l + "Invalid ", s = c + "decimal places", f = c + "rounding mode", h = l + "Division by zero", 
        // The shared prototype object.
        y = {}, p = void 0, v = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
        /*
 * Round Big x to a maximum of sd significant digits using rounding mode rm.
 *
 * x {Big} The Big to round.
 * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.
 * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 * [more] {boolean} Whether the result of division was truncated.
 */
        function d(t, e, r, n) {
            var o = t.c;
            if (r === p && (r = t.constructor.RM), 0 !== r && 1 !== r && 2 !== r && 3 !== r) throw Error(f);
            if (e < 1) n = 3 === r && (n || !!o[0]) || 0 === e && (1 === r && o[0] >= 5 || 2 === r && (o[0] > 5 || 5 === o[0] && (n || o[1] !== p))), 
            o.length = 1, n ? (
            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
            t.e = t.e - e + 1, o[0] = 1) : 
            // Zero.
            o[0] = t.e = 0; else if (e < o.length) {
                // Round up?
                if (
                // xc[sd] is the digit after the digit that may be rounded up.
                n = 1 === r && o[e] >= 5 || 2 === r && (o[e] > 5 || 5 === o[e] && (n || o[e + 1] !== p || 1 & o[e - 1])) || 3 === r && (n || !!o[0]), 
                // Remove any digits after the required precision.
                o.length = e, n) 
                // Rounding up may mean the previous digit has to be rounded up.
                for (;++o[--e] > 9; ) if (o[e] = 0, 0 === e) {
                    ++t.e, o.unshift(1);
                    break;
                }
                // Remove trailing zeros.
                                for (e = o.length; !o[--e]; ) o.pop();
            }
            return t;
        }
        /*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 */        function b(t, e, r) {
            var n = t.e, o = t.c.join(""), i = o.length;
            // Exponential notation?
                        if (e) o = o.charAt(0) + (i > 1 ? "." + o.slice(1) : "") + (n < 0 ? "e" : "e+") + n;
            // Normal notation.
             else if (n < 0) {
                for (;++n; ) o = "0" + o;
                o = "0." + o;
            } else if (n > 0) if (++n > i) for (n -= i; n--; ) o += "0"; else n < i && (o = o.slice(0, n) + "." + o.slice(n)); else i > 1 && (o = o.charAt(0) + "." + o.slice(1));
            return t.s < 0 && r ? "-" + o : o;
        }
        // Prototype/instance methods
        /*
 * Return a new Big whose value is the absolute value of this Big.
 */        y.abs = function() {
            var t = new this.constructor(this);
            return t.s = 1, t;
        }, 
        /*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
 */
        y.cmp = function(t) {
            var e, r = this, n = r.c, o = (t = new r.constructor(t)).c, i = r.s, a = t.s, u = r.e, l = t.e;
            // Either zero?
                        if (!n[0] || !o[0]) return n[0] ? i : o[0] ? -a : 0;
            // Signs differ?
                        if (i != a) return i;
            // Compare exponents.
            if (e = i < 0, u != l) return u > l ^ e ? 1 : -1;
            // Compare digit by digit.
            for (a = (u = n.length) < (l = o.length) ? u : l, i = -1; ++i < a; ) if (n[i] != o[i]) return n[i] > o[i] ^ e ? 1 : -1;
            // Compare lengths.
                        return u == l ? 0 : u > l ^ e ? 1 : -1;
        }, 
        /*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
        y.div = function(t) {
            var e = this, r = e.constructor, n = e.c, // dividend
            o = (t = new r(t)).c, // divisor
            i = e.s == t.s ? 1 : -1, u = r.DP;
            if (u !== ~~u || u < 0 || u > a) throw Error(s);
            // Divisor is zero?
                        if (!o[0]) throw Error(h);
            // Dividend is 0? Return +-0.
                        if (!n[0]) return t.s = i, t.c = [ t.e = 0 ], t;
            var l, c, f, y, v, b = o.slice(), m = l = o.length, g = n.length, w = n.slice(0, l), // remainder
            O = w.length, S = t, // quotient
            _ = S.c = [], j = 0, P = u + (S.e = e.e - t.e) + 1;
 // precision of the result
                        // Add zeros to make remainder as long as divisor.
            for (S.s = i, i = P < 0 ? 0 : P, 
            // Create version of divisor with leading zero.
            b.unshift(0); O++ < l; ) w.push(0);
            do {
                // n is how many times the divisor goes into current remainder.
                for (f = 0; f < 10; f++) {
                    // Compare divisor and remainder.
                    if (l != (O = w.length)) y = l > O ? 1 : -1; else for (v = -1, y = 0; ++v < l; ) if (o[v] != w[v]) {
                        y = o[v] > w[v] ? 1 : -1;
                        break;
                    }
                    // If divisor < remainder, subtract divisor from remainder.
                                        if (!(y < 0)) break;
                    // Remainder can't be more than 1 digit longer than divisor.
                    // Equalise lengths using divisor with extra leading zero?
                    for (c = O == l ? o : b; O; ) {
                        if (w[--O] < c[O]) {
                            for (v = O; v && !w[--v]; ) w[v] = 9;
                            --w[v], w[O] += 10;
                        }
                        w[O] -= c[O];
                    }
                    for (;!w[0]; ) w.shift();
                }
                // Add the digit n to the result array.
                                _[j++] = y ? f : ++f, 
                // Update the remainder.
                w[0] && y ? w[O] = n[m] || 0 : w = [ n[m] ];
            } while ((m++ < g || w[0] !== p) && i--);
            // Leading zero? Do not remove if result is simply zero (qi == 1).
                        return _[0] || 1 == j || (
            // There can't be more than one zero.
            _.shift(), S.e--, P--), 
            // Round?
            j > P && d(S, P, r.RM, w[0] !== p), S;
        }, 
        /*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */
        y.eq = function(t) {
            return 0 === this.cmp(t);
        }, 
        /*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */
        y.gt = function(t) {
            return this.cmp(t) > 0;
        }, 
        /*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */
        y.gte = function(t) {
            return this.cmp(t) > -1;
        }, 
        /*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */
        y.lt = function(t) {
            return this.cmp(t) < 0;
        }, 
        /*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */
        y.lte = function(t) {
            return this.cmp(t) < 1;
        }, 
        /*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */
        y.minus = y.sub = function(t) {
            var e, r, n, o, i = this, a = i.constructor, u = i.s, l = (t = new a(t)).s;
            // Signs differ?
                        if (u != l) return t.s = -l, i.plus(t);
            var c = i.c.slice(), s = i.e, f = t.c, h = t.e;
            // Either zero?
                        if (!c[0] || !f[0]) return f[0] ? t.s = -l : c[0] ? t = new a(i) : t.s = 1, 
            t;
            // Determine which is the bigger number. Prepend zeros to equalise exponents.
                        if (u = s - h) {
                for ((o = u < 0) ? (u = -u, n = c) : (h = s, n = f), n.reverse(), l = u; l--; ) n.push(0);
                n.reverse();
            } else for (
            // Exponents equal. Check digit by digit.
            r = ((o = c.length < f.length) ? c : f).length, u = l = 0; l < r; l++) if (c[l] != f[l]) {
                o = c[l] < f[l];
                break;
            }
            // x < y? Point xc to the array of the bigger number.
                        /*
   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
   * needs to start at yc.length.
   */
            if (o && (n = c, c = f, f = n, t.s = -t.s), (l = (r = f.length) - (e = c.length)) > 0) for (;l--; ) c[e++] = 0;
            // Subtract yc from xc.
                        for (l = e; r > u; ) {
                if (c[--r] < f[r]) {
                    for (e = r; e && !c[--e]; ) c[e] = 9;
                    --c[e], c[r] += 10;
                }
                c[r] -= f[r];
            }
            // Remove trailing zeros.
                        for (;0 === c[--l]; ) c.pop();
            // Remove leading zeros and adjust exponent accordingly.
                        for (;0 === c[0]; ) c.shift(), --h;
            return c[0] || (
            // n - n = +0
            t.s = 1, 
            // Result must be zero.
            c = [ h = 0 ]), t.c = c, t.e = h, t;
        }, 
        /*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */
        y.mod = function(t) {
            var e, r = this, n = r.constructor, o = r.s, i = (t = new n(t)).s;
            if (!t.c[0]) throw Error(h);
            return r.s = t.s = 1, e = 1 == t.cmp(r), r.s = o, t.s = i, e ? new n(r) : (o = n.DP, 
            i = n.RM, n.DP = n.RM = 0, r = r.div(t), n.DP = o, n.RM = i, this.minus(r.times(t)));
        }, 
        /*
 * Return a new Big whose value is the value of this Big negated.
 */
        y.neg = function() {
            var t = new this.constructor(this);
            return t.s = -t.s, t;
        }, 
        /*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */
        y.plus = y.add = function(t) {
            var e, r, n, o = this, i = o.constructor;
            // Signs differ?
            if (t = new i(t), o.s != t.s) return t.s = -t.s, o.minus(t);
            var a = o.e, u = o.c, l = t.e, c = t.c;
            // Either zero?
                        if (!u[0] || !c[0]) return c[0] || (u[0] ? t = new i(o) : t.s = o.s), 
            t;
            // Prepend zeros to equalise exponents.
            // Note: reverse faster than unshifts.
            if (u = u.slice(), e = a - l) {
                for (e > 0 ? (l = a, n = c) : (e = -e, n = u), n.reverse(); e--; ) n.push(0);
                n.reverse();
            }
            // Point xc to the longer array.
                        // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
            for (u.length - c.length < 0 && (n = c, c = u, u = n), e = c.length, r = 0; e; u[e] %= 10) r = (u[--e] = u[e] + c[e] + r) / 10 | 0;
            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
                        // Remove trailing zeros.
            for (r && (u.unshift(r), ++l), e = u.length; 0 === u[--e]; ) u.pop();
            return t.c = u, t.e = l, t;
        }, 
        /*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */
        y.pow = function(t) {
            var e = this, r = new e.constructor("1"), n = r, o = t < 0;
            if (t !== ~~t || t < -1e6 || t > u) throw Error(c + "exponent");
            for (o && (t = -t); 1 & t && (n = n.times(e)), t >>= 1; ) e = e.times(e);
            return o ? r.div(n) : n;
        }, 
        /*
 * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
 * significant digits using rounding mode rm, or Big.RM if rm is not specified.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
        y.prec = function(t, e) {
            if (t !== ~~t || t < 1 || t > a) throw Error(c + "precision");
            return d(new this.constructor(this), t, e);
        }, 
        /*
 * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places
 * using rounding mode rm, or Big.RM if rm is not specified.
 * If dp is negative, round to an integer which is a multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
        y.round = function(t, e) {
            if (t === p) t = 0; else if (t !== ~~t || t < -a || t > a) throw Error(s);
            return d(new this.constructor(this), t + this.e + 1, e);
        }, 
        /*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
        y.sqrt = function() {
            var t, e, r, n = this, o = n.constructor, i = n.s, a = n.e, u = new o("0.5");
            // Zero?
                        if (!n.c[0]) return new o(n);
            // Negative?
                        if (i < 0) throw Error(l + "No square root");
            // Estimate.
                        // Math.sqrt underflow/overflow?
            // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
            0 === (i = Math.sqrt(n + "")) || i === 1 / 0 ? ((e = n.c.join("")).length + a & 1 || (e += "0"), 
            a = ((a + 1) / 2 | 0) - (a < 0 || 1 & a), t = new o(((i = Math.sqrt(e)) == 1 / 0 ? "5e" : (i = i.toExponential()).slice(0, i.indexOf("e") + 1)) + a)) : t = new o(i + ""), 
            a = t.e + (o.DP += 4);
            // Newton-Raphson iteration.
            do {
                r = t, t = u.times(r.plus(n.div(r)));
            } while (r.c.slice(0, a).join("") !== t.c.slice(0, a).join(""));
            return d(t, (o.DP -= 4) + t.e + 1, o.RM);
        }, 
        /*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */
        y.times = y.mul = function(t) {
            var e, r = this, n = r.constructor, o = r.c, i = (t = new n(t)).c, a = o.length, u = i.length, l = r.e, c = t.e;
            // Determine sign of result.
                        // Return signed 0 if either 0.
            if (t.s = r.s == t.s ? 1 : -1, !o[0] || !i[0]) return t.c = [ t.e = 0 ], t;
            // Initialise exponent of result as x.e + y.e.
                        // Initialise coefficient array of result with zeros.
            for (t.e = l + c, 
            // If array xc has fewer digits than yc, swap xc and yc, and lengths.
            a < u && (e = o, o = i, i = e, c = a, a = u, u = c), e = new Array(c = a + u); c--; ) e[c] = 0;
            // Multiply.
            // i is initially xc.length.
                        for (l = u; l--; ) {
                // a is yc.length.
                for (u = 0, c = a + l; c > l; ) 
                // Current sum of products at this digit position, plus carry.
                u = e[c] + i[l] * o[c - l - 1] + u, e[c--] = u % 10, 
                // carry
                u = u / 10 | 0;
                e[c] = u;
            }
            // Increment result exponent if there is a final carry, otherwise remove leading zero.
                        // Remove trailing zeros.
            for (u ? ++t.e : e.shift(), l = e.length; !e[--l]; ) e.pop();
            return t.c = e, t;
        }, 
        /*
 * Return a string representing the value of this Big in exponential notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
        y.toExponential = function(t, e) {
            var r = this, n = r.c[0];
            if (t !== p) {
                if (t !== ~~t || t < 0 || t > a) throw Error(s);
                for (r = d(new r.constructor(r), ++t, e); r.c.length < t; ) r.c.push(0);
            }
            return b(r, !0, !!n);
        }, 
        /*
 * Return a string representing the value of this Big in normal notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */
        y.toFixed = function(t, e) {
            var r = this, n = r.c[0];
            if (t !== p) {
                if (t !== ~~t || t < 0 || t > a) throw Error(s);
                // x.e may have changed if the value is rounded up.
                for (t = t + (r = d(new r.constructor(r), t + r.e + 1, e)).e + 1; r.c.length < t; ) r.c.push(0);
            }
            return b(r, !1, !!n);
        }, 
        /*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */
        y[Symbol.for("nodejs.util.inspect.custom")] = y.toJSON = y.toString = function() {
            var t = this, e = t.constructor;
            return b(t, t.e <= e.NE || t.e >= e.PE, !!t.c[0]);
        }, 
        /*
 * Return the value of this Big as a primitve number.
 */
        y.toNumber = function() {
            var t = Number(b(this, !0, !0));
            if (!0 === this.constructor.strict && !this.eq(t.toString())) throw Error(l + "Imprecise conversion");
            return t;
        }, 
        /*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * rounding mode rm, or Big.RM if rm is not specified.
 * Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
        y.toPrecision = function(t, e) {
            var r = this, n = r.constructor, o = r.c[0];
            if (t !== p) {
                if (t !== ~~t || t < 1 || t > a) throw Error(c + "precision");
                for (r = d(new n(r), t, e); r.c.length < t; ) r.c.push(0);
            }
            return b(r, t <= r.e || r.e <= n.NE || r.e >= n.PE, !!o);
        }, 
        /*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */
        y.valueOf = function() {
            var t = this, e = t.constructor;
            if (!0 === e.strict) throw Error(l + "valueOf disallowed");
            return b(t, t.e <= e.NE || t.e >= e.PE, !0);
        };
        // Export
        (
        /*
 * Create and return a Big constructor.
 */
        function t() {
            /*
   * The Big constructor and exported function.
   * Create and return a new instance of a Big number object.
   *
   * n {number|string|Big} A numeric value.
   */
            function e(r) {
                var n = this;
                // Enable constructor usage without new.
                                if (!(n instanceof e)) return r === p ? t() : new e(r);
                // Duplicate.
                                if (r instanceof e) n.s = r.s, n.e = r.e, n.c = r.c.slice(); else {
                    if ("string" != typeof r) {
                        if (!0 === e.strict && "bigint" != typeof r) throw TypeError(c + "value");
                        // Minus zero?
                                                r = 0 === r && 1 / r < 0 ? "-0" : String(r);
                    }
                    !
                    /*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */
                    function(t, e) {
                        var r, n, o;
                        if (!v.test(e)) throw Error(c + "number");
                        // Determine sign.
                                                // Decimal point?
                        t.s = "-" == e.charAt(0) ? (e = e.slice(1), -1) : 1, (r = e.indexOf(".")) > -1 && (e = e.replace(".", ""));
                        // Exponential form?
                                                (n = e.search(/e/i)) > 0 ? (
                        // Determine exponent.
                        r < 0 && (r = n), r += +e.slice(n + 1), e = e.substring(0, n)) : r < 0 && (
                        // Integer.
                        r = e.length);
                        // Determine leading zeros.
                        for (o = e.length, n = 0; n < o && "0" == e.charAt(n); ) ++n;
                        if (n == o) 
                        // Zero.
                        t.c = [ t.e = 0 ]; else {
                            // Determine trailing zeros.
                            for (;o > 0 && "0" == e.charAt(--o); ) ;
                            // Convert string to array of digits without leading/trailing zeros.
                            for (t.e = r - n - 1, t.c = [], r = 0; n <= o; ) t.c[r++] = +e.charAt(n++);
                        }
                    }(n, r);
                }
                // Retain a reference to this Big constructor.
                // Shadow Big.prototype.constructor which points to Object.
                                n.constructor = e;
            }
            return e.prototype = y, e.DP = 20, e.RM = 1, e.NE = -7, e.PE = 21, e.strict = false, 
            e.roundDown = 0, e.roundHalfUp = 1, e.roundHalfEven = 2, e.roundUp = 3, e;
        })();
        /// <reference types="https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts" />
        /* harmony default export */        // ./node_modules/trading-signals/dist/error/NotEnoughDataError.js
        function m(t) {
            return m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, m(t);
        }
        function g(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, w(n.key), n);
            }
        }
        function w(t) {
            var e = function(t, e) {
                if ("object" != m(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != m(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == m(e) ? e : e + "";
        }
        function O(t, e, r) {
            return e = P(e), function(t, e) {
                if (e && ("object" == m(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, _() ? Reflect.construct(e, r || [], P(t).constructor) : e.apply(t, r));
        }
        function S(t) {
            var e = "function" == typeof Map ? new Map : void 0;
            return S = function(t) {
                if (null === t || !function(t) {
                    try {
                        return -1 !== Function.toString.call(t).indexOf("[native code]");
                    } catch (e) {
                        return "function" == typeof t;
                    }
                }(t)) return t;
                if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== e) {
                    if (e.has(t)) return e.get(t);
                    e.set(t, r);
                }
                function r() {
                    return function(t, e, r) {
                        if (_()) return Reflect.construct.apply(null, arguments);
                        var n = [ null ];
                        n.push.apply(n, e);
                        var o = new (t.bind.apply(t, n));
                        return r && j(o, r.prototype), o;
                    }(t, arguments, P(this).constructor);
                }
                return r.prototype = Object.create(t.prototype, {
                    constructor: {
                        value: r,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), j(r, t);
            }, S(t);
        }
        function _() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (_ = function() {
                return !!t;
            })();
        }
        function j(t, e) {
            return j = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, j(t, e);
        }
        function P(t) {
            return P = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, P(t);
        }
        var A =  function(t) {
            function e() {
                var t, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Not enough data";
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                }(this, e), t = O(this, e, [ r ]), Object.setPrototypeOf(t, (this instanceof e ? this.constructor : void 0).prototype), 
                t.name = "NotEnoughDataError", t;
            }
            return function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), e && j(t, e);
            }(e, t), r = e, n && g(r.prototype, n), o && g(r, o), Object.defineProperty(r, "prototype", {
                writable: !1
            }), r;
            var r, n, o;
        }( S(Error));
        // ./node_modules/trading-signals/dist/Indicator.js
        function E(t) {
            return E = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, E(t);
        }
        function M(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function x(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, I(n.key), n);
            }
        }
        function k(t, e, r) {
            return e && x(t.prototype, e), r && x(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function T(t, e, r) {
            return (e = I(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function I(t) {
            var e = function(t, e) {
                if ("object" != E(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != E(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == E(e) ? e : e + "";
        }
        var C =  function() {
            return k((function t() {
                M(this, t), T(this, "previousHighest", void 0), T(this, "highest", void 0), T(this, "previousLowest", void 0), 
                T(this, "lowest", void 0), T(this, "previousResult", void 0), T(this, "result", void 0);
            }), [ {
                key: "isStable",
                get: function() {
                    return void 0 !== this.result;
                }
            }, {
                key: "getResult",
                value: function() {
                    if (void 0 === this.result) throw new A;
                    return this.result;
                }
            }, {
                key: "setResult",
                value: function(t, e) {
                    return e && (this.highest = this.previousHighest, this.lowest = this.previousLowest, 
                    this.result = this.previousResult), void 0 === this.highest ? this.highest = t : t > this.highest ? (this.previousHighest = this.highest, 
                    this.highest = t) : this.previousHighest = this.highest, void 0 === this.lowest ? this.lowest = t : t < this.lowest ? (this.previousLowest = this.lowest, 
                    this.lowest = t) : this.previousLowest = this.lowest, this.previousResult = this.result, 
                    this.result = t;
                }
            }, {
                key: "replace",
                value: function(t) {
                    return this.update(t, !0);
                }
            } ]);
        }();
        // ./node_modules/trading-signals/dist/MA/MovingAverage.js
        function R(t) {
            return R = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, R(t);
        }
        function D(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function V(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, $(n.key), n);
            }
        }
        function B(t, e, r) {
            return e && V(t.prototype, e), r && V(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function N(t, e, r) {
            return e = H(e), function(t, e) {
                if (e && ("object" == R(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, L() ? Reflect.construct(e, r || [], H(t).constructor) : e.apply(t, r));
        }
        function L() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (L = function() {
                return !!t;
            })();
        }
        function H(t) {
            return H = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, H(t);
        }
        function U(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && q(t, e);
        }
        function q(t, e) {
            return q = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, q(t, e);
        }
        function z(t, e, r) {
            return (e = $(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function $(t) {
            var e = function(t, e) {
                if ("object" != R(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != R(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == R(e) ? e : e + "";
        }
        var F =  function(t) {
            function e(t) {
                var r;
                return D(this, e), z(r = N(this, e), "interval", void 0), r.interval = t, r;
            }
            return U(e, t), B(e, [ {
                key: "updates",
                value: function(t) {
                    var e = this;
                    return t.forEach((function(t) {
                        return e.update(t);
                    })), this.result;
                }
            }, {
                key: "replace",
                value: function(t) {
                    return this.update(t, !0);
                }
            } ]);
        }(C);
        // ./node_modules/trading-signals/dist/SMA/SMA.js
        function K(t) {
            return K = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, K(t);
        }
        function G(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function J(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, rt(n.key), n);
            }
        }
        function W(t, e, r) {
            return e && J(t.prototype, e), r && J(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function Y(t, e, r) {
            return e = X(e), function(t, e) {
                if (e && ("object" == K(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, Q() ? Reflect.construct(e, r || [], X(t).constructor) : e.apply(t, r));
        }
        function Q() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (Q = function() {
                return !!t;
            })();
        }
        function X(t) {
            return X = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, X(t);
        }
        function Z(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && tt(t, e);
        }
        function tt(t, e) {
            return tt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, tt(t, e);
        }
        function et(t, e, r) {
            return (e = rt(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function rt(t) {
            var e = function(t, e) {
                if ("object" != K(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != K(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == K(e) ? e : e + "";
        }
        var nt =  function(t) {
            function e() {
                var t;
                G(this, e);
                for (var r = arguments.length, n = new Array(r), o = 0; o < r; o++) n[o] = arguments[o];
                return et(t = Y(this, e, [].concat(n)), "prices", []), t;
            }
            return Z(e, t), W(e, [ {
                key: "update",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if (this.prices.length && e ? this.prices[this.prices.length - 1] = t : this.prices.push(t), 
                    this.prices.length > this.interval && this.prices.shift(), this.prices.length === this.interval) {
                        var r = this.prices.reduce((function(t, e) {
                            return t + e;
                        }), 0);
                        return this.setResult(r / this.prices.length, e);
                    }
                }
            } ]);
        }(F);
        // ./node_modules/trading-signals/dist/WSMA/WSMA.js
        function ot(t) {
            return ot = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, ot(t);
        }
        function it(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function at(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, pt(n.key), n);
            }
        }
        function ut(t, e, r) {
            return e && at(t.prototype, e), r && at(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function lt(t, e, r) {
            return e = st(e), function(t, e) {
                if (e && ("object" == ot(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, ct() ? Reflect.construct(e, r || [], st(t).constructor) : e.apply(t, r));
        }
        function ct() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (ct = function() {
                return !!t;
            })();
        }
        function st(t) {
            return st = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, st(t);
        }
        function ft(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && ht(t, e);
        }
        function ht(t, e) {
            return ht = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, ht(t, e);
        }
        function yt(t, e, r) {
            return (e = pt(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function pt(t) {
            var e = function(t, e) {
                if ("object" != ot(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != ot(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == ot(e) ? e : e + "";
        }
        var vt =  function(t) {
            function e(t) {
                var r;
                return it(this, e), yt(r = lt(this, e), "interval", void 0), yt(r, "indicator", void 0), 
                yt(r, "smoothingFactor", void 0), r.interval = t, r.indicator = new nt(t), r.smoothingFactor = 1 / r.interval, 
                r;
            }
            return ft(e, t), ut(e, [ {
                key: "updates",
                value: function(t) {
                    var e = this;
                    return t.forEach((function(t) {
                        return e.update(t);
                    })), this.result;
                }
            }, {
                key: "update",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = this.indicator.update(t);
                    if (e && void 0 !== this.previousResult) {
                        var n = (t - this.previousResult) * this.smoothingFactor;
                        return this.setResult(n + this.previousResult, e);
                    }
                    if (!e && void 0 !== this.result) {
                        var o = (t - this.result) * this.smoothingFactor;
                        return this.setResult(o + this.result, e);
                    }
                    if (void 0 === this.result && void 0 !== r) return this.setResult(r, e);
                }
            } ]);
        }(C);
        function dt(t) {
            return t.length ? t.reduce((function(t, e) {
                return t + e;
            }), 0) / t.length : 0;
        }
        // ./node_modules/trading-signals/dist/BBANDS/BollingerBands.js
        function bt(t) {
            return bt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, bt(t);
        }
        function mt(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function gt(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, St(n.key), n);
            }
        }
        function wt(t, e, r) {
            return e && gt(t.prototype, e), r && gt(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function Ot(t, e, r) {
            return (e = St(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function St(t) {
            var e = function(t, e) {
                if ("object" != bt(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != bt(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == bt(e) ? e : e + "";
        }
        var _t =  function() {
            return wt((function t(e) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
                mt(this, t), Ot(this, "interval", void 0), Ot(this, "deviationMultiplier", void 0), 
                Ot(this, "prices", []), Ot(this, "result", void 0), this.interval = e, this.deviationMultiplier = r;
            }), [ {
                key: "update",
                value: function(t) {
                    if (this.prices.push(t), this.prices.length > this.interval) {
                        this.prices.shift();
                        var e = dt(this.prices), r = function(t, e) {
                            var r = e || dt(t), n = dt(t.map((function(t) {
                                return t - r;
                            })).map((function(t) {
                                return t * t;
                            })));
                            return Math.sqrt(n);
                        }(this.prices, e);
                        return this.result = {
                            lower: e - r * this.deviationMultiplier,
                            middle: e,
                            upper: e + r * this.deviationMultiplier
                        };
                    }
                }
            }, {
                key: "getResult",
                value: function() {
                    if (void 0 === this.result) throw new A;
                    return this.result;
                }
            }, {
                key: "isStable",
                get: function() {
                    return void 0 !== this.result;
                }
            } ]);
        }();
        // ./node_modules/trading-signals/dist/EMA/EMA.js
        function jt(t) {
            return jt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, jt(t);
        }
        function Pt(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function At(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, Rt(n.key), n);
            }
        }
        function Et(t, e, r) {
            return e && At(t.prototype, e), r && At(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function Mt(t, e, r) {
            return e = kt(e), function(t, e) {
                if (e && ("object" == jt(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, xt() ? Reflect.construct(e, r || [], kt(t).constructor) : e.apply(t, r));
        }
        function xt() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (xt = function() {
                return !!t;
            })();
        }
        function kt(t) {
            return kt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, kt(t);
        }
        function Tt(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && It(t, e);
        }
        function It(t, e) {
            return It = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, It(t, e);
        }
        function Ct(t, e, r) {
            return (e = Rt(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function Rt(t) {
            var e = function(t, e) {
                if ("object" != jt(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != jt(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == jt(e) ? e : e + "";
        }
        var Dt =  function(t) {
            function e(t) {
                var r;
                return Pt(this, e), Ct(r = Mt(this, e, [ t ]), "interval", void 0), Ct(r, "pricesCounter", 0), 
                Ct(r, "weightFactor", void 0), r.interval = t, r.weightFactor = 2 / (r.interval + 1), 
                r;
            }
            return Tt(e, t), Et(e, [ {
                key: "update",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    return e ? e && 0 === this.pricesCounter && this.pricesCounter++ : this.pricesCounter++, 
                    e && void 0 !== this.previousResult ? this.setResult(t * this.weightFactor + this.previousResult * (1 - this.weightFactor), e) : this.setResult(t * this.weightFactor + (void 0 !== this.result ? this.result : t) * (1 - this.weightFactor), e);
                }
            }, {
                key: "getResult",
                value: function() {
                    if (this.pricesCounter < this.interval) throw new A;
                    return this.result;
                }
            }, {
                key: "isStable",
                get: function() {
                    try {
                        return this.getResult(), !0;
                    } catch (t) {
                        return !1;
                    }
                }
            } ]);
        }(F);
        // ./node_modules/trading-signals/dist/MACD/MACD.js
        function Vt(t) {
            return Vt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Vt(t);
        }
        function Bt(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function Nt(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, Ut(n.key), n);
            }
        }
        function Lt(t, e, r) {
            return e && Nt(t.prototype, e), r && Nt(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function Ht(t, e, r) {
            return (e = Ut(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function Ut(t) {
            var e = function(t, e) {
                if ("object" != Vt(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != Vt(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == Vt(e) ? e : e + "";
        }
        var qt =  function() {
            return Lt((function t(e, r, n) {
                Bt(this, t), Ht(this, "short", void 0), Ht(this, "long", void 0), Ht(this, "signal", void 0), 
                Ht(this, "prices", []), Ht(this, "result", void 0), this.short = e, this.long = r, 
                this.signal = n;
            }), [ {
                key: "getResult",
                value: function() {
                    if (void 0 === this.result) throw new A;
                    return this.result;
                }
            }, {
                key: "isStable",
                get: function() {
                    return void 0 !== this.result;
                }
            }, {
                key: "update",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    this.prices.length && e ? this.prices[this.prices.length - 1] = t : this.prices.push(t);
                    var r = this.short.update(t, e), n = this.long.update(t, e);
                    if (this.prices.length > this.long.interval && this.prices.shift(), this.prices.length === this.long.interval) {
                        var o = r - n, i = this.signal.update(o, e);
                        return this.result = {
                            histogram: o - i,
                            macd: o,
                            signal: i
                        };
                    }
                }
            } ]);
        }();
        // ./node_modules/trading-signals/dist/RSI/RSI.js
        function zt(t) {
            return zt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, zt(t);
        }
        function $t(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function Ft(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, Zt(n.key), n);
            }
        }
        function Kt(t, e, r) {
            return e && Ft(t.prototype, e), r && Ft(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function Gt(t, e, r) {
            return e = Wt(e), function(t, e) {
                if (e && ("object" == zt(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, Jt() ? Reflect.construct(e, r || [], Wt(t).constructor) : e.apply(t, r));
        }
        function Jt() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (Jt = function() {
                return !!t;
            })();
        }
        function Wt(t) {
            return Wt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, Wt(t);
        }
        function Yt(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && Qt(t, e);
        }
        function Qt(t, e) {
            return Qt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, Qt(t, e);
        }
        function Xt(t, e, r) {
            return (e = Zt(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function Zt(t) {
            var e = function(t, e) {
                if ("object" != zt(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != zt(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == zt(e) ? e : e + "";
        }
        var te =  function(t) {
            function e(t) {
                var r, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vt;
                return $t(this, e), Xt(r = Gt(this, e), "interval", void 0), Xt(r, "previousPrices", []), 
                Xt(r, "avgGain", void 0), Xt(r, "avgLoss", void 0), Xt(r, "maxValue", 100), r.interval = t, 
                r.avgGain = new n(r.interval), r.avgLoss = new n(r.interval), r;
            }
            return Yt(e, t), Kt(e, [ {
                key: "update",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if (this.previousPrices.length && e ? this.previousPrices[this.previousPrices.length - 1] = t : this.previousPrices.push(t), 
                    !(this.previousPrices.length < 2)) {
                        var r = t, n = this.previousPrices[this.previousPrices.length - 2];
                        if (r > n ? (this.avgLoss.update(0, e), this.avgGain.update(t - n, e)) : (this.avgLoss.update(n - r, e), 
                        this.avgGain.update(0, e)), this.avgGain.isStable) {
                            var o = this.avgLoss.getResult();
                            if (0 === o) return this.setResult(100, e);
                            var i = this.avgGain.getResult() / o;
                            return this.setResult(this.maxValue - this.maxValue / (i + 1), e);
                        }
                    }
                }
            } ]);
        }(C);
        // ./src/utilities/numberUtilities.js
        function ee(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, e) {
                var r = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != r) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (r = r.call(t)).next, 0 === e) {
                            if (Object(r) !== r) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(r)).done) && (u.push(n.value), u.length !== e); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != r.return && (a = r.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, e) || function(t, e) {
                if (t) {
                    if ("string" == typeof t) return re(t, e);
                    var r = {}.toString.call(t).slice(8, -1);
                    return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? re(t, e) : void 0;
                }
            }(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function re(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        var ne = function(t) {
            var e = 1 / (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .1);
            return Math.round(t * e) / e;
        }, oe = function(t) {
            return t.replace(/(?!^-)[^0-9.]/g, "");
        };
        // Helper to clean non-numeric characters (except "-" at the start and decimal point)
                // ./src/oscillators/rsi.js
        function ie(t) {
            return ie = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, ie(t);
        }
        function ae(t) {
            return function(t) {
                if (Array.isArray(t)) return ue(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || function(t, e) {
                if (t) {
                    if ("string" == typeof t) return ue(t, e);
                    var r = {}.toString.call(t).slice(8, -1);
                    return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? ue(t, e) : void 0;
                }
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function ue(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        function le(t, e, r) {
            return (e = function(t) {
                var e = function(t, e) {
                    if ("object" != ie(t) || !t) return t;
                    var r = t[Symbol.toPrimitive];
                    if (void 0 !== r) {
                        var n = r.call(t, e || "default");
                        if ("object" != ie(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === e ? String : Number)(t);
                }(t, "string");
                return "symbol" == ie(e) ? e : e + "";
            }(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        var ce = function(t, e) {
            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .05, n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            // Validate that value and bollingerBands are not null/undefined
            if (null == t || null == e) return null;
            var o = t >= 0, i = Math.abs(t), a = e.upper, u = e.lower, l = ne((i - u) / (a - u), r);
            return 0 === l ? o ? .01 : -.01 : n ? o ? Math.min(l, 1) : Math.max(-l, -1) : o ? l : -l;
        };
        // ./src/moving-averages/movingAverages.js
        function se(t) {
            return se = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, se(t);
        }
        function fe(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = ye(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == r.return || r.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function he(t) {
            return function(t) {
                if (Array.isArray(t)) return pe(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || ye(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function ye(t, e) {
            if (t) {
                if ("string" == typeof t) return pe(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? pe(t, e) : void 0;
            }
        }
        function pe(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        var ve = {
            ema: Dt,
            sma: nt
        }, de = function(t, e, r, n) {
            if (!r || "object" !== se(r)) throw new Error('"options" must be an object in '.concat(t, ". eg: {target, height, range}"));
            var o = r.target, i = void 0 === o ? "close" : o, a = r.diff, u = void 0 === a ? null : a;
            if ("string" != typeof i) throw new Error('"target" must be a valid keyName '.concat(t, "."));
            if ("number" != typeof e || e <= 0) throw new Error('"size" must be a positive number in '.concat(t, "."));
            //diff can be null, true, false or an object with optional {stdDev, scale, targets, and size}
                        var l = {
                target: i,
                diff: null
            };
            if (null !== u && ("object" === se(u) || "boolean" == typeof u && !0 === u)) {
                var c = u = !0 === u ? {} : u, s = c.stdDev, f = void 0 === s ? 2 : s, h = c.scale, y = void 0 === h ? .05 : h, p = c.targets, v = void 0 === p ? [ "close" ] : p, d = c.size, b = void 0 === d ? e : d, m = c.lag, g = void 0 === m ? 0 : m, w = c.autoMinMax, O = void 0 !== w && w;
                if ("number" != typeof f || f <= 0) throw new Error('"diff.stdDev" must be a number greater than 0 in '.concat(t, "."));
                if ("number" != typeof y || !n.includes(y)) throw new Error('"diff.scale" must be a number between 0.01 and 1 in '.concat(t, "."));
                if ("number" != typeof b || !Number.isInteger(b) || b <= 0) throw new Error('"diff.size" must be an integer greater than or equal to size in '.concat(t, "."));
                if (!Array.isArray(v)) throw new Error('"diff.targest" must be an array of keyNames with at least 1 item in '.concat(t, "."));
                if ("number" != typeof g || !Number.isInteger(g) || g < 0) throw new Error('"diff.lag" must be an integer greater than 0 in '.concat(t, "."));
                if ("boolean" != typeof O) throw new Error('"diff.autoMinMax" must be an boolean in '.concat(t, "."));
                l.diff = {
                    stdDev: f,
                    scale: y,
                    size: b,
                    targets: v,
                    lag: g,
                    autoMinMax: O
                };
            }
            return l;
        };
        // ./src/moving-averages/macd.js
        function be(t) {
            return be = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, be(t);
        }
        function me(t, e, r) {
            return (e = function(t) {
                var e = function(t, e) {
                    if ("object" != be(t) || !t) return t;
                    var r = t[Symbol.toPrimitive];
                    if (void 0 !== r) {
                        var n = r.call(t, e || "default");
                        if ("object" != be(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === e ? String : Number)(t);
                }(t, "string");
                return "symbol" == be(e) ? e : e + "";
            }(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function ge(t) {
            return function(t) {
                if (Array.isArray(t)) return we(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || function(t, e) {
                if (t) {
                    if ("string" == typeof t) return we(t, e);
                    var r = {}.toString.call(t).slice(8, -1);
                    return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? we(t, e) : void 0;
                }
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function we(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        var Oe = "close";
        // ./src/moving-averages/relativeVolume.js
        function Se(t) {
            return function(t) {
                if (Array.isArray(t)) return _e(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || function(t, e) {
                if (t) {
                    if ("string" == typeof t) return _e(t, e);
                    var r = {}.toString.call(t).slice(8, -1);
                    return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? _e(t, e) : void 0;
                }
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function _e(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        // ./src/moving-averages/donchianChannel.js
        function je(t) {
            return je = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, je(t);
        }
        function Pe(t, e) {
            var r = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                e && (n = n.filter((function(e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable;
                }))), r.push.apply(r, n);
            }
            return r;
        }
        function Ae(t, e, r) {
            return (e = function(t) {
                var e = function(t, e) {
                    if ("object" != je(t) || !t) return t;
                    var r = t[Symbol.toPrimitive];
                    if (void 0 !== r) {
                        var n = r.call(t, e || "default");
                        if ("object" != je(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === e ? String : Number)(t);
                }(t, "string");
                return "symbol" == je(e) ? e : e + "";
            }(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function Ee(t) {
            return function(t) {
                if (Array.isArray(t)) return ke(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || xe(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Me(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = xe(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == r.return || r.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function xe(t, e) {
            if (t) {
                if ("string" == typeof t) return ke(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? ke(t, e) : void 0;
            }
        }
        function ke(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        // ./src/moving-averages/bollingerBands.js
        function Te(t) {
            return Te = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Te(t);
        }
        function Ie(t, e) {
            var r = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                e && (n = n.filter((function(e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable;
                }))), r.push.apply(r, n);
            }
            return r;
        }
        function Ce(t, e, r) {
            return (e = function(t) {
                var e = function(t, e) {
                    if ("object" != Te(t) || !t) return t;
                    var r = t[Symbol.toPrimitive];
                    if (void 0 !== r) {
                        var n = r.call(t, e || "default");
                        if ("object" != Te(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === e ? String : Number)(t);
                }(t, "string");
                return "symbol" == Te(e) ? e : e + "";
            }(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function Re(t) {
            return function(t) {
                if (Array.isArray(t)) return Be(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || Ve(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function De(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = Ve(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == r.return || r.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function Ve(t, e) {
            if (t) {
                if ("string" == typeof t) return Be(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Be(t, e) : void 0;
            }
        }
        function Be(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        // ./src/oscillators/volumeOscillator.js
        function Ne(t) {
            return function(t) {
                if (Array.isArray(t)) return Le(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || function(t, e) {
                if (t) {
                    if ("string" == typeof t) return Le(t, e);
                    var r = {}.toString.call(t).slice(8, -1);
                    return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Le(t, e) : void 0;
                }
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Le(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        // ./src/studies/candleVectors.js
        function He(t) {
            return He = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, He(t);
        }
        function Ue(t, e) {
            var r = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                e && (n = n.filter((function(e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable;
                }))), r.push.apply(r, n);
            }
            return r;
        }
        function qe(t) {
            for (var e = 1; e < arguments.length; e++) {
                var r = null != arguments[e] ? arguments[e] : {};
                e % 2 ? Ue(Object(r), !0).forEach((function(e) {
                    ze(t, e, r[e]);
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Ue(Object(r)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));
                }));
            }
            return t;
        }
        function ze(t, e, r) {
            return (e = function(t) {
                var e = function(t, e) {
                    if ("object" != He(t) || !t) return t;
                    var r = t[Symbol.toPrimitive];
                    if (void 0 !== r) {
                        var n = r.call(t, e || "default");
                        if ("object" != He(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === e ? String : Number)(t);
                }(t, "string");
                return "symbol" == He(e) ? e : e + "";
            }(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function $e(t) {
            return function(t) {
                if (Array.isArray(t)) return Je(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || Ge(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Fe(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, e) {
                var r = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != r) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (r = r.call(t)).next, 0 === e) {
                            if (Object(r) !== r) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(r)).done) && (u.push(n.value), u.length !== e); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != r.return && (a = r.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, e) || Ge(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Ke(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = Ge(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == r.return || r.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function Ge(t, e) {
            if (t) {
                if ("string" == typeof t) return Je(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Je(t, e) : void 0;
            }
        }
        function Je(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        var We = function(t, e) {
            return t - e;
        }, Ye = function(t, e, r, n, o) {
            if (o ? t[e][t[e].length - 1] = n : t[e].push(n), t[e].length > r && t[e].shift(), 
            t.length < r) return null;
            var i = t[e].reduce((function(t, e) {
                return t + e;
            }), 0) / r, a = Math.sqrt(t[e].reduce((function(t, e) {
                return t + Math.pow(e - i, 2);
            }), 0) / r);
            return (n - i) / a;
        };
        // ./src/studies/lag.js
        function Qe(t) {
            return function(t) {
                if (Array.isArray(t)) return er(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || tr(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Xe(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, e) {
                var r = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != r) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (r = r.call(t)).next, 0 === e) {
                            if (Object(r) !== r) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(r)).done) && (u.push(n.value), u.length !== e); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != r.return && (a = r.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, e) || tr(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Ze(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = tr(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == r.return || r.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function tr(t, e) {
            if (t) {
                if ("string" == typeof t) return er(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? er(t, e) : void 0;
            }
        }
        function er(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        function rr(t) {
            return rr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, rr(t);
        }
        var nr = function(t, e) {
            var r = t.instances, n = t.verticalOhlcv, o = t.nullArray;
            if (0 === e) {
                var i = t.inputParams, a = t.priceBased, u = i.filter((function(t) {
                    return "lag" === t.key;
                }));
                if ("object" !== rr(u)) return;
                var l, c = u.map((function(t) {
                    return t.params;
                })), s = Ze(c);
                try {
                    for (s.s(); !(l = s.n()).done; ) {
                        var f, h = Xe(l.value, 2), y = h[0], p = h[1], v = Ze(y);
                        try {
                            for (v.s(); !(f = v.n()).done; ) {
                                var d = f.value;
                                if (a.includes(d)) for (var b = 1; b <= p; b++) a.push("".concat(d, "_lag_").concat(b));
                            }
                        } catch (t) {
                            v.e(t);
                        } finally {
                            v.f();
                        }
                    }
                } catch (t) {
                    s.e(t);
                } finally {
                    s.f();
                }
                r.lag = {
                    lagParams: c
                };
            }
            var m, g = Ze(r.lag.lagParams);
            try {
                for (g.s(); !(m = g.n()).done; ) {
                    var w, O = Xe(m.value, 2), S = O[0], _ = O[1], j = Ze(S);
                    try {
                        for (j.s(); !(w = j.n()).done; ) {
                            var P = w.value, A = n[P];
                            // Initialize lagged arrays only on the first index
                            if (0 === e) for (var E = 1; E <= _; E++) {
                                n["".concat(P, "_lag_").concat(E)] = Qe(o);
                            }
                            // Populate lagged values
                                                        for (var M = 1; M <= _; M++) {
                                var x = "".concat(P, "_lag_").concat(M), k = e - M, T = k <= 0 || void 0 === A[k] ? null : A[k];
                                t.pushToMain({
                                    index: e,
                                    key: x,
                                    value: T
                                });
                            }
                        }
                    } catch (t) {
                        j.e(t);
                    } finally {
                        j.f();
                    }
                }
            } catch (t) {
                g.e(t);
            } finally {
                g.f();
            }
            return !0;
        };
        // ./src/studies/findCrosses.js
        function or(t) {
            return function(t) {
                if (Array.isArray(t)) return ar(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || ir(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function ir(t, e) {
            if (t) {
                if ("string" == typeof t) return ar(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? ar(t, e) : void 0;
            }
        }
        function ar(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        function ur(t) {
            return ur = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, ur(t);
        }
        function lr(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, cr(n.key), n);
            }
        }
        function cr(t) {
            var e = function(t, e) {
                if ("object" != ur(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != ur(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == ur(e) ? e : e + "";
        }
        var sr = function(t, e) {
            return t > e;
        }, fr = function(t, e) {
            return t < e;
        }, hr =  function() {
            return t = function t() {
                !function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                }(this, t), Object.assign(this, {
                    interval: 0,
                    prevState: .5,
                    prevFast: null,
                    prevSlow: null,
                    prevHigh: null,
                    prevLow: null,
                    areHighAndLowUndefined: !1,
                    index: 0,
                    crossIndexes: {
                        up: [],
                        down: []
                    }
                });
            }, (e = [ {
                key: "update",
                value: function(t) {
                    var e = t.fast, r = t.high, n = t.slow, o = t.low, i = this.prevState;
                    this.areHighAndLowUndefined || void 0 !== r && void 0 !== o || (this.areHighAndLowUndefined = !0), 
                    null === e || null === n || function(t, e) {
                        return t === e;
                    }(e, n) ? i = .5 : sr(e, n) ? i = this.areHighAndLowUndefined ? 1 : [ o, n, this.prevLow, this.prevSlow ].every((function(t) {
                        return null !== t;
                    })) && fr(o, n) && sr(this.prevLow, this.prevSlow) ? 0 : 1 : fr(e, n) && (i = this.areHighAndLowUndefined ? 0 : [ r, n, this.prevHigh, this.prevSlow ].every((function(t) {
                        return null !== t;
                    })) && sr(r, n) && fr(this.prevHigh, this.prevSlow) ? 1 : 0), .5 === i ? this.interval = 0 : 1 === i ? this.prevState <= .5 ? this.interval = 1 : this.interval++ : 0 === i && (this.prevState >= .5 ? this.interval = -1 : this.interval--), 
                    1 === this.interval && this.crossIndexes.up.push(this.index), -1 === this.interval && this.crossIndexes.down.push(this.index), 
                    //save prev state
                    Object.assign(this, {
                        index: this.index + 1,
                        prevState: i,
                        prevFast: e,
                        prevSlow: n,
                        prevHigh: r,
                        prevLow: o
                    });
                }
            }, {
                key: "getResult",
                value: function() {
                    return this.interval;
                }
            } ]) && lr(t.prototype, e), r && lr(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
            var t, e, r;
        }(), yr = function(t, e) {
            var r = t.nullArray, n = t.verticalOhlcv, o = t.instances, i = t.len;
            if (0 === e) {
                var a = t.inputParams.filter((function(t) {
                    return "crossPairs" === t.key;
                }));
                if ("object" !== ur(a)) return;
                o.crossPairs = {
                    crossPairsList: a.flatMap((function(t) {
                        return t.params.flat();
                    }))
                };
            }
            var u, l = function(t, e) {
                var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (!r) {
                    if (Array.isArray(t) || (r = ir(t)) || e && t && "number" == typeof t.length) {
                        r && (t = r);
                        var n = 0, o = function() {};
                        return {
                            s: o,
                            n: function() {
                                return n >= t.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t[n++]
                                };
                            },
                            e: function(t) {
                                throw t;
                            },
                            f: o
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var i, a = !0, u = !1;
                return {
                    s: function() {
                        r = r.call(t);
                    },
                    n: function() {
                        var t = r.next();
                        return a = t.done, t;
                    },
                    e: function(t) {
                        u = !0, i = t;
                    },
                    f: function() {
                        try {
                            a || null == r.return || r.return();
                        } finally {
                            if (u) throw i;
                        }
                    }
                };
            }(o.crossPairs.crossPairsList);
            try {
                for (l.s(); !(u = l.n()).done; ) {
                    var c = u.value, s = c.fast, f = c.slow;
                    if (null != s && null != f) {
                        var h = "".concat(s, "_x_").concat(f);
                        if (0 === e) {
                            if ("number" == typeof f && (n[f] = new Array(i).fill(f)), "price" !== s && !n.hasOwnProperty(s)) throw Error('fast "'.concat(s, ' not found in crossPairs"'));
                            if (!n.hasOwnProperty(f)) throw Error('slow "'.concat(f, ' not found in crossPairs"'));
                            o[h] = new hr, n[h] = or(r);
                        }
                        var y = void 0, p = void 0, v = void 0, d = void 0, b = void 0;
                        "price" === s ? (p = n.close[e], v = n.high[e], d = n.low[e], b = n[f][e], o[h].update({
                            fast: p,
                            slow: b,
                            high: v,
                            low: d
                        })) : (y = n[s][e], b = n[f][e], o[h].update({
                            fast: y,
                            slow: b
                        })), t.pushToMain({
                            index: e,
                            key: h,
                            value: o[h].getResult()
                        });
                    }
                }
            } catch (t) {
                l.e(t);
            } finally {
                l.f();
            }
        };
        // ./src/studies/dateTime.js
        function pr(t) {
            return function(t) {
                if (Array.isArray(t)) return vr(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || function(t, e) {
                if (t) {
                    if ("string" == typeof t) return vr(t, e);
                    var r = {}.toString.call(t).slice(8, -1);
                    return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? vr(t, e) : void 0;
                }
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function vr(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        var dr = function(t) {
            var e = new Date(t), r = e.getMonth(), n = e.getFullYear(), o = e.getHours(), i = e.getMinutes(), a = e.getDay(), u = e.getDate(), l = new Date(e.getFullYear(), e.getMonth(), 1).getDay();
            return {
                month: r,
                year: n,
                hour: o,
                minute: i,
                day_of_the_week: a,
                day_of_the_month: u,
                week_of_the_month: Math.ceil((u + l) / 7)
            };
        };
        // ./src/studies/priceVariations.js
        function br(t) {
            return function(t) {
                if (Array.isArray(t)) return mr(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || function(t, e) {
                if (t) {
                    if ("string" == typeof t) return mr(t, e);
                    var r = {}.toString.call(t).slice(8, -1);
                    return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? mr(t, e) : void 0;
                }
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function mr(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        var gr = [ "open", "high", "low", "close" ];
        function wr(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = jr(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == r.return || r.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function Or(t, e) {
            if (null == t) return {};
            var r, n, o = function(t, e) {
                if (null == t) return {};
                var r = {};
                for (var n in t) if ({}.hasOwnProperty.call(t, n)) {
                    if (e.includes(n)) continue;
                    r[n] = t[n];
                }
                return r;
            }(t, e);
            if (Object.getOwnPropertySymbols) {
                var i = Object.getOwnPropertySymbols(t);
                for (n = 0; n < i.length; n++) r = i[n], e.includes(r) || {}.propertyIsEnumerable.call(t, r) && (o[r] = t[r]);
            }
            return o;
        }
        function Sr(t) {
            return function(t) {
                if (Array.isArray(t)) return Pr(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || jr(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function _r(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }
            // Map indicator keys to their respective functions
            (t) || function(t, e) {
                var r = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != r) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (r = r.call(t)).next, 0 === e) {
                            if (Object(r) !== r) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(r)).done) && (u.push(n.value), u.length !== e); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != r.return && (a = r.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, e) || jr(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function jr(t, e) {
            if (t) {
                if ("string" == typeof t) return Pr(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Pr(t, e) : void 0;
            }
        }
        function Pr(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        var Ar = {
            dateTime: function(t, e) {
                var r = t.instances, n = t.verticalOhlcv;
                if (0 === e) {
                    var o = t.nullArray;
                    if (!t.isValidDate) throw Error('dateTime method found and invalid "date" in input ohlcv');
                    var i = n.date[0].slice(0, 10);
                    Object.assign(r, {
                        dateTime: {
                            prevDateStr: i,
                            sessionDailyIndexCount: 0,
                            sessionIntradayIndexCount: 0,
                            cachedDayInfo: i
                        }
                    }), Object.assign(n, {
                        day_of_the_week: pr(o),
                        day_of_the_month: pr(o),
                        week_of_the_month: pr(o),
                        hour: pr(o),
                        month: pr(o),
                        year: pr(o),
                        session_daily_index: pr(o),
                        session_intraday_index: pr(o)
                    });
                }
                var a = n.date[e], u = dr(a), l = u.day_of_the_week, c = u.day_of_the_month, s = u.week_of_the_month, f = u.month, h = u.year, y = u.hour, p = a.slice(0, 10);
                p !== r.dateTime.prevDateStr && (r.dateTime.prevDateStr = p, r.dateTime.sessionDailyIndexCount++, 
                r.dateTime.sessionIntradayIndexCount = 0), t.pushToMain({
                    index: e,
                    key: "session_daily_index",
                    value: r.dateTime.sessionDailyIndexCount
                }), t.pushToMain({
                    index: e,
                    key: "session_intraday_index",
                    value: r.dateTime.sessionIntradayIndexCount
                }), t.pushToMain({
                    index: e,
                    key: "day_of_the_week",
                    value: l
                }), t.pushToMain({
                    index: e,
                    key: "day_of_the_month",
                    value: c
                }), t.pushToMain({
                    index: e,
                    key: "week_of_the_month",
                    value: s
                }), t.pushToMain({
                    index: e,
                    key: "month",
                    value: f
                }), t.pushToMain({
                    index: e,
                    key: "year",
                    value: h
                }), t.pushToMain({
                    index: e,
                    key: "hour",
                    value: y
                }), r.dateTime.sessionIntradayIndexCount++;
            },
            priceVariations: function(t, e) {
                0 === e && (t.priceBased = br(new Set([].concat(br(t.priceBased), [ "mid_price_open_close", "mid_price_high_low" ]))), 
                Object.assign(t.verticalOhlcv, {
                    mid_price_open_close: br(t.nullArray),
                    mid_price_high_low: br(t.nullArray)
                }));
                var r = t.verticalOhlcv.open[e], n = t.verticalOhlcv.high[e], o = t.verticalOhlcv.low[e], i = t.verticalOhlcv.close[e];
                t.pushToMain({
                    index: e,
                    key: "mid_price_open_close",
                    value: (r + i) / 2
                }), t.pushToMain({
                    index: e,
                    key: "mid_price_high_low",
                    value: (n + o) / 2
                });
            },
            rsi: function(t, e, r, n) {
                var o = n.scale, i = n.target, a = n.lag, u = n.autoMinMax, l = t.verticalOhlcv, c = t.instances, s = t.lastIndexReplace, f = "close" === i ? "" : "_".concat(i), h = "rsi_".concat(r).concat(f), y = "rsi_sma_".concat(r).concat(f);
                // Initialization on the first index.
                if (0 === e) {
                    var p = t.crossPairsList, v = t.nullArray;
                    if (!l.hasOwnProperty(i)) throw new Error("Target property ".concat(i, " not found in verticalOhlcv for rsi."));
                    p.push({
                        fast: h,
                        slow: y,
                        isDefault: !0
                    }), Object.assign(c, le(le({}, h, new te(r)), y, new nt(r))), Object.assign(l, le(le({}, h, ae(v)), y, ae(v))), 
                    a > 0 && t.lag([ h, y ], a), u && t.autoMinMaxKeys.push(h, y);
                }
                var d = l[i][e], b = null, m = null;
                // Update the RSI indicator.
                c[h].update(d, s);
                try {
                    b = c[h].getResult();
                } catch (t) {
                    b = null;
                }
                null !== b && "number" == typeof b && o && (b = ne(b, o)), 
                // Always push the RSI value, using null as a fallback.
                t.pushToMain({
                    index: e,
                    key: h,
                    value: b
                }), 
                // Update the SMA indicator only if a valid RSI value is available.
                null !== b && "number" == typeof b && c[y].update(b, s);
                try {
                    m = c[y].getResult();
                } catch (t) {
                    m = null;
                }
                null !== m && "number" == typeof m && o && (m = ne(m, o)), 
                // Always push the smoothed RSI value.
                t.pushToMain({
                    index: e,
                    key: y,
                    value: m
                });
            },
            movingAverages: function(t, e, r, n, o) {
                var i = o.target, a = o.diff, u = (o.autoMinMax, t.verticalOhlcv), l = t.instances, c = t.priceBased, s = t.lastIndexReplace, f = "string" == typeof i && u.hasOwnProperty(i) && "close" !== i ? "_".concat(i) : "", h = "".concat(r, "_").concat(n).concat(f), y = "".concat(r, "_").concat(n, "_diff").concat(f);
                if (0 === e) {
                    var p = t.nullArray;
                    if (!u.hasOwnProperty(i)) throw new Error("Target property ".concat(i, " not found in verticalOhlcv for ").concat(r, "."));
                    // Create the main moving average instance.
                                        // If diff configuration is provided, create the diff indicator.
                    if (l[h] = {
                        maInstance: new ve[r](n)
                    }, u[h] = he(p), null !== a) {
                        l[h].diffInstance = new _t(a.size, a.stdDev);
                        var v, d = [], b = fe(a.targets);
                        try {
                            for (b.s(); !(v = b.n()).done; ) {
                                var m = v.value;
                                u["".concat(y, "_").concat(m)] = he(p), a.autoMinMax && t.autoMinMaxKeys.push("".concat(y, "_").concat(m)), 
                                a.lag > 0 && d.push("".concat(y, "_").concat(m));
                            }
                        } catch (t) {
                            b.e(t);
                        } finally {
                            b.f();
                        }
                        a.lag > 0 && t.lag(d, a.lag);
                    }
                    c.push(h);
                }
                // Retrieve the current price value.
                                var g = u[i][e], w = l[h], O = w.maInstance, S = w.diffInstance;
                // Update the moving average instance.
                O.update(g, s);
                var _ = null;
                try {
                    _ = O.getResult();
                } catch (t) {
                    _ = null;
                }
                // Always push the MA value (even if null).
                                // Process the diff values if a diff is requested.
                if (t.pushToMain({
                    index: e,
                    key: h,
                    value: _
                }), null !== a) {
                    var j, P = fe(a.targets);
                    try {
                        for (P.s(); !(j = P.n()).done; ) {
                            var A = j.value, E = null;
                            // Compute diffValue only if we have a valid MA value.
                                                        null !== _ && "number" == typeof _ && (E = u[A][e] - _), 
                            // Update the diff indicator only if diffValue is a valid number.
                            null !== E && "number" == typeof E && S.update(Math.abs(E), s);
                            var M = null;
                            try {
                                M = S.getResult();
                            } catch (t) {
                                M = null;
                            }
                            var x = ce(E, M, a.scale, a.autoMinMax);
                            t.pushToMain({
                                index: e,
                                key: "".concat(y, "_").concat(A),
                                value: x
                            });
                        }
                    } catch (t) {
                        P.e(t);
                    } finally {
                        P.f();
                    }
                }
                return !0;
            },
            macd: function(t, e, r, n, o, i) {
                var a = i.target, u = t.verticalOhlcv, l = t.instances, c = t.lastIndexReplace, s = "".concat(r, "_").concat(n, "_").concat(o).concat(a === Oe ? "" : "_".concat(a));
                // Initialization on the first index.
                if (0 === e) {
                    var f = t.inputParams, h = t.crossPairsList, y = t.nullArray, p = t.priceBased;
                    if (!u.hasOwnProperty(a)) throw new Error("Target property ".concat(a, " not found in verticalOhlcv for macd."));
                    var v = f.filter((function(t) {
                        return "macd" === t.key;
                    })).length, d = v > 1 ? "macd_".concat(r, "_").concat(n, "_").concat(o) : "macd", b = a === Oe ? "".concat(d, "_diff") : "".concat(d, "_diff_").concat(a), m = a === Oe ? "".concat(d, "_dea") : "".concat(d, "_dea_").concat(a), g = a === Oe ? "".concat(d, "_histogram") : "".concat(d, "_histogram_").concat(a);
                    // Choose a display prefix based on the number of indicators.
                                        h.push({
                        fast: b,
                        slow: m,
                        isDefault: !0
                    }), l.hasOwnProperty("macd") || (l.macd = {
                        numberOfIndicators: v,
                        settings: {}
                    }), l.macd.settings[s] = new qt(new Dt(r), new Dt(n), new Dt(o)), Object.assign(u, me(me(me({}, b, ge(y)), m, ge(y)), g, ge(y))), 
                    p.push(b, m, g);
                }
                var w = l.macd, O = w.numberOfIndicators, S = w.settings, _ = O > 1 ? "macd_".concat(r, "_").concat(n, "_").concat(o) : "macd", j = a === Oe ? "".concat(_, "_diff") : "".concat(_, "_diff_").concat(a), P = a === Oe ? "".concat(_, "_dea") : "".concat(_, "_dea_").concat(a), A = a === Oe ? "".concat(_, "_histogram") : "".concat(_, "_histogram_").concat(a), E = S[s], M = u[a][e];
                E.update(M, c);
                var x = null;
                try {
                    x = E.getResult();
                } catch (t) {
                    // If the result is unavailable, macdResult remains null.
                    x = null;
                }
                // Always push values; use null as fallback when macdResult is missing.
                                return t.pushToMain({
                    index: e,
                    key: j,
                    value: x ? x.macd : null
                }), t.pushToMain({
                    index: e,
                    key: P,
                    value: x ? x.signal : null
                }), t.pushToMain({
                    index: e,
                    key: A,
                    value: x ? x.histogram : null
                }), !0;
            },
            relativeVolume: function(t, e) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, n = (arguments.length > 3 ? arguments[3] : void 0).scale, o = "relative_volume_".concat(r), i = t.instances, a = t.verticalOhlcv, u = t.lastIndexReplace;
                if (0 === e) {
                    var l = t.nullArray;
                    i[o] = {
                        instance: new nt(r),
                        prevRelativeVolumeSma: null
                    }, a[o] = Se(l);
                }
                var c = a.volume[e], s = i[o].instance;
                s.update(c, u);
                var f = null;
                try {
                    f = s.getResult();
                } catch (t) {
                    f = null;
                }
                var h = i[o].prevRelativeVolumeSma, y = null;
                // Only calculate relative volume if both current SMA and previous SMA are valid numbers and prevSma is not zero.
                return "number" == typeof f && "number" == typeof h && 0 !== h && (y = c / h, n && (y = ne(y, n))), 
                t.pushToMain({
                    index: e,
                    key: o,
                    value: y
                }), i[o].prevRelativeVolumeSma = f, !0;
            },
            donchianChannels: function(t, e, r, n, o) {
                var i = o.height, a = o.range, u = o.scale, l = o.lag, c = o.autoMinMax, s = "".concat(r, "_").concat(n), f = t.verticalOhlcv, h = t.instances, y = t.len;
                // Initialization: create output arrays and indicator instance on the first call.
                if (0 === e) {
                    var p = t.inputParams, v = t.priceBased, d = t.nullArray, b = p.filter((function(t) {
                        return "donchianChannels" === t.key;
                    })).length, m = b > 1 ? "donchian_channel_".concat(s) : "donchian_channel", g = [ "".concat(m, "_upper"), "".concat(m, "_basis"), "".concat(m, "_lower") ];
                    i && g.push("".concat(m, "_height")), h.hasOwnProperty("donchian_channel") || (h.donchian_channel = {
                        numberOfIndicators: b,
                        settings: {}
                    });
                    // Set up additional arrays for each range property.
                    var w, O = Me(a);
                    try {
                        for (O.s(); !(w = O.n()).done; ) {
                            var S = w.value;
                            if (!(S in f) || !v.includes(S)) throw new Error('Invalid range item value "'.concat(S, '" property for donchianChannels. Only price based key names are accepted:\n').concat(JSON.stringify(v)));
                            g.push("".concat(m, "_range_").concat(S)), c && t.autoMinMaxKeys.push("".concat(m, "_range_").concat(S));
                        }
                    } catch (t) {
                        O.e(t);
                    } finally {
                        O.f();
                    }
                    var _ = Object.fromEntries(g.map((function(t) {
                        return [ t, Ee(d) ];
                    })));
                    Object.assign(f, function(t) {
                        for (var e = 1; e < arguments.length; e++) {
                            var r = null != arguments[e] ? arguments[e] : {};
                            e % 2 ? Pe(Object(r), !0).forEach((function(e) {
                                Ae(t, e, r[e]);
                            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Pe(Object(r)).forEach((function(e) {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));
                            }));
                        }
                        return t;
                    }({}, _)), l > 0 && t.lag(g, l), v.push("".concat(m, "_upper"), "".concat(m, "_basis"), "".concat(m, "_lower")), 
                    h.donchian_channel.settings[s] = {
                        maxDeque: [],
                        // will hold indices for highs in descending order
                        minDeque: []
                    };
                }
                var j = h.donchian_channel.numberOfIndicators > 1 ? "donchian_channel_".concat(s) : "donchian_channel", P = h.donchian_channel.settings[s], A = P.maxDeque, E = P.minDeque, M = e - n, x = M + 1, k = x - r;
                // window: [startIdx, endIdx)
                // If the window is not fully available, push null values for all computed outputs.
                if (k < 0 || x > y) {
                    t.pushToMain({
                        index: e,
                        key: "".concat(j, "_upper"),
                        value: null
                    }), t.pushToMain({
                        index: e,
                        key: "".concat(j, "_basis"),
                        value: null
                    }), t.pushToMain({
                        index: e,
                        key: "".concat(j, "_lower"),
                        value: null
                    }), i && t.pushToMain({
                        index: e,
                        key: "".concat(j, "_height"),
                        value: null
                    });
                    var T, I = Me(a);
                    try {
                        for (I.s(); !(T = I.n()).done; ) {
                            var C = T.value;
                            t.pushToMain({
                                index: e,
                                key: "".concat(j, "_range_").concat(C),
                                value: null
                            });
                        }
                    } catch (t) {
                        I.e(t);
                    } finally {
                        I.f();
                    }
                    return !0;
                }
                // **Update the maximum deque:**
                for (var R = f.high, D = f.low; A.length && A[0] < k; ) A.shift();
                for (;A.length && R[A[A.length - 1]] <= R[M]; ) A.pop();
                // **Update the minimum deque:**
                for (A.push(M); E.length && E[0] < k; ) E.shift();
                for (;E.length && D[E[E.length - 1]] >= D[M]; ) E.pop();
                E.push(M);
                // Retrieve computed values with safety checks.
                var V = A.length ? R[A[0]] : null, B = E.length ? D[E[0]] : null, N = "number" == typeof V && "number" == typeof B ? (V + B) / 2 : null;
                // Process height if enabled.
                if (
                // Always push the main indicator values.
                t.pushToMain({
                    index: e,
                    key: "".concat(j, "_upper"),
                    value: V
                }), t.pushToMain({
                    index: e,
                    key: "".concat(j, "_basis"),
                    value: N
                }), t.pushToMain({
                    index: e,
                    key: "".concat(j, "_lower"),
                    value: B
                }), i) {
                    var L = null;
                    "number" == typeof V && "number" == typeof B && 0 !== B && (L = ne((V - B) / B, .001)), 
                    t.pushToMain({
                        index: e,
                        key: "".concat(j, "_height"),
                        value: L
                    });
                }
                // Process each range property.
                                var H, U = Me(a);
                try {
                    for (U.s(); !(H = U.n()).done; ) {
                        var q = H.value, z = null, $ = f[q][e];
                        "number" == typeof $ && "number" == typeof V && "number" == typeof B && V - B != 0 && (z = c ? Math.max(Math.min(($ - B) / (V - B), 1), 0) : ($ - B) / (V - B), 
                        u && (z = ne(z, u))), t.pushToMain({
                            index: e,
                            key: "".concat(j, "_range_").concat(q),
                            value: z
                        });
                    }
                } catch (t) {
                    U.e(t);
                } finally {
                    U.f();
                }
                return !0;
            },
            bollingerBands: function(t, e, r, n, o) {
                var i, a, u, l, c, s, f, h = o.height, y = o.range, p = void 0 === y ? [] : y, v = o.target, d = o.scale, b = o.lag, m = o.autoMinMax, g = t.verticalOhlcv, w = t.instances, O = t.lastIndexReplace, S = "close" === v ? "" : "_".concat(v), _ = "".concat(r, "_").concat(n).concat(S);
                // Initialization on the first call.
                if (0 === e) {
                    var j = t.priceBased, P = t.inputParams, A = t.nullArray, E = t.verticalOhlcv;
                    if (!(v in E)) throw new Error('bollingerBands could not find target "'.concat(v, '"'));
                    var M = P.filter((function(t) {
                        return "bollingerBands" === t.key;
                    })).length;
                    f = M > 1 ? "bollinger_bands_".concat(_) : "bollinger_bands".concat(S), 
                    // Only create the container if it doesn't already exist.
                    w.bollinger_bands || (w.bollinger_bands = {
                        numberOfIndicators: M,
                        settings: {}
                    }), 
                    // Add (or override) the indicator instance keyed by indicatorKey.
                    w.bollinger_bands.settings[_] = new _t(r, n);
                    var x = [ "".concat(f, "_upper"), "".concat(f, "_middle"), "".concat(f, "_lower") ];
                    h && x.push("".concat(f, "_height"));
                    // Set up additional arrays for each range property.
                                        var k, T = De(p);
                    try {
                        for (T.s(); !(k = T.n()).done; ) {
                            var I = k.value;
                            if (!(I in E) || !j.includes(I)) throw new Error('Invalid range item value "'.concat(I, '" property for bollingerBands. Only price based key names are accepted:\n').concat(JSON.stringify(j)));
                            x.push("".concat(f, "_range_").concat(I)), m && t.autoMinMaxKeys.push("".concat(f, "_range_").concat(I));
                        }
                    } catch (t) {
                        T.e(t);
                    } finally {
                        T.f();
                    }
                    var C = Object.fromEntries(x.map((function(t) {
                        return [ t, Re(A) ];
                    })));
                    Object.assign(E, function(t) {
                        for (var e = 1; e < arguments.length; e++) {
                            var r = null != arguments[e] ? arguments[e] : {};
                            e % 2 ? Ie(Object(r), !0).forEach((function(e) {
                                Ce(t, e, r[e]);
                            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Ie(Object(r)).forEach((function(e) {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));
                            }));
                        }
                        return t;
                    }({}, C)), b > 0 && t.lag(x, b), j.push("".concat(f, "_upper"), "".concat(f, "_middle"), "".concat(f, "_lower"));
                }
                // Derive prefix for subsequent calls if not set.
                                f || (f = w.bollinger_bands.numberOfIndicators > 1 ? "bollinger_bands_".concat(_) : "bollinger_bands".concat(S));
                var R = f, D = w.bollinger_bands.settings[_], V = g[v][e];
                // Update the indicator with the current value.
                                D.update(V, O);
                // Attempt to retrieve the result.
                var B = null;
                try {
                    B = D.getResult();
                } catch (t) {
                    // If not available, result stays null.
                }
                // Use null fallbacks for the primary values.
                                var N = null !== (i = null === (a = B) || void 0 === a ? void 0 : a.upper) && void 0 !== i ? i : null, L = null !== (u = null === (l = B) || void 0 === l ? void 0 : l.middle) && void 0 !== u ? u : null, H = null !== (c = null === (s = B) || void 0 === s ? void 0 : s.lower) && void 0 !== c ? c : null;
                // Process height if requested.
                if (
                // Always push the indicator outputs.
                t.pushToMain({
                    index: e,
                    key: "".concat(R, "_upper"),
                    value: N
                }), t.pushToMain({
                    index: e,
                    key: "".concat(R, "_middle"),
                    value: L
                }), t.pushToMain({
                    index: e,
                    key: "".concat(R, "_lower"),
                    value: H
                }), h) {
                    var U = null;
                    "number" == typeof N && "number" == typeof H && 0 !== H && (U = ne((N - H) / H, .001)), 
                    t.pushToMain({
                        index: e,
                        key: "".concat(R, "_height"),
                        value: U
                    });
                }
                // Process each range property.
                                var q, z = De(p);
                try {
                    for (z.s(); !(q = z.n()).done; ) {
                        var $ = q.value, F = null, K = g[$][e];
                        "number" == typeof K && "number" == typeof H && "number" == typeof N && N - H != 0 && (F = m ? Math.max(Math.min((K - H) / (N - H), 1), 0) : (K - H) / (N - H), 
                        d && (F = ne(F, d))), t.pushToMain({
                            index: e,
                            key: "".concat(R, "_range_").concat($),
                            value: F
                        });
                    }
                } catch (t) {
                    z.e(t);
                } finally {
                    z.f();
                }
                return !0;
            },
            volumeOscillator: function(t, e, r, n, o) {
                var i = o.scale, a = t.verticalOhlcv, u = t.instances, l = t.lastIndexReplace, c = a.volume[e], s = "volume_oscillator";
                if (0 === e) {
                    var f = t.crossPairsList, h = t.nullArray;
                    Object.assign(u, {
                        volume_oscillator: {
                            fastEMA: new Dt(r),
                            slowEMA: new Dt(n)
                        }
                    }), a[s] = Ne(h), f.push({
                        fast: s,
                        slow: 0,
                        isDefault: !0
                    });
                }
                var y = u[s], p = y.fastEMA, v = y.slowEMA;
                p.update(c, l), v.update(c, l);
                var d = null, b = null;
                try {
                    d = p.getResult();
                } catch (t) {
                    d = null;
                }
                try {
                    b = v.getResult();
                } catch (t) {
                    b = null;
                }
                var m = null;
                return "number" == typeof d && "number" == typeof b && 0 !== b && (m = 100 * (d - b) / b, 
                i && (m = ne(m, i))), t.pushToMain({
                    index: e,
                    key: s,
                    value: m
                }), !0;
            },
            candleVectors: function(t, e, r, n) {
                var o = n.patternSize, i = n.lag, a = n.autoMinMax, u = t.verticalOhlcv, l = t.instances, c = t.lastIndexReplace;
                if (0 === e) {
                    for (var s = t.nullArray, f = [ [ "close", "open" ], [ "close", "high" ], [ "close", "low" ], [ "open", "high" ], [ "open", "low" ], [ "high", "low" ] ], h = [ [ "open", "open" ], [ "high", "high" ], [ "low", "low" ], [ "close", "close" ] ].concat(f), y = [], p = {}, v = 0; v < o; v++) {
                        var d, b = Ke(h);
                        try {
                            for (b.s(); !(d = b.n()).done; ) {
                                var m = Fe(d.value, 2), g = m[0], w = m[1];
                                y.push("candle_change_".concat(v + 1, "_").concat(g, "_").concat(w)), p["candle_change_".concat(v + 1, "_").concat(g, "_").concat(w)] = $e(s), 
                                a && t.autoMinMaxKeys.push("candle_change_".concat(v + 1, "_").concat(g, "_").concat(w));
                            }
                        } catch (t) {
                            b.e(t);
                        } finally {
                            b.f();
                        }
                    }
                    for (var O = [], S = {}, _ = 0, j = f; _ < j.length; _++) {
                        var P = Fe(j[_], 2), A = P[0], E = P[1];
                        O.push("candle_body_".concat(A, "_").concat(E)), S["candle_body_".concat(A, "_").concat(E)] = $e(s), 
                        a && t.autoMinMaxKeys.push("candle_body_".concat(A, "_").concat(E));
                    }
                    var M = [].concat(O, y);
                    Object.assign(u, qe(qe({}, S), p)), Object.assign(l, {
                        candleVectors: {
                            bodyVectors: f,
                            lookBackVectors: h,
                            keyNames: M,
                            arrayChunk: qe({}, Object.fromEntries(M.map((function(t) {
                                return [ t, [] ];
                            }))))
                        }
                    }), i > 0 && t.lag(M, i);
                }
                for (var x = l.candleVectors, k = x.bodyVectors, T = x.lookBackVectors, I = x.arrayChunk, C = 0; C < k.length; C++) {
                    var R = Fe(k[C], 2), D = R[0], V = R[1], B = u[D][e], N = u[V][e], L = "candle_body_".concat(D, "_").concat(V), H = We(B, N), U = Ye(I, L, r, H, c);
                    t.pushToMain({
                        index: e,
                        key: L,
                        value: U
                    });
                }
                for (var q = 0; q < o; q++) {
                    var z, $ = Ke(T);
                    try {
                        for ($.s(); !(z = $.n()).done; ) {
                            var F = Fe(z.value, 2), K = F[0], G = F[1], J = u[K][e], W = u[G][e - (q + 1)], Y = "candle_change_".concat(q + 1, "_").concat(K, "_").concat(G);
                            if (void 0 !== W) {
                                var Q = We(J, W), X = Ye(I, Y, r, Q, c);
                                t.pushToMain({
                                    index: e,
                                    key: Y,
                                    value: X
                                });
                            } else t.pushToMain({
                                index: e,
                                key: Y,
                                value: null
                            });
                        }
                    } catch (t) {
                        $.e(t);
                    } finally {
                        $.f();
                    }
                }
                return !0;
            }
        }, Er = function(t, e, r) {
            var n = function(t) {
                return r > 1 ? t * r : t;
            };
            if ("number" === e) return n(t);
            if ("string" === e) {
                var o = oe(t);
                return n(Number(o));
            }
            return 0;
 // Optionally: throw an error if type is not recognized
                }, Mr = function(t, e) {
            return "number" === e ? t : "string" === e ? Number(oe(t)) : 0;
        }, xr = function(t, e) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, o = e.len, i = e.inputParams, a = e.hasVolume;
            //do not move nullArray from here
            e.nullArray = new Array(o).fill(null);
            var u = [ "open", "high", "low", "close" ];
            a && u.push("volume");
            var l = new Set(u);
            if (0 === n) {
                // Validate parameters and initialize base keys in verticalOhlcv
                !function(t) {
                    var e, n = t.inputParams, o = t.len, i = r(n);
                    try {
                        for (i.s(); !(e = i.n()).done; ) {
                            var a, u = r(e.value.params);
                            try {
                                for (u.s(); !(a = u.n()).done; ) {
                                    var l = a.value;
                                    if ("number" == typeof l && l > o) throw console.log(l, o), new Error("At least one of the params of the indicator is greater than the input OHLCV length. Make sure to have enough datapoints in the input OHLCV.");
                                }
                            } catch (t) {
                                u.e(t);
                            } finally {
                                u.f();
                            }
                        }
                    } catch (t) {
                        i.e(t);
                    } finally {
                        i.f();
                    }
                }(e), u.forEach((function(t) {
                    e.verticalOhlcv[t] = Sr(e.nullArray);
                }));
                // Identify any additional keys from the first input row and initialize them
                var c = Object.keys(t[0]).filter((function(t) {
                    return !l.has(t);
                }));
                c.forEach((function(t) {
                    e.verticalOhlcv[t] = Sr(e.nullArray);
                })), e.otherKeys = c, 
                // Set the input types once using the first row
                function(t, e) {
                    for (var r = 0, n = Object.keys(e.inputTypes); r < n.length; r++) {
                        var o = n[r];
                        if (!(o in t)) throw new Error('Property "'.concat(o, '" not found in ohlcv array. ').concat(e.ticker));
                        var i = t[o];
                        if ("number" == typeof i && i > 0) e.inputTypes[o] = "number"; else {
                            if ("string" != typeof i || !/^(\d+(\.\d*)?|\.\d+)$/.test(i)) throw new Error('Invalid property "'.concat(o, '" in ohlcv array. ').concat(e.ticker));
                            // Determine precisionMultiplier if not already set
                                                        e.inputTypes[o] = "string", i = oe(i);
                        }
                        if (0 === e.precisionMultiplier && !0 === e.precision) {
                            var a = _r(String(i).split("."), 2)[1], u = void 0 === a ? "" : a, l = Math.max(4, u.length);
                            e.precisionMultiplier = l > 1 ? Math.pow(10, l - 1) : 1;
                        }
                    }
                }(t[0], e);
            } else if (!e.otherKeys) throw new Error("otherKeys not found in main. Ensure you run with startIndex=0 first to initialize.");
            // Prepare the list of indicator function calls
                        // Process each row in the input
            for (var s = function(t) {
                return Array.isArray(t) ? t.map((function(t) {
                    var e = t.key, r = t.params;
                    return {
                        key: e,
                        fn: Ar[e],
                        args: r
                    };
                })) : [];
            }(i), f = n; f < o; f++) {
                var h = t[f], y = h.open, p = h.high, v = h.low, d = h.close, b = Or(h, gr), m = e.precisionMultiplier, g = Er(y, e.inputTypes.open, m), w = Er(p, e.inputTypes.high, m), O = Er(v, e.inputTypes.low, m), S = Er(d, e.inputTypes.close, m);
                // Destructure the base keys and use the rest for other properties
                //sets volume to 0
                                if (e.pushToMain({
                    index: f,
                    key: "open",
                    value: g
                }), e.pushToMain({
                    index: f,
                    key: "high",
                    value: w
                }), e.pushToMain({
                    index: f,
                    key: "low",
                    value: O
                }), e.pushToMain({
                    index: f,
                    key: "close",
                    value: S
                }), a) {
                    var _ = h.volume, j = Mr(_, e.inputTypes.volume);
                    e.pushToMain({
                        index: f,
                        key: "volume",
                        value: j
                    });
                } else delete b.volume;
                // Populate any extra keys identified during initialization
                                var P, A = wr(e.otherKeys);
                try {
                    for (A.s(); !(P = A.n()).done; ) {
                        var E = P.value;
                        e.pushToMain({
                            index: f,
                            key: E,
                            value: b[E]
                        });
                    }
                    // Run all indicator functions except for the ones processed later
                                } catch (t) {
                    A.e(t);
                } finally {
                    A.f();
                }
                var M, x = wr(s);
                try {
                    for (x.s(); !(M = x.n()).done; ) {
                        var k = M.value, T = k.key, I = k.fn, C = k.args;
                        [ "crossPairs", "lag" ].includes(T) || I.apply(void 0, [ e, f ].concat(Sr(C)));
                    }
                    // Process these indicators separately (ensuring their execution order)
                                } catch (t) {
                    x.e(t);
                } finally {
                    x.f();
                }
                nr(e, f), yr(e, f), e.lastComputedIndex++;
            }
        }, kr = function(t, e) {
            for (var r = t.length, n = new nt(e), o = new Array(r), i = 0, a = 0, u = 0, l = 0; l < r; l++) if (n.update(t[l]), 
            n.isStable) {
                var c = n.getResult();
                o[l] = c, i += c, a += c * c, u++;
            } else o[l] = null;
            var s = i / u, f = a / u - s * s, h = Math.sqrt(f);
            return o.map((function(t) {
                return null !== t ? (t - s) / h : null;
            }));
        }, Tr = function(t, e) {
            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5;
            if (t.length !== e.length) throw new Error("Both arrays must have the same length");
            for (var n = kr(t, r), o = kr(e, r), i = t.length, a = [], u = 0, l = 0, c = 0, s = 0, f = 0, h = 0, y = -1, p = 0; p < i; p++) {
                if (null !== n[p] && null !== o[p]) {
                    y = p;
                    break;
                }
                a.push(0);
            }
            if (-1 === y) 
            // No valid data points
            return new Array(i).fill(0);
            for (var v = y; v < i; v++) {
                var d = n[v], b = o[v];
                if (null !== d && null !== b) if (u += d, l += b, c += d * b, s += d * d, f += b * b, 
                ++h < 2) a.push(0); else {
                    var m = h * c - u * l, g = Math.sqrt((h * s - u * u) * (h * f - l * l)), w = 0 === g ? 0 : m / g;
                    a.push(w);
                } else 
                // Reset sums and counts when encountering null values
                u = l = c = s = f = h = 0, a.push(0);
            }
            return a;
        };
        // Processes the inputParams into a list of indicator calls
                // ./index.js
        function Ir(t) {
            return function(t) {
                if (Array.isArray(t)) return Vr(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || Dr(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Cr(t) {
            return Cr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Cr(t);
        }
        function Rr(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, e) {
                var r = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != r) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (r = r.call(t)).next, 0 === e) {
                            if (Object(r) !== r) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(r)).done) && (u.push(n.value), u.length !== e); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != r.return && (a = r.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, e) || Dr(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Dr(t, e) {
            if (t) {
                if ("string" == typeof t) return Vr(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Vr(t, e) : void 0;
            }
        }
        function Vr(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        function Br(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, Nr(n.key), n);
            }
        }
        function Nr(t) {
            var e = function(t, e) {
                if ("object" != Cr(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != Cr(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }
            /**
 * Class OHLCV_INDICATORS
 *
 * This class provides methods for calculating and managing technical indicators 
 * on financial OHLCV (Open, High, Low, Close, Volume) data. It enables users 
 * to parallel compute various technical indicators in 1 single loop.
 * OHLCV datasets.
 */ (t, "string");
            return "symbol" == Cr(e) ? e : e + "";
        }
        var Lr = [ .001, .002, .0025, .005, .01, .02, .025, .05, .1, .2, .25, .5, 1, 2, 2.5, 5, 10 ], Hr =  function() {
            return t = function t(e) {
                var r = this, n = e.input, o = e.ticker, i = void 0 === o ? null : o, a = e.precision, u = void 0 === a || a, l = e.inputParams, c = void 0 === l ? null : l;
                if (function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                }(this, t), !Array.isArray(n)) throw Error("input OHLCV must be an array: " + i);
                if (0 === n.length) throw Error("input OHLCV must not be empty: " + i);
                if (!n[0].hasOwnProperty("close")) throw Error("input OHLCV array objects require at least close property: " + i);
                return this.hasVolume = !!("number" == typeof n[0].volume && n[0].volume > 0 || "string" == typeof n[0].volume && n[0].volume), 
                this.isComputed = !1, this.lastComputedIndex = 0, this.input = n, this.inputTypes = this.hasVolume ? {
                    open: "",
                    high: "",
                    low: "",
                    close: "",
                    volume: ""
                } : {
                    open: "",
                    high: "",
                    low: "",
                    close: ""
                }, this.priceBased = [ "open", "high", "low", "close" ], this.len = n.length, this.lastIndexReplace = !1, 
                this.instances = {}, this.crossPairsList = [], this.verticalOhlcv = {}, this.studies = {}, 
                this.utilities = {
                    correlation: Tr
                }, this.invalidValueIndex = -1, this.precision = u, this.precisionMultiplier = !0 === this.precision ? 0 : 1, 
                this.autoMinMaxKeys = [], this.minMaxRanges = {}, Array.isArray(c) && (this.inputParams = c, 
                this.compute()), this.inputParams = [], this.pushToMain = function(t) {
                    var e = t.index, n = t.key, o = t.value;
                    return function(t) {
                        var e = t.main, r = t.index, n = t.key, o = t.value, i = e.precision, a = e.priceBased, u = e.minMaxRanges, l = e.verticalOhlcv, c = e.autoMinMaxKeys, s = e.precisionMultiplier;
                        if (null == o) {
                            e.invalidValueIndex = r;
                            //do not use let for main.invalidValueIndex
                            for (var f = 0, h = Object.keys(u); f < h.length; f++) u[h[f]] = {
                                min: 1 / 0,
                                max: -1 / 0
                            };
                            return l[n][r] = null, !1;
                        }
                        if (l[n][r] = o, "number" == typeof o && !n.includes("_x_")) {
                            var y = c.includes(n);
                            if (n.includes("_diff_") && y) u.hasOwnProperty(n) && u[n].min !== 1 / 0 && u[n].max !== -1 / 0 || (u[n] = {
                                min: -1,
                                max: 1
                            }); else if (n.startsWith("candle_") && y) u[n] = {
                                min: -3,
                                max: 3
                            }; else if (n.includes("_range_") && y) u[n] = {
                                min: 0,
                                max: 1
                            }; else if (n.startsWith("rsi_") && y) u[n] = {
                                min: 0,
                                max: 1
                            }; else {
                                var p = i && a.includes(n) ? o / s : o;
                                u.hasOwnProperty(n) || (u[n] = {
                                    min: 1 / 0,
                                    max: -1 / 0
                                }), p < u[n].min && (u[n].min = p), p > u[n].max && (u[n].max = p);
                            }
                        }
                        return !0;
                    }({
                        main: r,
                        index: e,
                        key: n,
                        value: o
                    });
                }, this;
            }, e = [ {
                key: "getDataAsCols",
                value: function() {
                    var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    this.compute();
                    for (var e = this.precisionMultiplier, r = this.precision, n = this.invalidValueIndex, o = this.len, i = this.verticalOhlcv, a = this.priceBased, u = {}, l = n >= 0 && t, c = o - (n + 1), s = 0, f = Object.entries(i); s < f.length; s++) {
                        var h = Rr(f[s], 2), y = h[0], p = h[1], v = l ? p.slice(-c) : p;
                        // If slicing is needed, create a sliced copy, otherwise re-use the array.
                                                // If this key is price based and precision is enabled, map over the array.
                        r && a.includes(y) && (v = v.map((function(t) {
                            return null == t ? null : t / e;
                        }))), u[y] = v;
                    }
                    return u;
                }
            }, {
                key: "getData",
                value: function() {
                    var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    //getData method returns the last object (row) of the new OHLCV with indicators: {open, high, low, close, rsi_14, bollinger_bands_upper}
                                        this.compute();
                    var e = this.precisionMultiplier, r = this.priceBased, n = this.precision;
                    return function(t) {
                        var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 ? arguments[4] : void 0, i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, a = Object.keys(t);
                        if (0 === a.length) return [];
                        for (var u = e && i >= 0 ? i + 1 : 0, l = t[a[0]].length, c = new Array(l - u), s = u; s < l; s++) {
                            for (var f = {}, h = 0; h < a.length; h++) {
                                var y = a[h], p = t[y][s];
                                f[y] = r && o.includes(y) ? p / n : p;
                            }
                            c[s - u] = f;
                        }
                        return c;
                    }(this.verticalOhlcv, t, n, e, r, this.invalidValueIndex);
                }
            }, {
                key: "getLastValues",
                value: function() {
                    this.compute();
                    for (var t = this.precisionMultiplier, e = this.priceBased, r = this.precision, n = this.verticalOhlcv, o = this.len, i = {}, a = 0, u = Object.keys(n); a < u.length; a++) {
                        var l = u[a];
                        i[l] = n[l][o - 1];
                    }
                    return r ? function(t) {
                        for (var e = t.row, r = t.precisionMultiplier, n = t.priceBased, o = {}, i = 0, a = Object.entries(e); i < a.length; i++) {
                            var u = ee(a[i], 2), l = u[0], c = u[1];
                            n.includes(l) && (c /= r), o[l] = c;
                        }
                        return o;
                    }({
                        row: i,
                        precisionMultiplier: t,
                        priceBased: e
                    }) : i;
                }
            }, {
                key: "compute",
                value: function(t) {
                    //if change is a valid object and change.date is after the last row in this.input[this.input.length - 1].date pushes change to this.input using the parseOhlcvToVertical function.
                    //stops the compute if compute is called from getData, getDataAsCols or getLastValues an isComputed is false
                    if (!0 === this.isComputed && !t) return this;
                    //checks the first row in OHLCV input to verify if the date property is valid
                                        //compute method can be used to add new or update the last datapoints if a new OHLCV object is passed with a valid date property
                    //valid date properties: "2024-12-16 15:45:00" or "2024-12-16"
                    if (this.isComputed = !1, this.isValidDate = this.input[0].hasOwnProperty("date") && o(this.input[0].date), 
                    //compute method can be used to process indicators if no arguments are provided
                    //compute method can be called to access the .verticalOhlcv object
                    //compute method is called automatically if getLastValues or getDate methods are called
                    this.len > this.lastComputedIndex && !t && xr(this.input, this, 0), t && "object" === Cr(t)) {
                        var e;
                        if (![ "open", "high", "low", "close", "volume", "date" ].every((function(e) {
                            return Object.keys(t).includes(e);
                        }))) throw Error('Invalid OHLCV object sent in "compute". Correct usage: .compute({open: 108.25, high: 108.410004, low: 108.25, close: 99999999, volume: 875903, date: "2024-12-16 15:45:00" || "2024-12-16"})');
                        if (!this.isValidDate) throw Error('All the OHLCV rows require a valid date property to access the compute change method. Correct date format: "2024-12-16 15:45:00" or "2024-12-16"');
                        if (!o(t.date)) throw Error('The date in the new OHLCV row is invalid. Correct date format: "2024-12-16 15:45:00" or "2024-12-16"');
                        var r = t.date, n = this.len - 1, i = null === (e = this.input[n]) || void 0 === e ? void 0 : e.date;
                        //fallback if .compute(change) is triggered before .compute() alone
                        0 === this.lastComputedIndex && this.compute(), i !== r ? (
                        // Add new item
                        this.len++, this.input.push(t), xr(this.input, this, this.len)) : (
                        // Modify the last item
                        this.input[n] = t, xr(this.input, this, n));
                    }
                    return this;
                }
            }, {
                key: "crossPairs",
                value: function(t) {
                    return i(this), this.crossPairsList = [].concat(Ir(this.crossPairsList), Ir(t)), 
                    this.inputParams.push({
                        key: "crossPairs",
                        params: [ this.crossPairsList ]
                    }), this;
                }
            }, {
                key: "lag",
                value: function() {
                    var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [ "close" ], r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                    if (i(this), !Array.isArray(e)) throw new Error('Param "colKeys" must be a valid array of keyNames in lag.');
                    if ("number" != typeof r || !Number.isInteger(r) || r < 0) throw new Error('Param "lags" must be a integer greater or equal to 0: '.concat(JSON.stringify(e)));
                    this.inputParams.push({
                        key: "lag",
                        params: [ e, r ]
                    });
                    for (var n = function() {
                        var r = e[o];
                        t.priceBased.find((function(t) {
                            return r === t;
                        })) && t.priceBased.push(r);
                    }, o = 0; o < e.length; o++) n();
                    return this;
                }
            }, {
                key: "relativeVolume",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if (!1 === this.hasVolume) throw new Error('If "relativeVolume" is called the input ohlcv must contain valid volume properties.');
                    i(this);
                    var r = e.scale, n = void 0 === r ? null : r;
                    if ("number" == typeof n && !Lr.includes(n)) throw new Error('"scale" value in relativeVolume must be any of the following numbers: '.concat(Lr.join(", ")));
                    return this.inputParams.push({
                        key: "relativeVolume",
                        params: [ t, {
                            scale: n
                        } ]
                    }), this;
                }
            }, {
                key: "ema",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    i(this);
                    var r = de("ema", t, e, Lr);
                    return this.inputParams.push({
                        key: "movingAverages",
                        params: [ "ema", t, r ]
                    }), this;
                }
            }, {
                key: "sma",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    i(this);
                    var r = de("sma", t, e, Lr);
                    return this.inputParams.push({
                        key: "movingAverages",
                        params: [ "sma", t, r ]
                    }), this;
                }
            }, {
                key: "macd",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 12, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 26, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 9, n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                    if (i(this), "number" != typeof t || t <= 0) throw new Error('"fast" must be a positive number in macd.');
                    if ("number" != typeof e || e <= t) throw new Error('"slow" must be a positive number greater than "fast" in macd.');
                    if ("number" != typeof r || r <= 0) throw new Error('"signal" must be a positive number in macd.');
                    if ("object" !== Cr(n)) throw new Error('"options" must be an object in macd. eg: {target}');
                    var o = n.target, a = void 0 === o ? "close" : o;
                    return this.inputParams.push({
                        key: "macd",
                        params: [ t, e, r, {
                            target: a
                        } ]
                    }), this;
                }
            }, {
                key: "bollingerBands",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 20, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    if (i(this), !r || "object" !== Cr(r)) throw new Error('"options" must be an object in bollingerBands. eg: {target, height, range}');
                    var n = r.target, o = void 0 === n ? "close" : n, a = r.height, u = void 0 !== a && a, l = r.range, c = void 0 === l ? [] : l, s = r.scale, f = void 0 === s ? null : s, h = r.lag, y = void 0 === h ? 0 : h, p = r.autoMinMax, v = void 0 !== p && p;
                    // Validate size and times
                                        if ("number" != typeof t || t <= 0) throw new Error('"size" must be a positive number in bollingerBands.');
                    if ("number" != typeof e || e <= 0) throw new Error('"stdDev" must be a positive number in bollingerBands.');
                    if (!Array.isArray(c)) throw new Error('If set, "range" must be a array of column names in bollingerBands.');
                    if ("number" != typeof y) throw new Error('"lag" value must be a number in bollingerBands.');
                    if ("boolean" != typeof v) throw new Error('"autoMinMax" value in rsi must be a number in bollingerBands.');
                    if ("boolean" != typeof u) throw new Error('"height" must be a boolean in bollingerBands.');
                    if ("number" == typeof f && !Lr.includes(f)) throw new Error('"scale" value in bollingerBands must be any of the following numbers: '.concat(Lr.join(", ")));
                    return this.inputParams.push({
                        key: "bollingerBands",
                        params: [ t, e, {
                            target: o,
                            height: u,
                            scale: f,
                            range: c,
                            lag: y,
                            autoMinMax: v
                        } ]
                    }), this;
                }
            }, {
                key: "rsi",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    // Validate size and times
                    if (i(this), "number" != typeof t || t <= 0) throw new Error('"size" must be a positive number in rsi.');
                    var r = e.scale, n = void 0 === r ? null : r, o = e.target, a = void 0 === o ? "close" : o, u = e.lag, l = void 0 === u ? 0 : u, c = e.autoMinMax, s = void 0 !== c && c;
                    if ("number" == typeof n && !Lr.includes(n)) throw new Error('"scale" value in rsi must be any of the following numbers: '.concat(Lr.join(", ")));
                    if ("number" != typeof l) throw new Error('"lag" value in rsi must be a number in rsi.');
                    if ("boolean" != typeof s) throw new Error('"autoMinMax" value in rsi must be a number in rsi.');
                    return this.inputParams.push({
                        key: "rsi",
                        params: [ t, {
                            scale: n,
                            target: a,
                            lag: l,
                            autoMinMax: s
                        } ]
                    }), this;
                }
            }, {
                key: "donchianChannels",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 20, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    if (i(this), "number" != typeof t || t <= 0) throw new Error('"size" must be a positive number greater than 0 in donchianChannels.');
                    if ("number" != typeof e || e < 0) throw new Error('"offset" must be a number greater than or equal to 0 in donchianChannels.');
                    var n = r.height, o = void 0 !== n && n, a = r.range, u = void 0 === a ? [] : a, l = r.scale, c = void 0 === l ? null : l, s = r.lag, f = void 0 === s ? 0 : s, h = r.autoMinMax, y = void 0 !== h && h;
                    if (!Array.isArray(u)) throw new Error('If set, "range" must be an array of column names in donchianChannels.');
                    if ("number" != typeof f) throw new Error('"lag" value in rsi must be a number in donchianChannels.');
                    if ("boolean" != typeof y) throw new Error('"autoMinMax" value in rsi must be a number in donchianChannels.');
                    if ("boolean" != typeof o) throw new Error('"height" must be a boolean in donchianChannels.');
                    if ("number" == typeof c && !Lr.includes(c)) throw new Error('"scale" value in donchianChannels must be any of the following numbers: '.concat(Lr.join(", ")));
                    return this.inputParams.push({
                        key: "donchianChannels",
                        params: [ t, e, {
                            height: o,
                            range: u,
                            scale: c,
                            lag: f,
                            autoMinMax: y
                        } ]
                    }), this;
                }
            }, {
                key: "candleVectors",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 200, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if (i(this), "number" != typeof t || t <= 0) throw new Error('"size" must be a positive number greater than 0 in candleVectors.');
                    var r = e.stdDev, n = void 0 === r ? 1 : r, o = e.lag, a = void 0 === o ? 0 : o, u = e.scale, l = void 0 === u ? .001 : u, c = e.patternSize, s = void 0 === c ? 0 : c, f = e.autoMinMax, h = void 0 !== f && f;
                    if ("number" != typeof n || n <= 0) throw new Error('"stdDev" must be a positive number greater than 0 in candleVectors.');
                    if ("number" == typeof l && !Lr.includes(l)) throw new Error('"scale" value in candleVectors must be any of the following numbers: '.concat(Lr.join(", ")));
                    if ("number" != typeof s || !Number.isInteger(s) || s < 0) throw new Error('"patternSize" value in candleVectors must be a positive integer.');
                    if ("boolean" != typeof h) throw new Error('"autoMinMax" value in candleVectors must be boolean');
                    return this.inputParams.push({
                        key: "candleVectors",
                        params: [ t, {
                            stdDev: n,
                            patternSize: s,
                            lag: a,
                            scale: l,
                            autoMinMax: h
                        } ]
                    }), this;
                }
            }, {
                key: "volumeOscillator",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    if (!1 === this.hasVolume) throw new Error('If "volumeOscillator" is called the input ohlcv must contain valid volume properties.');
                    if (i(this), "number" != typeof t || t <= 1) throw new Error('fastSize" must be a positive number greater than 1 in volumeOscillator.');
                    if ("number" != typeof e || e <= t) throw new Error('"slowSize" must be a positive number greater than the "fastSize" in volumeOscillator.');
                    var n = r.scale, o = void 0 === n ? null : n;
                    if ("number" == typeof o && !Lr.includes(o)) throw new Error('"scale" value in volumeOscillator must be any of the following numbers: '.concat(Lr.join(", ")));
                    return this.inputParams.push({
                        key: "volumeOscillator",
                        params: [ t, e, {
                            scale: o
                        } ]
                    }), this;
                }
            }, {
                key: "dateTime",
                value: function() {
                    return i(this), this.inputParams.push({
                        key: "dateTime",
                        params: []
                    }), this;
                }
            }, {
                key: "priceVariations",
                value: function() {
                    return i(this), this.inputParams.push({
                        key: "priceVariations",
                        params: []
                    }), this;
                }
            } ], e && Br(t.prototype, e), r && Br(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
            var t, e, r;
        }();
    })(), OHLCV_INDICATORS = e;
})
/******/ ();