var OHLCV_INDICATORS;

/******/ (() => {
    // webpackBootstrap
    /******/ "use strict";
    /******/ // The require scope
    /******/    var t = {
        /******/ // define getter functions for harmony exports
        /******/ d: (e, r) => {
            /******/ for (var n in r) 
            /******/ t.o(r, n) && !t.o(e, n) && 
            /******/ Object.defineProperty(e, n, {
                enumerable: !0,
                get: r[n]
            })
            /******/;
            /******/        },
        /******/ o: (t, e) => Object.prototype.hasOwnProperty.call(t, e)
        /******/ ,
        /******/ // define __esModule on exports
        /******/ r: t => {
            /******/ "undefined" != typeof Symbol && Symbol.toStringTag && 
            /******/ Object.defineProperty(t, Symbol.toStringTag, {
                value: "Module"
            })
            /******/ , Object.defineProperty(t, "__esModule", {
                value: !0
            });
        }
        /******/    }, e = {};
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/define property getters */
    /******/    
    // This entry need to be wrapped in an IIFE because it declares 'OHLCV_INDICATORS' on top-level, which conflicts with the current library output.
    (() => {
        // ./src/utilities/validators.js
        function r(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, e) {
                var r = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != r) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (r = r.call(t)).next, 0 === e) {
                            if (Object(r) !== r) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(r)).done) && (u.push(n.value), u.length !== e); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != r.return && (a = r.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, e) || i(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function n(t) {
            return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, n(t);
        }
        function o(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = i(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var a, u = !0, l = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return u = t.done, t;
                },
                e: function(t) {
                    l = !0, a = t;
                },
                f: function() {
                    try {
                        u || null == r.return || r.return();
                    } finally {
                        if (l) throw a;
                    }
                }
            };
        }
        function i(t, e) {
            if (t) {
                if ("string" == typeof t) return a(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? a(t, e) : void 0;
            }
        }
        function a(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        // ESM COMPAT FLAG
        t.r(e), 
        // EXPORTS
        t.d(e, {
            default: () => /* binding */ rn
        });
        var u = function(t, e) {
            if (!Array.isArray(t)) throw new Error('Property "inputParams" must be an "Array" or "Set".');
            var r, n = o(t);
            try {
                for (n.s(); !(r = n.n()).done; ) {
                    var i, a = o(r.value.params);
                    try {
                        for (a.s(); !(i = a.n()).done; ) {
                            var u = i.value;
                            if ("number" == typeof u && u > e) throw console.log(u, e), new Error("At least one of the params of the indicator is greater than the input OHLCV length. Make sure to have enough datapoints in the input OHLCV.");
                        }
                    } catch (t) {
                        a.e(t);
                    } finally {
                        a.f();
                    }
                }
            } catch (t) {
                n.e(t);
            } finally {
                n.f();
            }
        }, l = function(t) {
            if (!0 === t.isComputed) throw Error('ohlcv is already computed, you can not add new indicators after "compute", "getLastValues" , "getDataAsCols" or "getData" methods are called.');
        }, c = function(t, e, r) {
            if (!Array.isArray(t)) throw new Error('Param "'.concat(e, '" must be an array in "').concat(r, '".'));
            return !0;
        }, s = function(t, e, r) {
            if (!Boolean(t) || "object" == !n(t)) throw new Error('Param "'.concat(e, '" must be an object in "').concat(r, '".'));
            return !0;
        }, f = function(t, e, r, n) {
            if (c(t, "arrayOptions", "".concat(n, ".").concat(r, ".validateArrayOptions")), 
            !t.includes(e.toString())) throw new Error('Param "'.concat(r, '" must be any of the following values [').concat(t.join(", "), '] in "').concat(n, '".'));
            return !0;
        }, y = function(t, e, r) {
            if ("boolean" != typeof t) throw new Error('Param "'.concat(e, '" must be an boolean in "').concat(r, '".'));
            return !0;
        }, p = function(t, e, r, n) {
            s(e, "options", "".concat(n, ".").concat(r, ".validateNumber"));
            var o = e.allowDecimals, i = void 0 !== o && o, a = e.min, u = e.max, l = i ? "number" : "integer";
            if ("number" != typeof t || !1 === i && !Number.isInteger(t)) throw new Error('Param "'.concat(r, '" must be an integer in "').concat(n, '".'));
            if ("number" != typeof a || "number" != typeof u || a >= u) throw new Error('Param "min" must be a valid '.concat(l, ' lower than "max" "').concat(n, ".").concat(r, '.validateNumber".'));
            if (t < a) throw new Error('Param "'.concat(r, '" must be an ').concat(l, " greater than or equal to ").concat(a, ' in "').concat(n, '".'));
            if (t > u) throw new Error('Param "'.concat(r, '" must be an ').concat(l, " lower than or equal to ").concat(u, ' in "').concat(n, '".'));
            return !0;
        }, // 0, 1, 2 or 3
        // The maximum value of DP and Big.DP.
        h = 1e6, // 0 to 1000000
        // The maximum magnitude of the exponent argument to the pow method.
        v = 1e6, // true or false
        /**************************************************************************************************/
        // Error messages.
        m = "[big.js] ", d = m + "Invalid ", b = d + "decimal places", g = d + "rounding mode", w = m + "Division by zero", 
        // The shared prototype object.
        O = {}, S = void 0, j = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
        /*
 * Round Big x to a maximum of sd significant digits using rounding mode rm.
 *
 * x {Big} The Big to round.
 * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.
 * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 * [more] {boolean} Whether the result of division was truncated.
 */
        function P(t, e, r, n) {
            var o = t.c;
            if (r === S && (r = t.constructor.RM), 0 !== r && 1 !== r && 2 !== r && 3 !== r) throw Error(g);
            if (e < 1) n = 3 === r && (n || !!o[0]) || 0 === e && (1 === r && o[0] >= 5 || 2 === r && (o[0] > 5 || 5 === o[0] && (n || o[1] !== S))), 
            o.length = 1, n ? (
            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
            t.e = t.e - e + 1, o[0] = 1) : 
            // Zero.
            o[0] = t.e = 0; else if (e < o.length) {
                // Round up?
                if (
                // xc[sd] is the digit after the digit that may be rounded up.
                n = 1 === r && o[e] >= 5 || 2 === r && (o[e] > 5 || 5 === o[e] && (n || o[e + 1] !== S || 1 & o[e - 1])) || 3 === r && (n || !!o[0]), 
                // Remove any digits after the required precision.
                o.length = e, n) 
                // Rounding up may mean the previous digit has to be rounded up.
                for (;++o[--e] > 9; ) if (o[e] = 0, 0 === e) {
                    ++t.e, o.unshift(1);
                    break;
                }
                // Remove trailing zeros.
                                for (e = o.length; !o[--e]; ) o.pop();
            }
            return t;
        }
        /*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 */        function _(t, e, r) {
            var n = t.e, o = t.c.join(""), i = o.length;
            // Exponential notation?
                        if (e) o = o.charAt(0) + (i > 1 ? "." + o.slice(1) : "") + (n < 0 ? "e" : "e+") + n;
            // Normal notation.
             else if (n < 0) {
                for (;++n; ) o = "0" + o;
                o = "0." + o;
            } else if (n > 0) if (++n > i) for (n -= i; n--; ) o += "0"; else n < i && (o = o.slice(0, n) + "." + o.slice(n)); else i > 1 && (o = o.charAt(0) + "." + o.slice(1));
            return t.s < 0 && r ? "-" + o : o;
        }
        // Prototype/instance methods
        /*
 * Return a new Big whose value is the absolute value of this Big.
 */        O.abs = function() {
            var t = new this.constructor(this);
            return t.s = 1, t;
        }, 
        /*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
 */
        O.cmp = function(t) {
            var e, r = this, n = r.c, o = (t = new r.constructor(t)).c, i = r.s, a = t.s, u = r.e, l = t.e;
            // Either zero?
                        if (!n[0] || !o[0]) return n[0] ? i : o[0] ? -a : 0;
            // Signs differ?
                        if (i != a) return i;
            // Compare exponents.
            if (e = i < 0, u != l) return u > l ^ e ? 1 : -1;
            // Compare digit by digit.
            for (a = (u = n.length) < (l = o.length) ? u : l, i = -1; ++i < a; ) if (n[i] != o[i]) return n[i] > o[i] ^ e ? 1 : -1;
            // Compare lengths.
                        return u == l ? 0 : u > l ^ e ? 1 : -1;
        }, 
        /*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
        O.div = function(t) {
            var e = this, r = e.constructor, n = e.c, // dividend
            o = (t = new r(t)).c, // divisor
            i = e.s == t.s ? 1 : -1, a = r.DP;
            if (a !== ~~a || a < 0 || a > h) throw Error(b);
            // Divisor is zero?
                        if (!o[0]) throw Error(w);
            // Dividend is 0? Return +-0.
                        if (!n[0]) return t.s = i, t.c = [ t.e = 0 ], t;
            var u, l, c, s, f, y = o.slice(), p = u = o.length, v = n.length, m = n.slice(0, u), // remainder
            d = m.length, g = t, // quotient
            O = g.c = [], j = 0, _ = a + (g.e = e.e - t.e) + 1;
 // precision of the result
                        // Add zeros to make remainder as long as divisor.
            for (g.s = i, i = _ < 0 ? 0 : _, 
            // Create version of divisor with leading zero.
            y.unshift(0); d++ < u; ) m.push(0);
            do {
                // n is how many times the divisor goes into current remainder.
                for (c = 0; c < 10; c++) {
                    // Compare divisor and remainder.
                    if (u != (d = m.length)) s = u > d ? 1 : -1; else for (f = -1, s = 0; ++f < u; ) if (o[f] != m[f]) {
                        s = o[f] > m[f] ? 1 : -1;
                        break;
                    }
                    // If divisor < remainder, subtract divisor from remainder.
                                        if (!(s < 0)) break;
                    // Remainder can't be more than 1 digit longer than divisor.
                    // Equalise lengths using divisor with extra leading zero?
                    for (l = d == u ? o : y; d; ) {
                        if (m[--d] < l[d]) {
                            for (f = d; f && !m[--f]; ) m[f] = 9;
                            --m[f], m[d] += 10;
                        }
                        m[d] -= l[d];
                    }
                    for (;!m[0]; ) m.shift();
                }
                // Add the digit n to the result array.
                                O[j++] = s ? c : ++c, 
                // Update the remainder.
                m[0] && s ? m[d] = n[p] || 0 : m = [ n[p] ];
            } while ((p++ < v || m[0] !== S) && i--);
            // Leading zero? Do not remove if result is simply zero (qi == 1).
                        return O[0] || 1 == j || (
            // There can't be more than one zero.
            O.shift(), g.e--, _--), 
            // Round?
            j > _ && P(g, _, r.RM, m[0] !== S), g;
        }, 
        /*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */
        O.eq = function(t) {
            return 0 === this.cmp(t);
        }, 
        /*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */
        O.gt = function(t) {
            return this.cmp(t) > 0;
        }, 
        /*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */
        O.gte = function(t) {
            return this.cmp(t) > -1;
        }, 
        /*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */
        O.lt = function(t) {
            return this.cmp(t) < 0;
        }, 
        /*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */
        O.lte = function(t) {
            return this.cmp(t) < 1;
        }, 
        /*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */
        O.minus = O.sub = function(t) {
            var e, r, n, o, i = this, a = i.constructor, u = i.s, l = (t = new a(t)).s;
            // Signs differ?
                        if (u != l) return t.s = -l, i.plus(t);
            var c = i.c.slice(), s = i.e, f = t.c, y = t.e;
            // Either zero?
                        if (!c[0] || !f[0]) return f[0] ? t.s = -l : c[0] ? t = new a(i) : t.s = 1, 
            t;
            // Determine which is the bigger number. Prepend zeros to equalise exponents.
                        if (u = s - y) {
                for ((o = u < 0) ? (u = -u, n = c) : (y = s, n = f), n.reverse(), l = u; l--; ) n.push(0);
                n.reverse();
            } else for (
            // Exponents equal. Check digit by digit.
            r = ((o = c.length < f.length) ? c : f).length, u = l = 0; l < r; l++) if (c[l] != f[l]) {
                o = c[l] < f[l];
                break;
            }
            // x < y? Point xc to the array of the bigger number.
                        /*
   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
   * needs to start at yc.length.
   */
            if (o && (n = c, c = f, f = n, t.s = -t.s), (l = (r = f.length) - (e = c.length)) > 0) for (;l--; ) c[e++] = 0;
            // Subtract yc from xc.
                        for (l = e; r > u; ) {
                if (c[--r] < f[r]) {
                    for (e = r; e && !c[--e]; ) c[e] = 9;
                    --c[e], c[r] += 10;
                }
                c[r] -= f[r];
            }
            // Remove trailing zeros.
                        for (;0 === c[--l]; ) c.pop();
            // Remove leading zeros and adjust exponent accordingly.
                        for (;0 === c[0]; ) c.shift(), --y;
            return c[0] || (
            // n - n = +0
            t.s = 1, 
            // Result must be zero.
            c = [ y = 0 ]), t.c = c, t.e = y, t;
        }, 
        /*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */
        O.mod = function(t) {
            var e, r = this, n = r.constructor, o = r.s, i = (t = new n(t)).s;
            if (!t.c[0]) throw Error(w);
            return r.s = t.s = 1, e = 1 == t.cmp(r), r.s = o, t.s = i, e ? new n(r) : (o = n.DP, 
            i = n.RM, n.DP = n.RM = 0, r = r.div(t), n.DP = o, n.RM = i, this.minus(r.times(t)));
        }, 
        /*
 * Return a new Big whose value is the value of this Big negated.
 */
        O.neg = function() {
            var t = new this.constructor(this);
            return t.s = -t.s, t;
        }, 
        /*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */
        O.plus = O.add = function(t) {
            var e, r, n, o = this, i = o.constructor;
            // Signs differ?
            if (t = new i(t), o.s != t.s) return t.s = -t.s, o.minus(t);
            var a = o.e, u = o.c, l = t.e, c = t.c;
            // Either zero?
                        if (!u[0] || !c[0]) return c[0] || (u[0] ? t = new i(o) : t.s = o.s), 
            t;
            // Prepend zeros to equalise exponents.
            // Note: reverse faster than unshifts.
            if (u = u.slice(), e = a - l) {
                for (e > 0 ? (l = a, n = c) : (e = -e, n = u), n.reverse(); e--; ) n.push(0);
                n.reverse();
            }
            // Point xc to the longer array.
                        // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
            for (u.length - c.length < 0 && (n = c, c = u, u = n), e = c.length, r = 0; e; u[e] %= 10) r = (u[--e] = u[e] + c[e] + r) / 10 | 0;
            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
                        // Remove trailing zeros.
            for (r && (u.unshift(r), ++l), e = u.length; 0 === u[--e]; ) u.pop();
            return t.c = u, t.e = l, t;
        }, 
        /*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */
        O.pow = function(t) {
            var e = this, r = new e.constructor("1"), n = r, o = t < 0;
            if (t !== ~~t || t < -1e6 || t > v) throw Error(d + "exponent");
            for (o && (t = -t); 1 & t && (n = n.times(e)), t >>= 1; ) e = e.times(e);
            return o ? r.div(n) : n;
        }, 
        /*
 * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
 * significant digits using rounding mode rm, or Big.RM if rm is not specified.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
        O.prec = function(t, e) {
            if (t !== ~~t || t < 1 || t > h) throw Error(d + "precision");
            return P(new this.constructor(this), t, e);
        }, 
        /*
 * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places
 * using rounding mode rm, or Big.RM if rm is not specified.
 * If dp is negative, round to an integer which is a multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
        O.round = function(t, e) {
            if (t === S) t = 0; else if (t !== ~~t || t < -h || t > h) throw Error(b);
            return P(new this.constructor(this), t + this.e + 1, e);
        }, 
        /*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
        O.sqrt = function() {
            var t, e, r, n = this, o = n.constructor, i = n.s, a = n.e, u = new o("0.5");
            // Zero?
                        if (!n.c[0]) return new o(n);
            // Negative?
                        if (i < 0) throw Error(m + "No square root");
            // Estimate.
                        // Math.sqrt underflow/overflow?
            // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
            0 === (i = Math.sqrt(n + "")) || i === 1 / 0 ? ((e = n.c.join("")).length + a & 1 || (e += "0"), 
            a = ((a + 1) / 2 | 0) - (a < 0 || 1 & a), t = new o(((i = Math.sqrt(e)) == 1 / 0 ? "5e" : (i = i.toExponential()).slice(0, i.indexOf("e") + 1)) + a)) : t = new o(i + ""), 
            a = t.e + (o.DP += 4);
            // Newton-Raphson iteration.
            do {
                r = t, t = u.times(r.plus(n.div(r)));
            } while (r.c.slice(0, a).join("") !== t.c.slice(0, a).join(""));
            return P(t, (o.DP -= 4) + t.e + 1, o.RM);
        }, 
        /*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */
        O.times = O.mul = function(t) {
            var e, r = this, n = r.constructor, o = r.c, i = (t = new n(t)).c, a = o.length, u = i.length, l = r.e, c = t.e;
            // Determine sign of result.
                        // Return signed 0 if either 0.
            if (t.s = r.s == t.s ? 1 : -1, !o[0] || !i[0]) return t.c = [ t.e = 0 ], t;
            // Initialise exponent of result as x.e + y.e.
                        // Initialise coefficient array of result with zeros.
            for (t.e = l + c, 
            // If array xc has fewer digits than yc, swap xc and yc, and lengths.
            a < u && (e = o, o = i, i = e, c = a, a = u, u = c), e = new Array(c = a + u); c--; ) e[c] = 0;
            // Multiply.
            // i is initially xc.length.
                        for (l = u; l--; ) {
                // a is yc.length.
                for (u = 0, c = a + l; c > l; ) 
                // Current sum of products at this digit position, plus carry.
                u = e[c] + i[l] * o[c - l - 1] + u, e[c--] = u % 10, 
                // carry
                u = u / 10 | 0;
                e[c] = u;
            }
            // Increment result exponent if there is a final carry, otherwise remove leading zero.
                        // Remove trailing zeros.
            for (u ? ++t.e : e.shift(), l = e.length; !e[--l]; ) e.pop();
            return t.c = e, t;
        }, 
        /*
 * Return a string representing the value of this Big in exponential notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
        O.toExponential = function(t, e) {
            var r = this, n = r.c[0];
            if (t !== S) {
                if (t !== ~~t || t < 0 || t > h) throw Error(b);
                for (r = P(new r.constructor(r), ++t, e); r.c.length < t; ) r.c.push(0);
            }
            return _(r, !0, !!n);
        }, 
        /*
 * Return a string representing the value of this Big in normal notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */
        O.toFixed = function(t, e) {
            var r = this, n = r.c[0];
            if (t !== S) {
                if (t !== ~~t || t < 0 || t > h) throw Error(b);
                // x.e may have changed if the value is rounded up.
                for (t = t + (r = P(new r.constructor(r), t + r.e + 1, e)).e + 1; r.c.length < t; ) r.c.push(0);
            }
            return _(r, !1, !!n);
        }, 
        /*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */
        O[Symbol.for("nodejs.util.inspect.custom")] = O.toJSON = O.toString = function() {
            var t = this, e = t.constructor;
            return _(t, t.e <= e.NE || t.e >= e.PE, !!t.c[0]);
        }, 
        /*
 * Return the value of this Big as a primitve number.
 */
        O.toNumber = function() {
            var t = Number(_(this, !0, !0));
            if (!0 === this.constructor.strict && !this.eq(t.toString())) throw Error(m + "Imprecise conversion");
            return t;
        }, 
        /*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * rounding mode rm, or Big.RM if rm is not specified.
 * Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
        O.toPrecision = function(t, e) {
            var r = this, n = r.constructor, o = r.c[0];
            if (t !== S) {
                if (t !== ~~t || t < 1 || t > h) throw Error(d + "precision");
                for (r = P(new n(r), t, e); r.c.length < t; ) r.c.push(0);
            }
            return _(r, t <= r.e || r.e <= n.NE || r.e >= n.PE, !!o);
        }, 
        /*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */
        O.valueOf = function() {
            var t = this, e = t.constructor;
            if (!0 === e.strict) throw Error(m + "valueOf disallowed");
            return _(t, t.e <= e.NE || t.e >= e.PE, !0);
        };
        // Export
        (
        /*
 * Create and return a Big constructor.
 */
        function t() {
            /*
   * The Big constructor and exported function.
   * Create and return a new instance of a Big number object.
   *
   * n {number|string|Big} A numeric value.
   */
            function e(r) {
                var n = this;
                // Enable constructor usage without new.
                                if (!(n instanceof e)) return r === S ? t() : new e(r);
                // Duplicate.
                                if (r instanceof e) n.s = r.s, n.e = r.e, n.c = r.c.slice(); else {
                    if ("string" != typeof r) {
                        if (!0 === e.strict && "bigint" != typeof r) throw TypeError(d + "value");
                        // Minus zero?
                                                r = 0 === r && 1 / r < 0 ? "-0" : String(r);
                    }
                    !
                    /*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */
                    function(t, e) {
                        var r, n, o;
                        if (!j.test(e)) throw Error(d + "number");
                        // Determine sign.
                                                // Decimal point?
                        t.s = "-" == e.charAt(0) ? (e = e.slice(1), -1) : 1, (r = e.indexOf(".")) > -1 && (e = e.replace(".", ""));
                        // Exponential form?
                                                (n = e.search(/e/i)) > 0 ? (
                        // Determine exponent.
                        r < 0 && (r = n), r += +e.slice(n + 1), e = e.substring(0, n)) : r < 0 && (
                        // Integer.
                        r = e.length);
                        // Determine leading zeros.
                        for (o = e.length, n = 0; n < o && "0" == e.charAt(n); ) ++n;
                        if (n == o) 
                        // Zero.
                        t.c = [ t.e = 0 ]; else {
                            // Determine trailing zeros.
                            for (;o > 0 && "0" == e.charAt(--o); ) ;
                            // Convert string to array of digits without leading/trailing zeros.
                            for (t.e = r - n - 1, t.c = [], r = 0; n <= o; ) t.c[r++] = +e.charAt(n++);
                        }
                    }(n, r);
                }
                // Retain a reference to this Big constructor.
                // Shadow Big.prototype.constructor which points to Object.
                                n.constructor = e;
            }
            return e.prototype = O, e.DP = 20, e.RM = 1, e.NE = -7, e.PE = 21, e.strict = false, 
            e.roundDown = 0, e.roundHalfUp = 1, e.roundHalfEven = 2, e.roundUp = 3, e;
        })();
        /// <reference types="https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts" />
        /* harmony default export */        // ./node_modules/trading-signals/dist/error/NotEnoughDataError.js
        function N(t) {
            return N = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, N(t);
        }
        function T(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, A(n.key), n);
            }
        }
        function A(t) {
            var e = function(t, e) {
                if ("object" != N(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != N(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == N(e) ? e : e + "";
        }
        function E(t, e, r) {
            return e = D(e), function(t, e) {
                if (e && ("object" == N(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, x() ? Reflect.construct(e, r || [], D(t).constructor) : e.apply(t, r));
        }
        function k(t) {
            var e = "function" == typeof Map ? new Map : void 0;
            return k = function(t) {
                if (null === t || !function(t) {
                    try {
                        return -1 !== Function.toString.call(t).indexOf("[native code]");
                    } catch (e) {
                        return "function" == typeof t;
                    }
                }(t)) return t;
                if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== e) {
                    if (e.has(t)) return e.get(t);
                    e.set(t, r);
                }
                function r() {
                    return function(t, e, r) {
                        if (x()) return Reflect.construct.apply(null, arguments);
                        var n = [ null ];
                        n.push.apply(n, e);
                        var o = new (t.bind.apply(t, n));
                        return r && I(o, r.prototype), o;
                    }(t, arguments, D(this).constructor);
                }
                return r.prototype = Object.create(t.prototype, {
                    constructor: {
                        value: r,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), I(r, t);
            }, k(t);
        }
        function x() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (x = function() {
                return !!t;
            })();
        }
        function I(t, e) {
            return I = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, I(t, e);
        }
        function D(t) {
            return D = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, D(t);
        }
        var M =  function(t) {
            function e() {
                var t, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Not enough data";
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                }(this, e), t = E(this, e, [ r ]), Object.setPrototypeOf(t, (this instanceof e ? this.constructor : void 0).prototype), 
                t.name = "NotEnoughDataError", t;
            }
            return function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), e && I(t, e);
            }(e, t), r = e, n && T(r.prototype, n), o && T(r, o), Object.defineProperty(r, "prototype", {
                writable: !1
            }), r;
            var r, n, o;
        }( k(Error));
        // ./node_modules/trading-signals/dist/Indicator.js
        function R(t) {
            return R = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, R(t);
        }
        function C(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function F(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, H(n.key), n);
            }
        }
        function L(t, e, r) {
            return e && F(t.prototype, e), r && F(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function B(t, e, r) {
            return (e = H(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function H(t) {
            var e = function(t, e) {
                if ("object" != R(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != R(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == R(e) ? e : e + "";
        }
        var V =  function() {
            return L((function t() {
                C(this, t), B(this, "previousHighest", void 0), B(this, "highest", void 0), B(this, "previousLowest", void 0), 
                B(this, "lowest", void 0), B(this, "previousResult", void 0), B(this, "result", void 0);
            }), [ {
                key: "isStable",
                get: function() {
                    return void 0 !== this.result;
                }
            }, {
                key: "getResult",
                value: function() {
                    if (void 0 === this.result) throw new M;
                    return this.result;
                }
            }, {
                key: "setResult",
                value: function(t, e) {
                    return e && (this.highest = this.previousHighest, this.lowest = this.previousLowest, 
                    this.result = this.previousResult), void 0 === this.highest ? this.highest = t : t > this.highest ? (this.previousHighest = this.highest, 
                    this.highest = t) : this.previousHighest = this.highest, void 0 === this.lowest ? this.lowest = t : t < this.lowest ? (this.previousLowest = this.lowest, 
                    this.lowest = t) : this.previousLowest = this.lowest, this.previousResult = this.result, 
                    this.result = t;
                }
            }, {
                key: "replace",
                value: function(t) {
                    return this.update(t, !0);
                }
            } ]);
        }();
        // ./node_modules/trading-signals/dist/MA/MovingAverage.js
        function U(t) {
            return U = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, U(t);
        }
        function $(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function q(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, W(n.key), n);
            }
        }
        function z(t, e, r) {
            return e && q(t.prototype, e), r && q(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function G(t, e, r) {
            return e = Y(e), function(t, e) {
                if (e && ("object" == U(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, K() ? Reflect.construct(e, r || [], Y(t).constructor) : e.apply(t, r));
        }
        function K() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (K = function() {
                return !!t;
            })();
        }
        function Y(t) {
            return Y = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, Y(t);
        }
        function J(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && Z(t, e);
        }
        function Z(t, e) {
            return Z = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, Z(t, e);
        }
        function Q(t, e, r) {
            return (e = W(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function W(t) {
            var e = function(t, e) {
                if ("object" != U(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != U(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == U(e) ? e : e + "";
        }
        var X =  function(t) {
            function e(t) {
                var r;
                return $(this, e), Q(r = G(this, e), "interval", void 0), r.interval = t, r;
            }
            return J(e, t), z(e, [ {
                key: "updates",
                value: function(t) {
                    var e = this;
                    return t.forEach((function(t) {
                        return e.update(t);
                    })), this.result;
                }
            }, {
                key: "replace",
                value: function(t) {
                    return this.update(t, !0);
                }
            } ]);
        }(V);
        // ./node_modules/trading-signals/dist/SMA/SMA.js
        function tt(t) {
            return tt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, tt(t);
        }
        function et(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function rt(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, st(n.key), n);
            }
        }
        function nt(t, e, r) {
            return e && rt(t.prototype, e), r && rt(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function ot(t, e, r) {
            return e = at(e), function(t, e) {
                if (e && ("object" == tt(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, it() ? Reflect.construct(e, r || [], at(t).constructor) : e.apply(t, r));
        }
        function it() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (it = function() {
                return !!t;
            })();
        }
        function at(t) {
            return at = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, at(t);
        }
        function ut(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && lt(t, e);
        }
        function lt(t, e) {
            return lt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, lt(t, e);
        }
        function ct(t, e, r) {
            return (e = st(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function st(t) {
            var e = function(t, e) {
                if ("object" != tt(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != tt(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == tt(e) ? e : e + "";
        }
        var ft =  function(t) {
            function e() {
                var t;
                et(this, e);
                for (var r = arguments.length, n = new Array(r), o = 0; o < r; o++) n[o] = arguments[o];
                return ct(t = ot(this, e, [].concat(n)), "prices", []), t;
            }
            return ut(e, t), nt(e, [ {
                key: "update",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if (this.prices.length && e ? this.prices[this.prices.length - 1] = t : this.prices.push(t), 
                    this.prices.length > this.interval && this.prices.shift(), this.prices.length === this.interval) {
                        var r = this.prices.reduce((function(t, e) {
                            return t + e;
                        }), 0);
                        return this.setResult(r / this.prices.length, e);
                    }
                }
            } ]);
        }(X);
        // ./node_modules/trading-signals/dist/WSMA/WSMA.js
        function yt(t) {
            return yt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, yt(t);
        }
        function pt(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function ht(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, St(n.key), n);
            }
        }
        function vt(t, e, r) {
            return e && ht(t.prototype, e), r && ht(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function mt(t, e, r) {
            return e = bt(e), function(t, e) {
                if (e && ("object" == yt(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, dt() ? Reflect.construct(e, r || [], bt(t).constructor) : e.apply(t, r));
        }
        function dt() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (dt = function() {
                return !!t;
            })();
        }
        function bt(t) {
            return bt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, bt(t);
        }
        function gt(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && wt(t, e);
        }
        function wt(t, e) {
            return wt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, wt(t, e);
        }
        function Ot(t, e, r) {
            return (e = St(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function St(t) {
            var e = function(t, e) {
                if ("object" != yt(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != yt(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == yt(e) ? e : e + "";
        }
        var jt =  function(t) {
            function e(t) {
                var r;
                return pt(this, e), Ot(r = mt(this, e), "interval", void 0), Ot(r, "indicator", void 0), 
                Ot(r, "smoothingFactor", void 0), r.interval = t, r.indicator = new ft(t), r.smoothingFactor = 1 / r.interval, 
                r;
            }
            return gt(e, t), vt(e, [ {
                key: "updates",
                value: function(t) {
                    var e = this;
                    return t.forEach((function(t) {
                        return e.update(t);
                    })), this.result;
                }
            }, {
                key: "update",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = this.indicator.update(t);
                    if (e && void 0 !== this.previousResult) {
                        var n = (t - this.previousResult) * this.smoothingFactor;
                        return this.setResult(n + this.previousResult, e);
                    }
                    if (!e && void 0 !== this.result) {
                        var o = (t - this.result) * this.smoothingFactor;
                        return this.setResult(o + this.result, e);
                    }
                    if (void 0 === this.result && void 0 !== r) return this.setResult(r, e);
                }
            } ]);
        }(V);
        function Pt(t) {
            return t.length ? t.reduce((function(t, e) {
                return t + e;
            }), 0) / t.length : 0;
        }
        // ./node_modules/trading-signals/dist/TR/TR.js
        function _t(t) {
            return _t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, _t(t);
        }
        function Nt(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function Tt(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, Rt(n.key), n);
            }
        }
        function At(t, e, r) {
            return e && Tt(t.prototype, e), r && Tt(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function Et(t, e, r) {
            return e = xt(e), function(t, e) {
                if (e && ("object" == _t(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, kt() ? Reflect.construct(e, r || [], xt(t).constructor) : e.apply(t, r));
        }
        function kt() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (kt = function() {
                return !!t;
            })();
        }
        function xt(t) {
            return xt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, xt(t);
        }
        function It(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && Dt(t, e);
        }
        function Dt(t, e) {
            return Dt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, Dt(t, e);
        }
        function Mt(t, e, r) {
            return (e = Rt(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function Rt(t) {
            var e = function(t, e) {
                if ("object" != _t(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != _t(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == _t(e) ? e : e + "";
        }
        var Ct =  function(t) {
            function e() {
                var t;
                Nt(this, e);
                for (var r = arguments.length, n = new Array(r), o = 0; o < r; o++) n[o] = arguments[o];
                return Mt(t = Et(this, e, [].concat(n)), "previousCandle", void 0), Mt(t, "twoPreviousCandle", void 0), 
                t;
            }
            return It(e, t), At(e, [ {
                key: "update",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = t.high, n = t.low, o = r - n;
                    if (this.previousCandle && e && (this.previousCandle = this.twoPreviousCandle), 
                    this.previousCandle) {
                        var i = Math.abs(r - this.previousCandle.close), a = Math.abs(n - this.previousCandle.close);
                        return this.twoPreviousCandle = this.previousCandle, this.previousCandle = t, this.setResult(Math.max(o, i, a), e);
                    }
                    return this.twoPreviousCandle = this.previousCandle, this.previousCandle = t, this.setResult(o, e);
                }
            } ]);
        }(V);
        // ./node_modules/trading-signals/dist/ATR/ATR.js
        function Ft(t) {
            return Ft = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Ft(t);
        }
        function Lt(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function Bt(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, Kt(n.key), n);
            }
        }
        function Ht(t, e, r) {
            return e && Bt(t.prototype, e), r && Bt(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function Vt(t, e, r) {
            return e = $t(e), function(t, e) {
                if (e && ("object" == Ft(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, Ut() ? Reflect.construct(e, r || [], $t(t).constructor) : e.apply(t, r));
        }
        function Ut() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (Ut = function() {
                return !!t;
            })();
        }
        function $t(t) {
            return $t = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, $t(t);
        }
        function qt(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && zt(t, e);
        }
        function zt(t, e) {
            return zt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, zt(t, e);
        }
        function Gt(t, e, r) {
            return (e = Kt(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function Kt(t) {
            var e = function(t, e) {
                if ("object" != Ft(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != Ft(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == Ft(e) ? e : e + "";
        }
        var Yt =  function(t) {
            function e(t) {
                var r, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : jt;
                return Lt(this, e), Gt(r = Vt(this, e), "interval", void 0), Gt(r, "tr", void 0), 
                Gt(r, "smoothing", void 0), r.interval = t, r.tr = new Ct, r.smoothing = new n(t), 
                r;
            }
            return qt(e, t), Ht(e, [ {
                key: "update",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = this.tr.update(t, e);
                    if (this.smoothing.update(r, e), this.smoothing.isStable) return this.setResult(this.smoothing.getResult(), e);
                }
            } ]);
        }(V);
        // ./node_modules/trading-signals/dist/BBANDS/BollingerBands.js
        function Jt(t) {
            return Jt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Jt(t);
        }
        function Zt(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function Qt(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, te(n.key), n);
            }
        }
        function Wt(t, e, r) {
            return e && Qt(t.prototype, e), r && Qt(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function Xt(t, e, r) {
            return (e = te(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function te(t) {
            var e = function(t, e) {
                if ("object" != Jt(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != Jt(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == Jt(e) ? e : e + "";
        }
        var ee =  function() {
            return Wt((function t(e) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
                Zt(this, t), Xt(this, "interval", void 0), Xt(this, "deviationMultiplier", void 0), 
                Xt(this, "prices", []), Xt(this, "result", void 0), this.interval = e, this.deviationMultiplier = r;
            }), [ {
                key: "update",
                value: function(t) {
                    if (this.prices.push(t), this.prices.length > this.interval) {
                        this.prices.shift();
                        var e = Pt(this.prices), r = function(t, e) {
                            var r = e || Pt(t), n = Pt(t.map((function(t) {
                                return t - r;
                            })).map((function(t) {
                                return t * t;
                            })));
                            return Math.sqrt(n);
                        }(this.prices, e);
                        return this.result = {
                            lower: e - r * this.deviationMultiplier,
                            middle: e,
                            upper: e + r * this.deviationMultiplier
                        };
                    }
                }
            }, {
                key: "getResult",
                value: function() {
                    if (void 0 === this.result) throw new M;
                    return this.result;
                }
            }, {
                key: "isStable",
                get: function() {
                    return void 0 !== this.result;
                }
            } ]);
        }();
        // ./node_modules/trading-signals/dist/EMA/EMA.js
        function re(t) {
            return re = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, re(t);
        }
        function ne(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function oe(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, ye(n.key), n);
            }
        }
        function ie(t, e, r) {
            return e && oe(t.prototype, e), r && oe(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function ae(t, e, r) {
            return e = le(e), function(t, e) {
                if (e && ("object" == re(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, ue() ? Reflect.construct(e, r || [], le(t).constructor) : e.apply(t, r));
        }
        function ue() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (ue = function() {
                return !!t;
            })();
        }
        function le(t) {
            return le = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, le(t);
        }
        function ce(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && se(t, e);
        }
        function se(t, e) {
            return se = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, se(t, e);
        }
        function fe(t, e, r) {
            return (e = ye(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function ye(t) {
            var e = function(t, e) {
                if ("object" != re(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != re(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == re(e) ? e : e + "";
        }
        var pe =  function(t) {
            function e(t) {
                var r;
                return ne(this, e), fe(r = ae(this, e, [ t ]), "interval", void 0), fe(r, "pricesCounter", 0), 
                fe(r, "weightFactor", void 0), r.interval = t, r.weightFactor = 2 / (r.interval + 1), 
                r;
            }
            return ce(e, t), ie(e, [ {
                key: "update",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    return e ? e && 0 === this.pricesCounter && this.pricesCounter++ : this.pricesCounter++, 
                    e && void 0 !== this.previousResult ? this.setResult(t * this.weightFactor + this.previousResult * (1 - this.weightFactor), e) : this.setResult(t * this.weightFactor + (void 0 !== this.result ? this.result : t) * (1 - this.weightFactor), e);
                }
            }, {
                key: "getResult",
                value: function() {
                    if (this.pricesCounter < this.interval) throw new M;
                    return this.result;
                }
            }, {
                key: "isStable",
                get: function() {
                    try {
                        return this.getResult(), !0;
                    } catch (t) {
                        return !1;
                    }
                }
            } ]);
        }(X);
        // ./node_modules/trading-signals/dist/MACD/MACD.js
        function he(t) {
            return he = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, he(t);
        }
        function ve(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function me(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, ge(n.key), n);
            }
        }
        function de(t, e, r) {
            return e && me(t.prototype, e), r && me(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function be(t, e, r) {
            return (e = ge(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function ge(t) {
            var e = function(t, e) {
                if ("object" != he(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != he(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == he(e) ? e : e + "";
        }
        var we =  function() {
            return de((function t(e, r, n) {
                ve(this, t), be(this, "short", void 0), be(this, "long", void 0), be(this, "signal", void 0), 
                be(this, "prices", []), be(this, "result", void 0), this.short = e, this.long = r, 
                this.signal = n;
            }), [ {
                key: "getResult",
                value: function() {
                    if (void 0 === this.result) throw new M;
                    return this.result;
                }
            }, {
                key: "isStable",
                get: function() {
                    return void 0 !== this.result;
                }
            }, {
                key: "update",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    this.prices.length && e ? this.prices[this.prices.length - 1] = t : this.prices.push(t);
                    var r = this.short.update(t, e), n = this.long.update(t, e);
                    if (this.prices.length > this.long.interval && this.prices.shift(), this.prices.length === this.long.interval) {
                        var o = r - n, i = this.signal.update(o, e);
                        return this.result = {
                            histogram: o - i,
                            macd: o,
                            signal: i
                        };
                    }
                }
            } ]);
        }();
        // ./node_modules/trading-signals/dist/RSI/RSI.js
        function Oe(t) {
            return Oe = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Oe(t);
        }
        function Se(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function je(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, xe(n.key), n);
            }
        }
        function Pe(t, e, r) {
            return e && je(t.prototype, e), r && je(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
        }
        function _e(t, e, r) {
            return e = Te(e), function(t, e) {
                if (e && ("object" == Oe(e) || "function" == typeof e)) return e;
                if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t;
                }(t);
            }(t, Ne() ? Reflect.construct(e, r || [], Te(t).constructor) : e.apply(t, r));
        }
        function Ne() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (Ne = function() {
                return !!t;
            })();
        }
        function Te(t) {
            return Te = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, Te(t);
        }
        function Ae(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && Ee(t, e);
        }
        function Ee(t, e) {
            return Ee = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, Ee(t, e);
        }
        function ke(t, e, r) {
            return (e = xe(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function xe(t) {
            var e = function(t, e) {
                if ("object" != Oe(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != Oe(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == Oe(e) ? e : e + "";
        }
        var Ie =  function(t) {
            function e(t) {
                var r, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : jt;
                return Se(this, e), ke(r = _e(this, e), "interval", void 0), ke(r, "previousPrices", []), 
                ke(r, "avgGain", void 0), ke(r, "avgLoss", void 0), ke(r, "maxValue", 100), r.interval = t, 
                r.avgGain = new n(r.interval), r.avgLoss = new n(r.interval), r;
            }
            return Ae(e, t), Pe(e, [ {
                key: "update",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if (this.previousPrices.length && e ? this.previousPrices[this.previousPrices.length - 1] = t : this.previousPrices.push(t), 
                    !(this.previousPrices.length < 2)) {
                        var r = t, n = this.previousPrices[this.previousPrices.length - 2];
                        if (r > n ? (this.avgLoss.update(0, e), this.avgGain.update(t - n, e)) : (this.avgLoss.update(n - r, e), 
                        this.avgGain.update(0, e)), this.avgGain.isStable) {
                            var o = this.avgLoss.getResult();
                            if (0 === o) return this.setResult(100, e);
                            var i = this.avgGain.getResult() / o;
                            return this.setResult(this.maxValue - this.maxValue / (i + 1), e);
                        }
                    }
                }
            } ]);
        }(V);
        // ./src/oscillators/rsi.js
        function De(t) {
            return De = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, De(t);
        }
        function Me(t, e, r) {
            return (e = function(t) {
                var e = function(t, e) {
                    if ("object" != De(t) || !t) return t;
                    var r = t[Symbol.toPrimitive];
                    if (void 0 !== r) {
                        var n = r.call(t, e || "default");
                        if ("object" != De(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === e ? String : Number)(t);
                }(t, "string");
                return "symbol" == De(e) ? e : e + "";
            }(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        var Re = {
            ema: pe,
            sma: ft
        }, Ce = function(t, e, r, n, o) {
            var i = o.target, a = (o.lag, o.precomputed), u = t.verticalOhlcv, l = t.instances, c = a.keyName;
            if (0 === e && !u.hasOwnProperty(i)) throw new Error("Target property ".concat(i, " not found in verticalOhlcv for ").concat(r, "."));
            // Retrieve the current price value.
                        var s = u[i][e], f = l[c];
            // Update the moving average instance.
            f.update(s);
            var y = NaN;
            try {
                y = f.getResult();
            } catch (t) {}
            // Always push the MA value (even if NaN).
                        return t.pushToMain({
                index: e,
                key: c,
                value: y
            }), !0;
        }, Fe = function(t) {
            var e = t.main, r = t.size, n = t.target, o = t.lag, i = t.methodName, a = e.instances, u = e.verticalOhlcv, l = e.priceBased, c = e.arrayTypes, s = e.len, f = "close" !== n ? "_".concat(n) : "", y = "".concat(i, "_").concat(r).concat(f);
            // Create the main moving average instance.
            return a[y] = new Re[i](r), u[y] = new Float64Array(s).fill(NaN), l.add(y), o > 0 && e.lag([ y ], o), 
            c[y] = "Float64Array", {
                keyName: y
            };
        };
        // ./src/moving-averages/macd.js
        function Le(t) {
            return Le = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Le(t);
        }
        function Be(t, e, r) {
            return (e = function(t) {
                var e = function(t, e) {
                    if ("object" != Le(t) || !t) return t;
                    var r = t[Symbol.toPrimitive];
                    if (void 0 !== r) {
                        var n = r.call(t, e || "default");
                        if ("object" != Le(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === e ? String : Number)(t);
                }(t, "string");
                return "symbol" == Le(e) ? e : e + "";
            }(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function He(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = function(t, e) {
                    if (t) {
                        if ("string" == typeof t) return Ve(t, e);
                        var r = {}.toString.call(t).slice(8, -1);
                        return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Ve(t, e) : void 0;
                    }
                }(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == r.return || r.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function Ve(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        var Ue = "close";
        // ./src/utilities/numberUtilities.js
        function $e(t) {
            return $e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, $e(t);
        }
        // Helper to clean non-numeric characters (except "-" at the start and decimal point)
        var qe = {
            number: function(t) {
                return t;
            },
            numberCleanString: function(t) {
                return Number(t);
            },
            numberDirtyString: function(t) {
                return Number(t.replace(/(?!^-)[^0-9.]/g, ""));
            }
        }, ze = function(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            // 1) true numbers
                        if ("number" == typeof t && !Number.isNaN(t)) return "number";
            // 2) strings
                        if ("string" == typeof t) {
                var r = t.trim(), n = /^-?\d+(\.\d+)?$/;
                // a) clean numeric string: only digits and an optional single period
                if (n.test(r)) return "numberCleanString";
                // b) dirty numeric string: contains non-digits (dollar, commas, letters, etc.)
                //    but once you strip those out, you're left with a valid number
                                var o = r.replace(/[^0-9.]/g, "");
                if (o && n.test(o)) return "numberDirtyString";
            }
            if (e) throw new TypeError("Invalid input: expected a number or numeric string");
            return $e(t);
        }, Ge = function(t, e) {
            var r = Math.pow(10, e);
            // add a tiny epsilon to mitigate floating-point quirks around .5
                        return Math.round((t + Number.EPSILON) * r) / r;
        };
        // ./src/moving-averages/donchianChannel.js
        function Ke(t) {
            return function(t) {
                if (Array.isArray(t)) return Je(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || Ye(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Ye(t, e) {
            if (t) {
                if ("string" == typeof t) return Je(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Je(t, e) : void 0;
            }
        }
        function Je(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        // ./src/moving-averages/bollingerBands.js
        function Ze(t) {
            return Ze = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Ze(t);
        }
        function Qe(t, e) {
            var r = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                e && (n = n.filter((function(e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable;
                }))), r.push.apply(r, n);
            }
            return r;
        }
        function We(t, e, r) {
            return (e = function(t) {
                var e = function(t, e) {
                    if ("object" != Ze(t) || !t) return t;
                    var r = t[Symbol.toPrimitive];
                    if (void 0 !== r) {
                        var n = r.call(t, e || "default");
                        if ("object" != Ze(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === e ? String : Number)(t);
                }(t, "string");
                return "symbol" == Ze(e) ? e : e + "";
            }(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function Xe(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = function(t, e) {
                    if (t) {
                        if ("string" == typeof t) return tr(t, e);
                        var r = {}.toString.call(t).slice(8, -1);
                        return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? tr(t, e) : void 0;
                    }
                }(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == r.return || r.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function tr(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        // ./src/oscillators/volumeOscillator.js
        function er(t) {
            return er = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, er(t);
        }
        function rr(t, e, r) {
            return (e = function(t) {
                var e = function(t, e) {
                    if ("object" != er(t) || !t) return t;
                    var r = t[Symbol.toPrimitive];
                    if (void 0 !== r) {
                        var n = r.call(t, e || "default");
                        if ("object" != er(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === e ? String : Number)(t);
                }(t, "string");
                return "symbol" == er(e) ? e : e + "";
            }(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        // ./src/utilities/dateUtilities.js
        function nr(t) {
            return nr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, nr(t);
        }
        var or = {
            string: function(t) {
                return t.toISOString();
            },
            milliseconds: function(t) {
                return t.getTime();
            },
            seconds: function(t) {
                return t.getTime() / 1e3;
            },
            object: function(t) {
                return t;
            }
        }, ir = {
            dateObject: function(t) {
                return t;
            },
            dateMilliseconds: function(t) {
                return new Date(t);
            },
            dateSeconds: function(t) {
                return new Date(1e3 * t);
            },
            dateIncompleteDayString: function(t) {
                return new Date("".concat(t, "  00:00:00"));
            },
            dateCompleteDateString: function(t) {
                return new Date(t);
            }
        }, ar = function(t) {
            // Regex for a UTC Time Format where the string ends with "Z".
            var e = [ "Date -> object", "Milliseconds Timestamp -> integer", "Seconds Timestamp -> integer", "UTC Time Format (ISO 8601) -> string", "Including a Timezone Offset (ISO 8601) -> string", "Local Time Format (ISO 8601) -> string", "YYYY/MM/DD or YYYY-MM-DD -> string" ], r = function() {
                throw new Error('Invalid "'.concat(nr(t), '" date value passed in selectDateFormatter. Supported formats: \n-').concat(e.join("\n- ")));
            };
            // Regex for a Timezone Offset Format,
            // which includes a plus or minus sign followed by HH:MM at the end.
                        if ("object" === nr(t)) {
                if (t instanceof Date && !isNaN(t.valueOf())) return "dateObject";
                r();
            } else {
                if ("number" == typeof t) 
                // Use a numeric threshold based on the absolute value: typically,
                // if the absolute value is below 1e11, then it's a seconds timestamp.
                // Otherwise, it's a milliseconds timestamp.
                return Math.abs(t) < 1e11 ? "dateSeconds" : "dateMillseconds";
                if ("string" == typeof t) {
                    if (/^\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(?:\.\d+)?Z$/i.test(t) || /^\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(?:\.\d+)?([+-]\d{2}:\d{2})$/.test(t) || /^\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(?:\.\d+)?$/.test(t) && t.length > 10 || /^\d{4}\/\d{2}\/\d{2}$/.test(t)) return "dateCompleteDateString";
                    if (/^\d{4}-\d{2}-\d{2}$/.test(t)) return "dateIncompleteDayString";
                    r();
                } else r();
            }
        };
        // ./src/utilities/assignTypes.js
        function ur(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, e) {
                var r = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != r) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (r = r.call(t)).next, 0 === e) {
                            if (Object(r) !== r) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(r)).done) && (u.push(n.value), u.length !== e); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != r.return && (a = r.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, e) || function(t, e) {
                if (t) {
                    if ("string" == typeof t) return lr(t, e);
                    var r = {}.toString.call(t).slice(8, -1);
                    return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? lr(t, e) : void 0;
                }
            }(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function lr(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        var cr = new Set([ "open", "high", "low", "close" ]), sr = function(t, e) {
            return "Array" === t ? new Array(e).fill(null) : "Float64Array" === t ? new Float64Array(e).fill(NaN) : "Int32Array" === t ? new Int32Array(e).fill(NaN) : void 0;
        };
        // ./src/studies/lag.js
        function fr(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, e) {
                var r = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != r) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (r = r.call(t)).next, 0 === e) {
                            if (Object(r) !== r) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(r)).done) && (u.push(n.value), u.length !== e); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != r.return && (a = r.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, e) || pr(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function yr(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = pr(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == r.return || r.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function pr(t, e) {
            if (t) {
                if ("string" == typeof t) return hr(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? hr(t, e) : void 0;
            }
        }
        function hr(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        var vr = function(t, e) {
            var r = t.instances, n = t.verticalOhlcv, o = t.len, i = t.arrayTypes, a = t.priceBased;
            if (0 === e) {
                var u, l = [], c = yr(t.inputParams);
                try {
                    for (c.s(); !(u = c.n()).done; ) {
                        var s = u.value;
                        "lag" === s.key && l.push(s.params);
                    }
                } catch (t) {
                    c.e(t);
                } finally {
                    c.f();
                }
                for (var f = 0, y = l; f < y.length; f++) {
                    var p, h = fr(y[f], 2), v = h[0], m = h[1], d = yr(v);
                    try {
                        for (d.s(); !(p = d.n()).done; ) {
                            var b = p.value;
                            if (a.has(b)) for (var g = 1; g <= m; g++) a.add("".concat(b, "_lag_").concat(g));
                        }
                    } catch (t) {
                        d.e(t);
                    } finally {
                        d.f();
                    }
                }
                r.lag = {
                    lagParams: l
                };
            }
            var w, O = yr(r.lag.lagParams);
            try {
                for (O.s(); !(w = O.n()).done; ) {
                    var S, j = fr(w.value, 2), P = j[0], _ = j[1], N = yr(P);
                    try {
                        for (N.s(); !(S = N.n()).done; ) {
                            var T = S.value, A = n[T];
                            // Initialize lagged arrays only on the first index
                            if (0 === e) for (var E = 1; E <= _; E++) {
                                var k = "".concat(T, "_lag_").concat(E);
                                if (!i.hasOwnProperty(T)) throw new Error('Lag processing invoked by "'.concat(T, '" expected arrayTypes to have a "').concat(T, '" property, but it wasnt found.'));
                                n[k] = sr(i[T], o), i[k] = i[T];
                            }
                            // Populate lagged values
                                                        for (var x = 1; x <= _; x++) {
                                var I = "".concat(T, "_lag_").concat(x), D = e - x, M = D <= 0 || void 0 === A[D] ? null : A[D];
                                t.pushToMain({
                                    index: e,
                                    key: I,
                                    value: M
                                });
                            }
                        }
                    } catch (t) {
                        N.e(t);
                    } finally {
                        N.f();
                    }
                }
            } catch (t) {
                O.e(t);
            } finally {
                O.f();
            }
            return !0;
        };
        // ./src/studies/findCrosses.js
        function mr(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = function(t, e) {
                    if (t) {
                        if ("string" == typeof t) return dr(t, e);
                        var r = {}.toString.call(t).slice(8, -1);
                        return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? dr(t, e) : void 0;
                    }
                }(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == r.return || r.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function dr(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        function br(t) {
            return br = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, br(t);
        }
        function gr(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, wr(n.key), n);
            }
        }
        function wr(t) {
            var e = function(t, e) {
                if ("object" != br(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != br(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }(t, "string");
            return "symbol" == br(e) ? e : e + "";
        }
        var Or = function(t, e) {
            return t > e;
        }, Sr = function(t, e) {
            return t < e;
        }, jr =  function() {
            return t = function t() {
                !function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                }(this, t), Object.assign(this, {
                    interval: 0,
                    prevState: .5,
                    prevFast: NaN,
                    prevSlow: NaN,
                    prevHigh: NaN,
                    prevLow: NaN,
                    areHighAndLowUndefined: !1,
                    crossIndexes: {
                        up: [],
                        down: []
                    }
                });
            }, (e = [ {
                key: "update",
                value: function(t, e) {
                    var r = e.fast, n = e.high, o = e.slow, i = e.low, a = this.prevState;
                    this.areHighAndLowUndefined || void 0 !== n && void 0 !== i || (this.areHighAndLowUndefined = !0), 
                    Number.isNaN(r) || Number.isNaN(o) || function(t, e) {
                        return t === e;
                    }(r, o) ? a = .5 : Or(r, o) ? a = this.areHighAndLowUndefined ? 1 : [ i, o, this.prevLow, this.prevSlow ].every((function(t) {
                        return !Number.isNaN(t);
                    })) && Sr(i, o) && Or(this.prevLow, this.prevSlow) ? 0 : 1 : Sr(r, o) && (a = this.areHighAndLowUndefined ? 0 : [ n, o, this.prevHigh, this.prevSlow ].every((function(t) {
                        return !Number.isNaN(t);
                    })) && Or(n, o) && Sr(this.prevHigh, this.prevSlow) ? 1 : 0), .5 === a ? this.interval = 0 : 1 === a ? this.prevState <= .5 ? this.interval = 1 : this.interval++ : 0 === a && (this.prevState >= .5 ? this.interval = -1 : this.interval--), 
                    1 === this.interval && this.crossIndexes.up.push(t), -1 === this.interval && this.crossIndexes.down.push(t), 
                    //save prev state
                    Object.assign(this, {
                        prevState: a,
                        prevFast: r,
                        prevSlow: o,
                        prevHigh: n,
                        prevLow: i
                    });
                }
            }, {
                key: "getResult",
                value: function() {
                    return this.interval;
                }
            } ]) && gr(t.prototype, e), r && gr(t, r), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
            var t, e, r;
        }(), Pr = function(t, e) {
            var r = t.verticalOhlcv, n = t.instances, o = t.len, i = t.arrayTypes, a = t.verticalOhlcvTempCols;
            if (0 === e) {
                var u = t.inputParams;
                n.crossPairsList = u.reduce((function(t, e) {
                    var r = e.key, n = e.params;
                    if ("crossPairs" === r) {
                        var o, i = mr(n);
                        try {
                            for (i.s(); !(o = i.n()).done; ) {
                                var a, u = mr(o.value);
                                try {
                                    for (u.s(); !(a = u.n()).done; ) {
                                        var l = a.value;
                                        t.push(l);
                                    }
                                } catch (t) {
                                    u.e(t);
                                } finally {
                                    u.f();
                                }
                            }
                        } catch (t) {
                            i.e(t);
                        } finally {
                            i.f();
                        }
                    }
                    return t;
                }), []);
            }
            var l, c = mr(n.crossPairsList);
            try {
                for (c.s(); !(l = c.n()).done; ) {
                    var s = l.value, f = s.fast, y = s.slow;
                    if (null != f && null != y) {
                        var p = "".concat(f, "_x_").concat(y);
                        if (0 === e) {
                            if ("number" == typeof y && (a.add(y.toString()), r[y.toString()] = new Int32Array(o).fill(y)), 
                            "price" !== f && !r.hasOwnProperty(f)) throw Error('fast "'.concat(f, ' not found in crossPairs"'));
                            if (!r.hasOwnProperty(y)) throw Error('slow "'.concat(y, ' not found in crossPairs"'));
                            n[p] = new jr, r[p] = new Int32Array(o).fill(NaN), i[p] = "Int32Array";
                        }
                        var h = void 0, v = void 0, m = void 0, d = void 0, b = void 0;
                        "price" === f ? (v = r.close[e], m = r.high[e], d = r.low[e], b = r[y][e], n[p].update(e, {
                            fast: v,
                            slow: b,
                            high: m,
                            low: d
                        })) : (h = r[f][e], b = r[y][e], n[p].update(e, {
                            fast: h,
                            slow: b
                        })), t.pushToMain({
                            index: e,
                            key: p,
                            value: n[p].getResult()
                        });
                    }
                }
            } catch (t) {
                c.e(t);
            } finally {
                c.f();
            }
        };
        // ./src/studies/dateTime.js
        function _r(t) {
            return _r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, _r(t);
        }
        function Nr(t, e) {
            var r = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                e && (n = n.filter((function(e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable;
                }))), r.push.apply(r, n);
            }
            return r;
        }
        function Tr(t, e, r) {
            return (e = function(t) {
                var e = function(t, e) {
                    if ("object" != _r(t) || !t) return t;
                    var r = t[Symbol.toPrimitive];
                    if (void 0 !== r) {
                        var n = r.call(t, e || "default");
                        if ("object" != _r(n)) return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === e ? String : Number)(t);
                }(t, "string");
                return "symbol" == _r(e) ? e : e + "";
            }(e)) in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        var Ar = function(t) {
            var e = t.getMonth(), r = t.getFullYear(), n = t.getHours(), o = t.getMinutes(), i = t.getDay(), a = t.getDate(), u = new Date(t.getFullYear(), t.getMonth(), 1).getDay();
            return {
                month: e,
                year: r,
                hour: n,
                minute: o,
                day_of_the_week: i,
                day_of_the_month: a,
                week_of_the_month: Math.ceil((a + u) / 7)
            };
        };
        // ./src/studies/scaler.js
        function Er(t) {
            return function(t) {
                if (Array.isArray(t)) return Dr(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || Ir(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function kr(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = Ir(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == r.return || r.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function xr(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }
            /* General scaler: supports "minmax" and "zscore" types */ (t) || function(t, e) {
                var r = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != r) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (r = r.call(t)).next, 0 === e) {
                            if (Object(r) !== r) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(r)).done) && (u.push(n.value), u.length !== e); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != r.return && (a = r.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, e) || Ir(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Ir(t, e) {
            if (t) {
                if ("string" == typeof t) return Dr(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Dr(t, e) : void 0;
            }
        }
        function Dr(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        // ./src/core-functions/mainLoop.js
        function Mr(t) {
            return function(t) {
                if (Array.isArray(t)) return Lr(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || Fr(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Rr(t, e) {
            var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!r) {
                if (Array.isArray(t) || (r = Fr(t)) || e && t && "number" == typeof t.length) {
                    r && (t = r);
                    var n = 0, o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return n >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[n++]
                            };
                        },
                        e: function(t) {
                            throw t;
                        },
                        f: o
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i, a = !0, u = !1;
            return {
                s: function() {
                    r = r.call(t);
                },
                n: function() {
                    var t = r.next();
                    return a = t.done, t;
                },
                e: function(t) {
                    u = !0, i = t;
                },
                f: function() {
                    try {
                        a || null == r.return || r.return();
                    } finally {
                        if (u) throw i;
                    }
                }
            };
        }
        function Cr(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }
            // Map indicator keys to their respective functions
            (t) || function(t, e) {
                var r = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != r) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (r = r.call(t)).next, 0 === e) {
                            if (Object(r) !== r) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(r)).done) && (u.push(n.value), u.length !== e); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != r.return && (a = r.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, e) || Fr(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Fr(t, e) {
            if (t) {
                if ("string" == typeof t) return Lr(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Lr(t, e) : void 0;
            }
        }
        function Lr(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        var Br = {
            dateTime: function(t, e, r) {
                var n = r.lag, o = t.instances, i = t.verticalOhlcv;
                if (0 === e) {
                    var a = t.len, u = t.dateType, l = t.arrayTypes;
                    if (!u) throw Error('dateTime method found and invalid "date" in input ohlcv');
                    Object.assign(o, {
                        dateTime: {
                            prevDateStr: i.date[0],
                            sessionDailyIndexCount: 0,
                            sessionIntradayIndexCount: 0,
                            cachedDayInfo: i.date[0]
                        }
                    });
                    for (var c = [ "day_of_the_week", "day_of_the_month", "week_of_the_month", "minute", "hour", "month", "year", "session_daily_index", "session_intraday_index" ], s = 0, f = c; s < f.length; s++) {
                        l[f[s]] = "Int32Array";
                    }
                    Object.assign(i, function(t) {
                        for (var e = 1; e < arguments.length; e++) {
                            var r = null != arguments[e] ? arguments[e] : {};
                            e % 2 ? Nr(Object(r), !0).forEach((function(e) {
                                Tr(t, e, r[e]);
                            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Nr(Object(r)).forEach((function(e) {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));
                            }));
                        }
                        return t;
                    }({}, Object.fromEntries(c.map((function(t) {
                        return [ t, new Int32Array(a).fill(NaN) ];
                    }))))), n > 0 && t.lag(c, n);
                }
                var y = i.date[e], p = Ar(y), h = p.day_of_the_week, v = p.day_of_the_month, m = p.week_of_the_month, d = p.month, b = p.year, g = p.hour, w = p.minute, O = y;
                O !== o.dateTime.prevDateStr && (o.dateTime.prevDateStr = O, o.dateTime.sessionDailyIndexCount++, 
                o.dateTime.sessionIntradayIndexCount = 0), t.pushToMain({
                    index: e,
                    key: "session_daily_index",
                    value: o.dateTime.sessionDailyIndexCount
                }), t.pushToMain({
                    index: e,
                    key: "session_intraday_index",
                    value: o.dateTime.sessionIntradayIndexCount
                }), t.pushToMain({
                    index: e,
                    key: "day_of_the_week",
                    value: h
                }), t.pushToMain({
                    index: e,
                    key: "day_of_the_month",
                    value: v
                }), t.pushToMain({
                    index: e,
                    key: "week_of_the_month",
                    value: m
                }), t.pushToMain({
                    index: e,
                    key: "month",
                    value: d
                }), t.pushToMain({
                    index: e,
                    key: "year",
                    value: b
                }), t.pushToMain({
                    index: e,
                    key: "hour",
                    value: g
                }), t.pushToMain({
                    index: e,
                    key: "minute",
                    value: w
                }), o.dateTime.sessionIntradayIndexCount++;
            },
            rsi: function(t, e, r, n) {
                var o = n.target, i = n.lag, a = t.verticalOhlcv, u = t.instances, l = "close" === o ? "" : "_".concat(o), c = "rsi_".concat(r).concat(l), s = "rsi_sma_".concat(r).concat(l);
                // Initialization on the first index.
                if (0 === e) {
                    var f = t.crossPairsList, y = t.len, p = t.arrayTypes;
                    if (!a.hasOwnProperty(o)) throw new Error("Target property ".concat(o, " not found in verticalOhlcv for rsi."));
                    f.push({
                        fast: c,
                        slow: s,
                        isDefault: !0
                    }), Object.assign(u, Me(Me({}, c, new Ie(r)), s, new ft(r))), Object.assign(a, Me(Me({}, c, new Float64Array(y).fill(NaN)), s, new Float64Array(y).fill(NaN)));
                    var h = [ c, s ];
                    i > 0 && t.lag(h, i);
                    for (var v = 0, m = h; v < m.length; v++) {
                        p[m[v]] = "Float64Array";
                    }
                }
                var d = a[o][e], b = NaN, g = NaN;
                // Update the RSI indicator.
                u[c].update(d);
                try {
                    b = u[c].getResult();
                } catch (t) {
                    b = NaN;
                }
                // Always push the RSI value, using NaN as a fallback.
                                t.pushToMain({
                    index: e,
                    key: c,
                    value: b
                }), 
                // Update the SMA indicator only if a valid RSI value is available.
                Number.isNaN(b) || u[s].update(b);
                try {
                    g = u[s].getResult();
                } catch (t) {
                    g = NaN;
                }
                // Always push the smoothed RSI value.
                                t.pushToMain({
                    index: e,
                    key: s,
                    value: g
                });
            },
            atr: function(t, e, r, n) {
                var o = n.lag, i = n.type, a = t.verticalOhlcv, u = t.instances, l = "percentage" === i ? "atr_".concat(r, "_percentage") : "atr_".concat(r);
                if (0 === e) {
                    var c = t.instances, s = t.verticalOhlcv, f = t.arrayTypes, y = t.len, p = t.priceBased;
                    c[l] = new Yt(r, jt), "price" === i && p.add(l), s[l] = new Float64Array(y).fill(NaN), 
                    f[l] = "Float64Array", o > 0 && t.lag([ l ], o);
                }
                // Retrieve the current price value.
                                var h = {
                    high: a.high[e],
                    low: a.low[e],
                    close: a.close[e]
                }, v = u[l];
                // Update the moving average instance.
                v.update(h);
                var m = NaN;
                try {
                    m = v.getResult();
                } catch (t) {}
                return "percentage" === i && (m = Number.isNaN(m) ? NaN : m / h.close), 
                // Always push the MA value (even if NaN).
                t.pushToMain({
                    index: e,
                    key: l,
                    value: m
                }), !0;
            },
            ema: Ce,
            sma: Ce,
            macd: function(t, e, r, n, o, i) {
                var a = i.target, u = i.lag, l = i.precomputed, c = t.verticalOhlcv, s = t.instances, f = l.instanceKey;
                // Initialization on the first index.
                if (0 === e) {
                    var y = t.inputParams, p = t.crossPairsList, h = t.priceBased, v = t.len, m = t.arrayTypes;
                    if (!c.hasOwnProperty(a)) throw new Error("Target property ".concat(a, " not found in verticalOhlcv for macd."));
                    var d, b = 0, g = He(y);
                    try {
                        for (g.s(); !(d = g.n()).done; ) {
                            "macd" === d.value.key && b++;
                        }
                        // Choose a display prefix based on the number of indicators.
                                        } catch (t) {
                        g.e(t);
                    } finally {
                        g.f();
                    }
                    var w = b > 1 ? "macd_".concat(r, "_").concat(n, "_").concat(o) : "macd", O = a === Ue ? "".concat(w, "_diff") : "".concat(w, "_diff_").concat(a), S = a === Ue ? "".concat(w, "_dea") : "".concat(w, "_dea_").concat(a), j = a === Ue ? "".concat(w, "_histogram") : "".concat(w, "_histogram_").concat(a);
                    // Build the keys.
                                        p.push({
                        fast: O,
                        slow: S,
                        isDefault: !0
                    }), s.hasOwnProperty("macd") || (s.macd = {
                        numberOfIndicators: b,
                        settings: {}
                    }), s.macd.settings[f] = new we(new pe(r), new pe(n), new pe(o)), Object.assign(c, Be(Be(Be({}, O, new Float64Array(v).fill(NaN)), S, new Float64Array(v).fill(NaN)), j, new Float64Array(v).fill(NaN)))[j].forEach((function(t) {
                        h.add(t);
                    }));
                    var P = [ O, S, j ];
                    u > 0 && t.lag(P, u);
                    for (var _ = 0, N = P; _ < N.length; _++) {
                        m[N[_]] = "Float64Array";
                    }
                }
                var T = s.macd, A = T.numberOfIndicators, E = T.settings, k = A > 1 ? "macd_".concat(r, "_").concat(n, "_").concat(o) : "macd", x = a === Ue ? "".concat(k, "_diff") : "".concat(k, "_diff_").concat(a), I = a === Ue ? "".concat(k, "_dea") : "".concat(k, "_dea_").concat(a), D = a === Ue ? "".concat(k, "_histogram") : "".concat(k, "_histogram_").concat(a), M = E[f], R = c[a][e];
                M.update(R);
                var C = {};
                try {
                    C = M.getResult();
                } catch (t) {
                    // If the result is unavailable, macdResult remains NaN.
                }
                // Always push values; use NaN as fallback when macdResult is missing.
                                return t.pushToMain({
                    index: e,
                    key: x,
                    value: C ? C.macd : NaN
                }), t.pushToMain({
                    index: e,
                    key: I,
                    value: C ? C.signal : NaN
                }), t.pushToMain({
                    index: e,
                    key: D,
                    value: C ? C.histogram : NaN
                }), !0;
            },
            relativeVolume: function(t, e, r, n) {
                var o = n.lag, i = "relative_volume_".concat(r), a = t.instances, u = t.verticalOhlcv;
                if (0 === e) {
                    var l = t.len, c = t.arrayTypes;
                    a[i] = {
                        instance: new ft(r),
                        prevRelativeVolumeSma: NaN
                    }, u[i] = new Float64Array(l).fill(NaN), o > 0 && t.lag([ i ], o), c[i] = "Float64Array";
                }
                var s = u.volume[e], f = a[i].instance;
                f.update(s);
                var y = NaN;
                try {
                    y = f.getResult();
                } catch (t) {}
                var p = a[i].prevRelativeVolumeSma, h = NaN;
                // Only calculate relative volume if both current SMA and previous SMA are valid numbers and prevSma is not zero.
                return Number.isNaN(y) || Number.isNaN(p) || (h = s / p), t.pushToMain({
                    index: e,
                    key: i,
                    value: h
                }), a[i].prevRelativeVolumeSma = y, !0;
            },
            donchianChannels: function(t, e, r, n, o) {
                var i = t.verticalOhlcv, a = t.instances, u = t.len, l = t.inputParams, c = t.priceBased, s = t.arrayTypes, f = t.lag, y = o.height, p = o.range, h = o.decimals, v = "".concat(r, "_").concat(n);
                // ---- INIT (only at first bar) ----
                if (0 === e) {
                    // how many donchianChannels calls in this session?
                    var m = l.filter((function(t) {
                        return "donchianChannels" === t.key;
                    })).length, d = "donchian_channel", b = m > 1 ? "".concat(d, "_").concat(v) : d, g = [ "upper", "basis", "lower" ].map((function(t) {
                        return "".concat(b, "_").concat(t);
                    }));
                    y && g.push("".concat(b, "_height"));
                    var w, O = function(t, e) {
                        var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!r) {
                            if (Array.isArray(t) || (r = Ye(t)) || e && t && "number" == typeof t.length) {
                                r && (t = r);
                                var n = 0, o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return n >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[n++]
                                        };
                                    },
                                    e: function(t) {
                                        throw t;
                                    },
                                    f: o
                                };
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }
                        var i, a = !0, u = !1;
                        return {
                            s: function() {
                                r = r.call(t);
                            },
                            n: function() {
                                var t = r.next();
                                return a = t.done, t;
                            },
                            e: function(t) {
                                u = !0, i = t;
                            },
                            f: function() {
                                try {
                                    a || null == r.return || r.return();
                                } finally {
                                    if (u) throw i;
                                }
                            }
                        };
                    }(p);
                    try {
                        for (O.s(); !(w = O.n()).done; ) {
                            var S = w.value;
                            if (!(S in i) || !c.has(S)) throw new Error('Invalid range key "'.concat(S, '". Only price-based keys are allowed: ').concat(Ke(c)));
                            g.push("".concat(b, "_range_").concat(S));
                        }
                        // bootstrap instance
                                        } catch (t) {
                        O.e(t);
                    } finally {
                        O.f();
                    }
                    a.donchian_channel || (a.donchian_channel = {
                        numberOfIndicators: m,
                        settings: {}
                    }), a.donchian_channel.numberOfIndicators = m, a.donchian_channel.settings[v] = {
                        maxDeque: [],
                        minDeque: []
                    }, 
                    // allocate & fill NaNs
                    Object.assign(i, Object.fromEntries(g.map((function(t) {
                        return [ t, new Float64Array(u).fill(NaN) ];
                    })))), 
                    // apply lag if requested
                    f > 0 && t.lag(g, f), 
                    // mark price-based outputs
                    [ "upper", "basis", "lower" ].forEach((function(t) {
                        return c.add("".concat(b, "_").concat(t));
                    })), g.forEach((function(t) {
                        return s[t] = "Float64Array";
                    }));
                }
                // ---- PER-BAR COMPUTATION ----
                                var j = a.donchian_channel, P = j.numberOfIndicators, _ = j.settings, N = P > 1 ? "donchian_channel_".concat(v) : "donchian_channel", T = _[v], A = T.maxDeque, E = T.minDeque, k = e - n, x = k - r + 1, I = [ "upper", "basis", "lower" ].map((function(t) {
                    return "".concat(N, "_").concat(t);
                }));
                y && I.push("".concat(N, "_height"));
                var D = p.map((function(t) {
                    return "".concat(N, "_range_").concat(t);
                }));
                // not enough data  push NaNs
                                if (x < 0 || k + 1 > u) return [].concat(Ke(I), Ke(D)).forEach((function(r) {
                    return t.pushToMain({
                        index: e,
                        key: r,
                        value: NaN
                    });
                })), !0;
                var M = i.high, R = i.low, C = function(t, e, r) {
                    for (;t.length && t[0] < x; ) t.shift();
                    for (;t.length && r(e[t.at(-1)], e[k]); ) t.pop();
                    t.push(k);
                };
                // tiny helper to keep deques up-to-date
                                C(A, M, (function(t, e) {
                    return t <= e;
                })), C(E, R, (function(t, e) {
                    return t >= e;
                }));
                // single bounds exist? flag instead of repeated isNaN
                var F = A.length && E.length, L = F ? M[A[0]] : NaN, B = F ? R[E[0]] : NaN, H = F ? (L + B) / 2 : NaN;
                if (t.pushToMain({
                    index: e,
                    key: "".concat(N, "_upper"),
                    value: L
                }), t.pushToMain({
                    index: e,
                    key: "".concat(N, "_basis"),
                    value: H
                }), t.pushToMain({
                    index: e,
                    key: "".concat(N, "_lower"),
                    value: B
                }), y) {
                    // avoid divide-by-zero
                    var V = F && B ? (L - B) / B : NaN;
                    t.pushToMain({
                        index: e,
                        key: "".concat(N, "_height"),
                        value: null === h ? V : Ge(V, h)
                    });
                }
                // precompute spread once
                                // for each extra range key, use price===price to skip NaNs
                for (var U = F ? L - B : NaN, $ = 0; $ < p.length; $++) {
                    var q = i[p[$]][e], z = F && q == q && U ? (q - B) / U : NaN;
                    t.pushToMain({
                        index: e,
                        key: D[$],
                        value: null === h ? z : Ge(z, h)
                    });
                }
                return !0;
            },
            bollingerBands: function(t, e, r, n, o) {
                var i, a, u, l, c, s, f, y = o.height, p = o.range, h = void 0 === p ? [] : p, v = o.target, m = o.lag, d = o.decimals, b = t.verticalOhlcv, g = t.instances, w = "close" === v ? "" : "_".concat(v), O = "".concat(r, "_").concat(n).concat(w);
                // Initialization on the first call.
                if (0 === e) {
                    var S = t.priceBased, j = t.inputParams, P = t.verticalOhlcv, _ = t.len, N = t.arrayTypes;
                    if (!(v in P)) throw new Error('bollingerBands could not find target "'.concat(v, '"'));
                    var T, A = 0, E = Xe(j);
                    try {
                        for (E.s(); !(T = E.n()).done; ) {
                            "bollingerBands" === T.value.key && A++;
                        }
                    } catch (t) {
                        E.e(t);
                    } finally {
                        E.f();
                    }
                    f = A > 1 ? "bollinger_bands_".concat(O) : "bollinger_bands".concat(w), 
                    // Only create the container if it doesn't already exist.
                    g.bollinger_bands || (g.bollinger_bands = {
                        numberOfIndicators: A,
                        settings: {}
                    }), 
                    // Add (or override) the indicator instance keyed by indicatorKey.
                    g.bollinger_bands.settings[O] = new ee(r, n);
                    var k = [ "".concat(f, "_upper"), "".concat(f, "_middle"), "".concat(f, "_lower") ];
                    y && k.push("".concat(f, "_height"));
                    // Set up additional arrays for each range property.
                                        var x, I = Xe(h);
                    try {
                        for (I.s(); !(x = I.n()).done; ) {
                            var D = x.value;
                            if (!(D in P) || !S.has(D)) throw new Error('Invalid range item value "'.concat(D, '" property for bollingerBands. Only price based key names are accepted:\n').concat(JSON.stringify(S)));
                            k.push("".concat(f, "_range_").concat(D));
                        }
                    } catch (t) {
                        I.e(t);
                    } finally {
                        I.f();
                    }
                    var M = Object.fromEntries(k.map((function(t) {
                        return [ t, new Float64Array(_).fill(NaN) ];
                    })));
                    Object.assign(P, function(t) {
                        for (var e = 1; e < arguments.length; e++) {
                            var r = null != arguments[e] ? arguments[e] : {};
                            e % 2 ? Qe(Object(r), !0).forEach((function(e) {
                                We(t, e, r[e]);
                            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Qe(Object(r)).forEach((function(e) {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));
                            }));
                        }
                        return t;
                    }({}, M)), m > 0 && t.lag(k, m), [ "".concat(f, "_upper"), "".concat(f, "_middle"), "".concat(f, "_lower") ].forEach((function(t) {
                        S.add(t);
                    }));
                    for (var R = 0, C = k; R < C.length; R++) {
                        N[C[R]] = "Float64Array";
                    }
                }
                // Derive prefix for subsequent calls if not set.
                                f || (f = g.bollinger_bands.numberOfIndicators > 1 ? "bollinger_bands_".concat(O) : "bollinger_bands".concat(w));
                var F = f, L = g.bollinger_bands.settings[O], B = b[v][e];
                // Update the indicator with the current value.
                                L.update(B);
                // Attempt to retrieve the result.
                var H = {};
                try {
                    H = L.getResult();
                } catch (t) {
                    // If not available, result stays {}.
                }
                // Use NaN fallbacks for the primary values.
                                var V = null !== (i = null === (a = H) || void 0 === a ? void 0 : a.upper) && void 0 !== i ? i : NaN, U = null !== (u = null === (l = H) || void 0 === l ? void 0 : l.middle) && void 0 !== u ? u : NaN, $ = null !== (c = null === (s = H) || void 0 === s ? void 0 : s.lower) && void 0 !== c ? c : NaN;
                // Process height if requested.
                if (
                // Always push the indicator outputs.
                t.pushToMain({
                    index: e,
                    key: "".concat(F, "_upper"),
                    value: V
                }), t.pushToMain({
                    index: e,
                    key: "".concat(F, "_middle"),
                    value: U
                }), t.pushToMain({
                    index: e,
                    key: "".concat(F, "_lower"),
                    value: $
                }), y) {
                    var q = NaN;
                    Number.isNaN($) || Number.isNaN(V) || (q = (V - $) / $), t.pushToMain({
                        index: e,
                        key: "".concat(F, "_height"),
                        value: null === d ? q : Ge(q, d)
                    });
                }
                // Process each range property.
                                var z, G = Xe(h);
                try {
                    for (G.s(); !(z = G.n()).done; ) {
                        var K = z.value, Y = NaN, J = b[K][e];
                        Number.isNaN(J) || Number.isNaN($) || Number.isNaN(V) || (Y = (J - $) / (V - $)), 
                        t.pushToMain({
                            index: e,
                            key: "".concat(F, "_range_").concat(K),
                            value: null === d ? Y : Ge(Y, d)
                        });
                    }
                } catch (t) {
                    G.e(t);
                } finally {
                    G.f();
                }
                return !0;
            },
            volumeOscillator: function(t, e, r, n, o) {
                var i = o.lag, a = t.verticalOhlcv, u = t.instances, l = a.volume[e], c = "volume_oscillator_".concat(r, "_").concat(n);
                if (0 === e) {
                    var s = t.crossPairsList, f = t.len, y = t.arrayTypes;
                    Object.assign(u, rr({}, c, {
                        fastEMA: new pe(r),
                        slowEMA: new pe(n)
                    })), a[c] = new Float64Array(f).fill(NaN), s.push({
                        fast: c,
                        slow: 0,
                        isDefault: !0
                    }), i > 0 && t.lag([ c ], i), y[c] = "Float64Array";
                }
                var p = u[c], h = p.fastEMA, v = p.slowEMA;
                h.update(l), v.update(l);
                var m = NaN, d = NaN;
                try {
                    m = h.getResult();
                } catch (t) {}
                try {
                    d = v.getResult();
                } catch (t) {}
                var b = NaN;
                return Number.isNaN(m) || Number.isNaN(d) || (b = 100 * (m - d) / d), t.pushToMain({
                    index: e,
                    key: c,
                    value: b
                }), !0;
            },
            scaler: function(t, e, r, n, o) {
                var i = o.type, a = o.group, u = o.range, l = o.lag, c = o.precomputed, s = o.decimals, f = c.groupKey, y = c.groupKeyLen, p = t.verticalOhlcv, h = t.instances, v = t.arrayTypes, m = "".concat(i, "_").concat(r);
                if (0 === e) {
                    var d = t.len;
                    h.hasOwnProperty("scaler") || (h.scaler = {
                        windows: {}
                    });
                    var b, g = kr(n);
                    try {
                        var w = function() {
                            var e = b.value;
                            if (!p.hasOwnProperty(e)) throw new Error('Target property "'.concat(e, '" not found in verticalOhlcv'));
                            var r = "".concat(m, "_").concat(e);
                            p[r] = new Float64Array(d).fill(NaN), v[r] = "Float64Array";
                            var n = a ? f : e;
                            if (h.scaler.windows[n] = [], a && (t.scaledGroups[f] || (t.scaledGroups[f] = []), 
                            t.scaledGroups[f].push(r)), l > 0) {
                                if (a) {
                                    var o, i = Array.from({
                                        length: l
                                    }).map((function(t, e) {
                                        return "".concat(r, "_lag_").concat(e + 1);
                                    }));
                                    (o = t.scaledGroups[f]).push.apply(o, Er(i));
                                }
                                t.lag([ r ], l);
                            }
                        };
                        for (g.s(); !(b = g.n()).done; ) w();
                    } catch (t) {
                        g.e(t);
                    } finally {
                        g.f();
                    }
                }
                var O, S = h.scaler.windows, j = kr(n);
                // update windows with current values
                                try {
                    for (j.s(); !(O = j.n()).done; ) {
                        var P = O.value, _ = p[P][e], N = S[a ? f : P];
                        N.push(_), N.length > (a ? r * y : r) && N.shift();
                    }
                } catch (t) {
                    j.e(t);
                } finally {
                    j.f();
                }
                var T, A = e + 1 >= r, E = kr(n);
                // scale values once enough data
                                try {
                    var k = function() {
                        var r, n, o, l, c, y, h = T.value, v = p[h][e], d = "".concat(m, "_").concat(h), b = null;
                        if (A) {
                            var g = S[a ? f : h];
                            if ("minmax" === i) {
                                var w = Math.min.apply(Math, Er(g)), O = Math.max.apply(Math, Er(g));
                                r = v, n = w, o = O, l = xr(u, 2), c = l[0], y = l[1], b = (Math.min(Math.max(r, n), o) - n) / (o - n) * (y - c) + c;
                            } else {
                                if ("zscore" !== i) throw new Error('Unknown scaler type "'.concat(i, '"'));
                                var j = g.reduce((function(t, e) {
                                    return t + e;
                                }), 0) / g.length, P = g.reduce((function(t, e) {
                                    return t + Math.pow(e - j, 2);
                                }), 0) / g.length, _ = Math.sqrt(P);
                                b = function(t, e, r) {
                                    return 0 === r ? 0 : (t - e) / r;
                                }(v, j, _);
                            }
                        }
                        t.pushToMain({
                            index: e,
                            key: d,
                            value: null === s ? b : Ge(b, s)
                        });
                    };
                    for (E.s(); !(T = E.n()).done; ) k();
                } catch (t) {
                    E.e(t);
                } finally {
                    E.f();
                }
            }
        }, Hr = function(t, e) {
            for (var r = t.length, n = new ft(e), o = new Array(r), i = 0, a = 0, u = 0, l = 0; l < r; l++) if (n.update(t[l]), 
            n.isStable) {
                var c = n.getResult();
                o[l] = c, i += c, a += c * c, u++;
            } else o[l] = null;
            var s = i / u, f = a / u - s * s, y = Math.sqrt(f);
            return o.map((function(t) {
                return null !== t ? (t - s) / y : null;
            }));
        }, Vr = function(t, e) {
            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5;
            if (t.length !== e.length) throw new Error("Both arrays must have the same length");
            for (var n = Hr(t, r), o = Hr(e, r), i = t.length, a = [], u = 0, l = 0, c = 0, s = 0, f = 0, y = 0, p = -1, h = 0; h < i; h++) {
                if (null !== n[h] && null !== o[h]) {
                    p = h;
                    break;
                }
                a.push(0);
            }
            if (-1 === p) 
            // No valid data points
            return new Array(i).fill(0);
            for (var v = p; v < i; v++) {
                var m = n[v], d = o[v];
                if (null !== m && null !== d) if (u += m, l += d, c += m * d, s += m * m, f += d * d, 
                ++y < 2) a.push(0); else {
                    var b = y * c - u * l, g = Math.sqrt((y * s - u * u) * (y * f - l * l)), w = 0 === g ? 0 : b / g;
                    a.push(w);
                } else 
                // Reset sums and counts when encountering null values
                u = l = c = s = f = y = 0, a.push(0);
            }
            return a;
        };
        // ./src/utilities/verticalToHorizontal.js
        function Ur(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, e) {
                var r = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != r) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (r = r.call(t)).next, 0 === e) {
                            if (Object(r) !== r) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(r)).done) && (u.push(n.value), u.length !== e); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != r.return && (a = r.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, e) || function(t, e) {
                if (t) {
                    if ("string" == typeof t) return $r(t, e);
                    var r = {}.toString.call(t).slice(8, -1);
                    return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? $r(t, e) : void 0;
                }
            }(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function $r(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        var qr = function(t) {
            var e = t.main, r = t.skipNull, n = void 0 !== r && r, o = t.startIndex, i = void 0 === o ? 0 : o, a = t.dateFormat, u = e.precisionMultiplier, l = e.priceBased, c = e.precision, s = e.verticalOhlcv, f = e.invalidValueIndex, y = e.len, p = e.verticalOhlcvKeyNames, h = e.verticalOhlcvTempCols;
            if (0 === p.length) return [];
            for (var v = n && f >= 0 ? f + 1 : 0, m = Math.max(v, i), d = y - m, b = Array.from({
                length: d
            }, (function() {
                return {};
            })), g = 0, w = Object.entries(s); g < w.length; g++) {
                var O = Ur(w[g], 2), S = O[0], j = O[1];
                if (!h.has(S)) for (var P = l.has(S) && c, _ = m; _ < y; _++) b[_ - m][S] = P ? j[_] / u : "date" === S ? or[a](j[_]) : j[_];
            }
            return b;
        };
        function zr(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, e) {
                var r = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != r) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (r = r.call(t)).next, 0 === e) {
                            if (Object(r) !== r) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(r)).done) && (u.push(n.value), u.length !== e); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != r.return && (a = r.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, e) || Gr(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Gr(t, e) {
            if (t) {
                if ("string" == typeof t) return Kr(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Kr(t, e) : void 0;
            }
        }
        function Kr(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        var Yr = function(t, e) {
            var r = t.precision, n = t.priceBased;
            if (!1 === r) return 1;
            var o, i = 1, a = // ./src/utilities/precisionMultiplier.js
            function(t, e) {
                var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (!r) {
                    if (Array.isArray(t) || (r = Gr(t)) || e && t && "number" == typeof t.length) {
                        r && (t = r);
                        var n = 0, o = function() {};
                        return {
                            s: o,
                            n: function() {
                                return n >= t.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t[n++]
                                };
                            },
                            e: function(t) {
                                throw t;
                            },
                            f: o
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var i, a = !0, u = !1;
                return {
                    s: function() {
                        r = r.call(t);
                    },
                    n: function() {
                        var t = r.next();
                        return a = t.done, t;
                    },
                    e: function(t) {
                        u = !0, i = t;
                    },
                    f: function() {
                        try {
                            a || null == r.return || r.return();
                        } finally {
                            if (u) throw i;
                        }
                    }
                };
            }(Object.entries(e).filter((function(t) {
                var e = zr(t, 2), r = e[0];
                e[1];
                return n.has(r);
            })).map((function(t) {
                var e = zr(t, 2);
                e[0];
                return e[1];
            })));
            try {
                for (a.s(); !(o = a.n()).done; ) {
                    var u = o.value, l = zr(String(u).split("."), 2)[1], c = void 0 === l ? "" : l, s = Math.max(4, c.length), f = s > 1 ? Math.pow(10, s - 1) : 1;
                    f > i && (i = f);
                }
            } catch (t) {
                a.e(t);
            } finally {
                a.f();
            }
            return i;
        };
        // ./index.js
        function Jr(t) {
            return Jr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, Jr(t);
        }
        function Zr(t) {
            return function(t) {
                if (Array.isArray(t)) return Xr(t);
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }(t) || Wr(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Qr(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t;
            }(t) || function(t, e) {
                var r = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != r) {
                    var n, o, i, a, u = [], l = !0, c = !1;
                    try {
                        if (i = (r = r.call(t)).next, 0 === e) {
                            if (Object(r) !== r) return;
                            l = !1;
                        } else for (;!(l = (n = i.call(r)).done) && (u.push(n.value), u.length !== e); l = !0) ;
                    } catch (t) {
                        c = !0, o = t;
                    } finally {
                        try {
                            if (!l && null != r.return && (a = r.return(), Object(a) !== a)) return;
                        } finally {
                            if (c) throw o;
                        }
                    }
                    return u;
                }
            }(t, e) || Wr(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
        }
        function Wr(t, e) {
            if (t) {
                if ("string" == typeof t) return Xr(t, e);
                var r = {}.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Xr(t, e) : void 0;
            }
        }
        function Xr(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
            return n;
        }
        function tn(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, en(n.key), n);
            }
        }
        function en(t) {
            var e = function(t, e) {
                if ("object" != Jr(t) || !t) return t;
                var r = t[Symbol.toPrimitive];
                if (void 0 !== r) {
                    var n = r.call(t, e || "default");
                    if ("object" != Jr(n)) return n;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === e ? String : Number)(t);
            }
            //precomputed
            /**
 * Class OHLCV_INDICATORS
 *
 * This class provides methods for calculating and managing technical indicators 
 * on financial OHLCV (Open, High, Low, Close, Volume) data. It enables users 
 * to parallel compute various technical indicators in 1 single loop.
 * OHLCV datasets.
 */ (t, "string");
            return "symbol" == Jr(e) ? e : e + "";
        }
        var rn =  function() {
            return t = function t(e) {
                var r = this, n = e.input, o = e.ticker, i = void 0 === o ? null : o, a = e.precision, l = void 0 === a || a, s = e.inputParams, f = void 0 === s ? null : s, h = e.chunkProcess, v = void 0 === h ? 2e3 : h;
                if (function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                }(this, t), c(n, "input", null !== i ? "contructor ".concat(i) : "constuctor"), 
                0 === n.length) throw Error("input OHLCV must not be empty: " + i);
                y(l, "precision", "constructor"), p(v, {
                    min: 100,
                    max: 5e4,
                    allowDecimals: !1
                }, "chunkProcess", "constructor"), this.chunkProcess = v, this.firstRow = n[0];
                var m = function(t) {
                    for (var e = {}, r = {}, n = 0, o = Object.entries(t); n < o.length; n++) {
                        var i = ur(o[n], 2), a = i[0], u = i[1];
                        if ("date" === a) e[a] = ar(u), r[a] = "Array"; else if ("volume" === a) e[a] = ze(u, !0), 
                        r[a] = "Int32Array"; else if (cr.has(a)) e[a] = ze(u, !0), r[a] = "Float64Array"; else {
                            var l = ze(u, !1);
                            e[a] = l, r[a] = "number" === l ? "Float64Array" : "Array";
                        }
                    }
                    return {
                        inputTypes: e,
                        arrayTypes: r
                    };
                }(this.firstRow), d = m.inputTypes, b = m.arrayTypes;
                if (this.inputTypes = d, this.arrayTypes = b, !this.firstRow.hasOwnProperty("close")) throw Error('input OHLCV array objects require at least "close" property: '.concat(i));
                return this.dateType = this.inputTypes.date ? this.inputTypes.date : null, this.isComputed = !1, 
                this.input = n, this.priceBased = new Set([ "open", "high", "low", "close" ]), this.len = n.length, 
                this.instances = {}, this.crossPairsList = [], this.verticalOhlcv = {}, this.verticalOhlcvKeyNames = [], 
                this.verticalOhlcvTempCols = new Set, this.utilities = {
                    correlation: Vr
                }, this.invalidValueIndex = -1, this.precision = l, this.precisionMultiplier = Yr(this, this.firstRow), 
                this.scaledGroups = {}, this.pushToMain = function(t) {
                    var e = t.index, n = t.key, o = t.value;
                    return function(t) {
                        var e = t.main, r = t.index, n = t.key, o = t.value, i = e.verticalOhlcv;
                        return null == o || Number.isNaN(o) ? (e.invalidValueIndex = r, i[n][r] = o, !1) : (i[n][r] = o, 
                        !0);
                    }({
                        main: r,
                        index: e,
                        key: n,
                        value: o
                    });
                }, null !== f && (u(f, this.len), this.inputParams = f, this.compute()), this.inputParams = [], 
                this;
            }, e = [ {
                key: "getDataAsCols",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    this.compute();
                    var e = t.skipNull, r = void 0 === e || e, n = t.dateFormat, o = void 0 === n ? "string" : n;
                    f(Object.keys(or), o, "dateFormat", "getDataAsCols"), s(t, "options", "getDataAsCols");
                    for (var i = this.precisionMultiplier, a = this.precision, u = this.invalidValueIndex, l = this.len, c = this.verticalOhlcv, y = this.priceBased, p = this.arrayTypes, h = this.verticalOhlcvTempCols, v = {}, m = r ? u + 1 : 0, d = l - m, b = 0, g = Object.entries(c); b < g.length; b++) {
                        var w = Qr(g[b], 2), O = w[0], S = w[1];
                        if (!h.has(O)) {
                            var j = y.has(O) && a;
                            v[O] = sr(p[O], d);
                            for (var P = m; P < l; P++) v[O][P] = j ? S[P] / i : "date" === O ? or[o](S[P]) : S[P];
                        }
                    }
                    return v;
                }
            }, {
                key: "getData",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    //getData method returns the last object (row) of the new OHLCV with indicators: {open, high, low, close, rsi_14, bollinger_bands_upper}
                                        this.compute();
                    var e = t.skipNull, r = void 0 === e || e, n = t.dateFormat, o = void 0 === n ? "string" : n;
                    return f(Object.keys(or), o, "dateFormat", "getData"), s(t, "options", "getData"), 
                    qr({
                        main: this,
                        skipNull: r,
                        startIndex: 0,
                        dateFormat: o
                    });
                }
            }, {
                key: "getLastValues",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    this.compute();
                    var e = t.dateFormat, r = void 0 === e ? "string" : e;
                    return f(Object.keys(or), r, "dateFormat", "getData"), qr({
                        skipNull: !1,
                        main: this,
                        startIndex: this.len - 1,
                        dateFormat: r
                    })[0];
                }
            }, {
                key: "compute",
                value: function() {
                    // If we've already computed, bail out immediately
                    return this.isComputed || (
                    // Mark as in progress
                    this.isComputed = !1, 
                    // Figure out whether theres a date field in the inputs
                    // Only run the full loop once (or when new data appears later,
                    // if you extend this to reset isComputed elsewhere)
                    this.len > 0 && (function(t, e) {
                        var r = e.len, n = e.inputParams, o = e.priceBased, i = e.precisionMultiplier, a = e.arrayTypes, l = e.verticalOhlcv, c = e.verticalOhlcvKeyNames, s = e.inputTypes, f = e.chunkProcess;
                        u(n, r);
                        for (var y = 0, p = Object.keys(s); y < p.length; y++) {
                            var h = p[y];
                            l[h] = sr(a[h], r);
                        }
                        // Process each row in the input
                                                for (var v = 0; v < r; v += f) for (var m = Math.min(v + f, r), d = v; d < m; d++) {
                            for (var b = t[d], g = 0, w = Object.entries(s); g < w.length; g++) {
                                var O = Cr(w[g], 2), S = O[0], j = O[1], P = b[S];
                                if (qe.hasOwnProperty(j)) {
                                    var _ = qe[j](P);
                                    i > 1 && o.has(S) && (_ *= i), e.pushToMain({
                                        index: d,
                                        key: S,
                                        value: _
                                    });
                                } else ir.hasOwnProperty(j) ? e.pushToMain({
                                    index: d,
                                    key: S,
                                    value: ir[j](P)
                                }) : e.pushToMain({
                                    index: d,
                                    key: S,
                                    value: P
                                });
                            }
                            // Run all indicator functions except for the ones processed later
                                                        var N, T = Rr(n);
                            try {
                                for (T.s(); !(N = T.n()).done; ) {
                                    var A = N.value, E = A.key, k = A.params;
                                    "lag" !== E && "crossPairs" !== E && 
                                    // resolve fn on-demand, no per-item object allocation here
                                    Br[E].apply(Br, [ e, d ].concat(Mr(k)));
                                }
                                // Process these indicators separately (ensuring their execution order)
                                                        } catch (t) {
                                T.e(t);
                            } finally {
                                T.f();
                            }
                            vr(e, d), Pr(e, d), t[d] = null;
                        }
                        c.push.apply(c, Mr(Object.keys(l)));
                    }(this.input, this), this.isComputed = !0, 
                    //flushing after mainLoop
                    this.input = [], this.instances = {}, this.firstRow = [])), this;
                }
            }, {
                key: "crossPairs",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e = "crossPairs";
                    return l(this), c(t, "arr", e), this.crossPairsList = [].concat(Zr(this.crossPairsList), Zr(t)), 
                    this.inputParams.push({
                        key: e,
                        params: [ this.crossPairsList ]
                    }), this;
                }
            }, {
                key: "lag",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [ "close" ], e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, r = "lag";
                    l(this), c(t, "colKeys", r), p(e, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "lookback", r), this.inputParams.push({
                        key: r,
                        params: [ t, e ]
                    });
                    var n, o = function(t, e) {
                        var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!r) {
                            if (Array.isArray(t) || (r = Wr(t)) || e && t && "number" == typeof t.length) {
                                r && (t = r);
                                var n = 0, o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return n >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[n++]
                                        };
                                    },
                                    e: function(t) {
                                        throw t;
                                    },
                                    f: o
                                };
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }
                        var i, a = !0, u = !1;
                        return {
                            s: function() {
                                r = r.call(t);
                            },
                            n: function() {
                                var t = r.next();
                                return a = t.done, t;
                            },
                            e: function(t) {
                                u = !0, i = t;
                            },
                            f: function() {
                                try {
                                    a || null == r.return || r.return();
                                } finally {
                                    if (u) throw i;
                                }
                            }
                        };
                    }(t);
                    try {
                        for (o.s(); !(n = o.n()).done; ) {
                            var i = n.value;
                            this.priceBased.has(i) && this.priceBased.add(i);
                        }
                    } catch (t) {
                        o.e(t);
                    } finally {
                        o.f();
                    }
                    return this;
                }
            }, {
                key: "relativeVolume",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = "relativeVolume";
                    if (!this.inputTypes.hasOwnProperty("volume")) throw new Error('If "relativeVolume" is called the input ohlcv must contain valid volume properties.');
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", r), s(e, "options", r);
                    var n = e.lag, o = void 0 === n ? 0 : n;
                    return p(o, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", r), this.inputParams.push({
                        key: r,
                        params: [ t, {
                            lag: o
                        } ]
                    }), this;
                }
            }, {
                key: "atr",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 14, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = "atr";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", r), s(e, "options", r);
                    var n = e.lag, o = void 0 === n ? 0 : n, i = e.type, a = void 0 === i ? "price" : i;
                    return p(o, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", r), f([ "price", "percentage" ], a, "options.type", r), this.inputParams.push({
                        key: r,
                        params: [ t, {
                            lag: o,
                            type: a
                        } ]
                    }), this;
                }
            }, {
                key: "ema",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = "ema";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", r), s(e, "options", r);
                    var n = e.target, o = void 0 === n ? "close" : n, i = e.lag, a = void 0 === i ? 0 : i;
                    p(a, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", r);
                    var u = Fe({
                        main: this,
                        size: t,
                        target: o,
                        lag: a,
                        methodName: r
                    });
                    return this.inputParams.push({
                        key: r,
                        params: [ r, t, {
                            target: o,
                            lag: a,
                            precomputed: u
                        } ]
                    }), this;
                }
            }, {
                key: "sma",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = "sma";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", r), s(e, "options", r);
                    var n = e.target, o = void 0 === n ? "close" : n, i = e.lag, a = void 0 === i ? 0 : i;
                    p(a, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", r);
                    var u = Fe({
                        main: this,
                        size: t,
                        target: o,
                        lag: a,
                        methodName: r
                    });
                    return this.inputParams.push({
                        key: r,
                        params: [ r, t, {
                            target: o,
                            lag: a,
                            precomputed: u
                        } ]
                    }), this;
                }
            }, {
                key: "macd",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 12, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 26, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 9, n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, o = "macd";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "fast", o), p(e, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "slow", o), p(r, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "signal", o), s(n, "options", o);
                    var i = n.target, a = void 0 === i ? "close" : i, u = n.lag, c = void 0 === u ? 0 : u;
                    p(c, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", o);
                    var f = {
                        instanceKey: "".concat(t, "_").concat(e, "_").concat(r).concat("close" === a ? "" : "_".concat(a))
                    };
                    return this.inputParams.push({
                        key: o,
                        params: [ t, e, r, {
                            target: a,
                            lag: c,
                            precomputed: f
                        } ]
                    }), this;
                }
            }, {
                key: "bollingerBands",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 20, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = "bollingerBands";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", n), p(e, {
                        min: .01,
                        max: 50,
                        allowDecimals: !0
                    }, "stdDev", n), s(r, "options", n);
                    var o = r.target, i = void 0 === o ? "close" : o, a = r.height, u = void 0 !== a && a, f = r.range, h = void 0 === f ? [] : f, v = r.lag, m = void 0 === v ? 0 : v, d = r.decimals, b = void 0 === d ? null : d;
                    return c(h, "options.range", n), p(m, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", n), y(u, "options.height", n), null !== b && p(b, {
                        min: 1,
                        max: 15,
                        allowDecimals: !1
                    }, "decimals", n), this.inputParams.push({
                        key: n,
                        params: [ t, e, {
                            target: i,
                            height: u,
                            range: h,
                            lag: m,
                            decimals: b
                        } ]
                    }), this;
                }
            }, {
                key: "rsi",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 14, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = "rsi";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", r), s(e, "options", r);
                    var n = e.target, o = void 0 === n ? "close" : n, i = e.lag, a = void 0 === i ? 0 : i;
                    return p(a, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", r), this.inputParams.push({
                        key: r,
                        params: [ t, {
                            target: o,
                            lag: a
                        } ]
                    }), this;
                }
            }, {
                key: "donchianChannels",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 20, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = "donchianChannels";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", n), p(e, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "offset", n), s(r, "options", n);
                    var o = r.height, i = void 0 !== o && o, a = r.range, u = void 0 === a ? [] : a, f = r.lag, h = void 0 === f ? 0 : f, v = r.decimals, m = void 0 === v ? null : v;
                    return c(u, "options.range", n), p(h, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", n), y(i, "options.height", n), null !== m && p(m, {
                        min: 1,
                        max: 15,
                        allowDecimals: !1
                    }, "decimals", n), this.inputParams.push({
                        key: n,
                        params: [ t, e, {
                            height: i,
                            range: u,
                            lag: h,
                            decimals: m
                        } ]
                    }), this;
                }
            }, {
                key: "volumeOscillator",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = "volumeOscillator";
                    if (!this.inputTypes.hasOwnProperty("volume")) throw new Error('If "volumeOscillator" is called the input ohlcv must contain valid volume properties.');
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "fastSize", n), p(e, {
                        min: t,
                        max: this.len,
                        allowDecimals: !1
                    }, "slowSize", n), s(r, "options", n);
                    var o = r.lag, i = void 0 === o ? 0 : o;
                    return p(i, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", n), this.inputParams.push({
                        key: n,
                        params: [ t, e, {
                            lag: i
                        } ]
                    }), this;
                }
            }, {
                key: "dateTime",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = "dateTime";
                    l(this), s(t, "options", e);
                    var r = t.lag, n = void 0 === r ? 0 : r;
                    return p(n, {
                        min: 0,
                        max: this.len,
                        allowDecimals: !1
                    }, "options.lag", e), this.inputParams.push({
                        key: e,
                        params: [ {
                            lag: n
                        } ]
                    }), this;
                }
            }, {
                key: "scaler",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, o = "scaler";
                    l(this), p(t, {
                        min: 1,
                        max: this.len,
                        allowDecimals: !1
                    }, "size", o), c(e, "colKeys", o);
                    var i = n.group, a = void 0 !== i && i, u = n.range, s = void 0 === u ? [ 0, 1 ] : u, h = n.lag, v = void 0 === h ? 0 : h, m = n.type, d = void 0 === m ? "minmax" : m, b = n.decimals, g = void 0 === b ? null : b;
                    y(a, "options.group", o), function(t, e, n) {
                        if (c(t, e, n), 2 !== t.length) throw new Error('Invalid "'.concat(e, '" array length: expected 2 items, but got ').concat(t.length, ' in "').concat(n, ".").concat(e, '".'));
                        var o = r(t, 2), i = o[0], a = o[1];
                        if (p(i, {
                            min: -100,
                            max: a,
                            allowDecimals: !1
                        }, "min", n), p(a, {
                            min: i,
                            max: 100,
                            allowDecimals: !1
                        }, "max", n), i === a) throw new Error('Invalid "min" can not be equal to "max" property in "'.concat(n, ".").concat(e, '".'));
                    }(s, "options.range", o), f([ "minmax", "zscore" ], d, "options.type", o), null !== g && p(g, {
                        min: 1,
                        max: 15,
                        allowDecimals: !1
                    }, "decimals", o);
                    var w = {
                        groupKey: a ? "".concat(d, "_").concat(t, "_group_").concat(e.join("_")) : "",
                        groupKeyLen: e.length
                    };
                    return this.inputParams.push({
                        key: o,
                        params: [ t, e, {
                            type: d,
                            group: a,
                            range: s,
                            lag: v,
                            precomputed: w,
                            decimals: g
                        } ]
                    }), this;
                }
            } ], e && tn(t.prototype, e), n && tn(t, n), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t;
            var t, e, n;
        }();
    })(), OHLCV_INDICATORS = e;
})
/******/ ();